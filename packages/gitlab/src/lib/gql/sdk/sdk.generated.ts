import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { gql } from 'graphql-request';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A `AchievementsAchievementID` is a global ID. It is encoded as a string.
   *
   * An example `AchievementsAchievementID` is: `"gid://gitlab/Achievements::Achievement/1"`.
   */
  AchievementsAchievementID: any;
  /**
   * A `AchievementsUserAchievementID` is a global ID. It is encoded as a string.
   *
   * An example `AchievementsUserAchievementID` is: `"gid://gitlab/Achievements::UserAchievement/1"`.
   */
  AchievementsUserAchievementID: any;
  /**
   * A `AiModelID` is a global ID. It is encoded as a string.
   *
   * An example `AiModelID` is: `"gid://gitlab/Ai::Model/1"`.
   */
  AiModelID: any;
  /**
   * A `AlertManagementAlertID` is a global ID. It is encoded as a string.
   *
   * An example `AlertManagementAlertID` is: `"gid://gitlab/AlertManagement::Alert/1"`.
   */
  AlertManagementAlertID: any;
  /**
   * A `AlertManagementHttpIntegrationID` is a global ID. It is encoded as a string.
   *
   * An example `AlertManagementHttpIntegrationID` is: `"gid://gitlab/AlertManagement::HttpIntegration/1"`.
   */
  AlertManagementHttpIntegrationID: any;
  /**
   * A `AnalyticsDevopsAdoptionEnabledNamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `AnalyticsDevopsAdoptionEnabledNamespaceID` is: `"gid://gitlab/Analytics::DevopsAdoption::EnabledNamespace/1"`.
   */
  AnalyticsDevopsAdoptionEnabledNamespaceID: any;
  /**
   * A `AppSecFuzzingCoverageCorpusID` is a global ID. It is encoded as a string.
   *
   * An example `AppSecFuzzingCoverageCorpusID` is: `"gid://gitlab/AppSec::Fuzzing::Coverage::Corpus/1"`.
   */
  AppSecFuzzingCoverageCorpusID: any;
  /**
   * A `AuditEventsExternalAuditEventDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsExternalAuditEventDestinationID` is: `"gid://gitlab/AuditEvents::ExternalAuditEventDestination/1"`.
   */
  AuditEventsExternalAuditEventDestinationID: any;
  /**
   * A `AuditEventsGoogleCloudLoggingConfigurationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsGoogleCloudLoggingConfigurationID` is:
   * `"gid://gitlab/AuditEvents::GoogleCloudLoggingConfiguration/1"`.
   */
  AuditEventsGoogleCloudLoggingConfigurationID: any;
  /**
   * A `AuditEventsInstanceExternalAuditEventDestinationID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsInstanceExternalAuditEventDestinationID` is:
   * `"gid://gitlab/AuditEvents::InstanceExternalAuditEventDestination/1"`.
   */
  AuditEventsInstanceExternalAuditEventDestinationID: any;
  /**
   * A `AuditEventsStreamingHeaderID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsStreamingHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::Header/1"`.
   */
  AuditEventsStreamingHeaderID: any;
  /**
   * A `AuditEventsStreamingInstanceHeaderID` is a global ID. It is encoded as a string.
   *
   * An example `AuditEventsStreamingInstanceHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::InstanceHeader/1"`.
   */
  AuditEventsStreamingInstanceHeaderID: any;
  /**
   * A `AwardableID` is a global ID. It is encoded as a string.
   *
   * An example `AwardableID` is: `"gid://gitlab/Awardable/1"`.
   */
  AwardableID: any;
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: any;
  /**
   * A `BoardID` is a global ID. It is encoded as a string.
   *
   * An example `BoardID` is: `"gid://gitlab/Board/1"`.
   */
  BoardID: any;
  /**
   * A `BoardsEpicBoardID` is a global ID. It is encoded as a string.
   *
   * An example `BoardsEpicBoardID` is: `"gid://gitlab/Boards::EpicBoard/1"`.
   */
  BoardsEpicBoardID: any;
  /**
   * A `BoardsEpicListID` is a global ID. It is encoded as a string.
   *
   * An example `BoardsEpicListID` is: `"gid://gitlab/Boards::EpicList/1"`.
   */
  BoardsEpicListID: any;
  /**
   * A `CiBuildID` is a global ID. It is encoded as a string.
   *
   * An example `CiBuildID` is: `"gid://gitlab/Ci::Build/1"`.
   */
  CiBuildID: any;
  /**
   * A `CiCatalogResourceID` is a global ID. It is encoded as a string.
   *
   * An example `CiCatalogResourceID` is: `"gid://gitlab/Ci::Catalog::Resource/1"`.
   */
  CiCatalogResourceID: any;
  /**
   * A `CiJobArtifactID` is a global ID. It is encoded as a string.
   *
   * An example `CiJobArtifactID` is: `"gid://gitlab/Ci::JobArtifact/1"`.
   */
  CiJobArtifactID: any;
  /**
   * A `CiPipelineID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineID` is: `"gid://gitlab/Ci::Pipeline/1"`.
   */
  CiPipelineID: any;
  /**
   * A `CiPipelineScheduleID` is a global ID. It is encoded as a string.
   *
   * An example `CiPipelineScheduleID` is: `"gid://gitlab/Ci::PipelineSchedule/1"`.
   */
  CiPipelineScheduleID: any;
  /**
   * A `CiRunnerID` is a global ID. It is encoded as a string.
   *
   * An example `CiRunnerID` is: `"gid://gitlab/Ci::Runner/1"`.
   */
  CiRunnerID: any;
  /**
   * A `CiRunnerManagerID` is a global ID. It is encoded as a string.
   *
   * An example `CiRunnerManagerID` is: `"gid://gitlab/Ci::RunnerManager/1"`.
   */
  CiRunnerManagerID: any;
  /**
   * A `CiStageID` is a global ID. It is encoded as a string.
   *
   * An example `CiStageID` is: `"gid://gitlab/Ci::Stage/1"`.
   */
  CiStageID: any;
  /**
   * A `ClustersAgentID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentID` is: `"gid://gitlab/Clusters::Agent/1"`.
   */
  ClustersAgentID: any;
  /**
   * A `ClustersAgentTokenID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersAgentTokenID` is: `"gid://gitlab/Clusters::AgentToken/1"`.
   */
  ClustersAgentTokenID: any;
  /**
   * A `ClustersClusterID` is a global ID. It is encoded as a string.
   *
   * An example `ClustersClusterID` is: `"gid://gitlab/Clusters::Cluster/1"`.
   */
  ClustersClusterID: any;
  /**
   * Color represented as a hex code or named color.
   *
   * For example: "#fefefe".
   */
  Color: any;
  /**
   * A `ComplianceManagementFrameworkID` is a global ID. It is encoded as a string.
   *
   * An example `ComplianceManagementFrameworkID` is: `"gid://gitlab/ComplianceManagement::Framework/1"`.
   */
  ComplianceManagementFrameworkID: any;
  /**
   * A `ContainerRepositoryID` is a global ID. It is encoded as a string.
   *
   * An example `ContainerRepositoryID` is: `"gid://gitlab/ContainerRepository/1"`.
   */
  ContainerRepositoryID: any;
  /**
   * A `CustomEmojiID` is a global ID. It is encoded as a string.
   *
   * An example `CustomEmojiID` is: `"gid://gitlab/CustomEmoji/1"`.
   */
  CustomEmojiID: any;
  /**
   * A `CustomerRelationsContactID` is a global ID. It is encoded as a string.
   *
   * An example `CustomerRelationsContactID` is: `"gid://gitlab/CustomerRelations::Contact/1"`.
   */
  CustomerRelationsContactID: any;
  /**
   * A `CustomerRelationsOrganizationID` is a global ID. It is encoded as a string.
   *
   * An example `CustomerRelationsOrganizationID` is: `"gid://gitlab/CustomerRelations::Organization/1"`.
   */
  CustomerRelationsOrganizationID: any;
  /**
   * A `DastProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastProfileID` is: `"gid://gitlab/Dast::Profile/1"`.
   */
  DastProfileID: any;
  /**
   * A `DastProfileScheduleID` is a global ID. It is encoded as a string.
   *
   * An example `DastProfileScheduleID` is: `"gid://gitlab/Dast::ProfileSchedule/1"`.
   */
  DastProfileScheduleID: any;
  /**
   * A `DastScannerProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastScannerProfileID` is: `"gid://gitlab/DastScannerProfile/1"`.
   */
  DastScannerProfileID: any;
  /**
   * A `DastSiteProfileID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteProfileID` is: `"gid://gitlab/DastSiteProfile/1"`.
   */
  DastSiteProfileID: any;
  /**
   * A `DastSiteTokenID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteTokenID` is: `"gid://gitlab/DastSiteToken/1"`.
   */
  DastSiteTokenID: any;
  /**
   * A `DastSiteValidationID` is a global ID. It is encoded as a string.
   *
   * An example `DastSiteValidationID` is: `"gid://gitlab/DastSiteValidation/1"`.
   */
  DastSiteValidationID: any;
  /** Date represented in ISO 8601 */
  Date: any;
  /**
   * A `DependencyProxyManifestID` is a global ID. It is encoded as a string.
   *
   * An example `DependencyProxyManifestID` is: `"gid://gitlab/DependencyProxy::Manifest/1"`.
   */
  DependencyProxyManifestID: any;
  /**
   * A `DeploymentID` is a global ID. It is encoded as a string.
   *
   * An example `DeploymentID` is: `"gid://gitlab/Deployment/1"`.
   */
  DeploymentID: any;
  /**
   * A `DescriptionVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DescriptionVersionID` is: `"gid://gitlab/DescriptionVersion/1"`.
   */
  DescriptionVersionID: any;
  /**
   * A `DesignManagementDesignAtVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementDesignAtVersionID` is: `"gid://gitlab/DesignManagement::DesignAtVersion/1"`.
   */
  DesignManagementDesignAtVersionID: any;
  /**
   * A `DesignManagementDesignID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementDesignID` is: `"gid://gitlab/DesignManagement::Design/1"`.
   */
  DesignManagementDesignID: any;
  /**
   * A `DesignManagementVersionID` is a global ID. It is encoded as a string.
   *
   * An example `DesignManagementVersionID` is: `"gid://gitlab/DesignManagement::Version/1"`.
   */
  DesignManagementVersionID: any;
  /**
   * A `DiffNoteID` is a global ID. It is encoded as a string.
   *
   * An example `DiffNoteID` is: `"gid://gitlab/DiffNote/1"`.
   */
  DiffNoteID: any;
  /**
   * A `DiscussionID` is a global ID. It is encoded as a string.
   *
   * An example `DiscussionID` is: `"gid://gitlab/Discussion/1"`.
   */
  DiscussionID: any;
  /**
   * Duration between two instants, represented as a fractional number of seconds.
   *
   * For example: 12.3334
   */
  Duration: any;
  /**
   * A `EmailID` is a global ID. It is encoded as a string.
   *
   * An example `EmailID` is: `"gid://gitlab/Email/1"`.
   */
  EmailID: any;
  /**
   * A `EnvironmentID` is a global ID. It is encoded as a string.
   *
   * An example `EnvironmentID` is: `"gid://gitlab/Environment/1"`.
   */
  EnvironmentID: any;
  /**
   * A `EpicID` is a global ID. It is encoded as a string.
   *
   * An example `EpicID` is: `"gid://gitlab/Epic/1"`.
   */
  EpicID: any;
  /**
   * A `EpicTreeSortingID` is a global ID. It is encoded as a string.
   *
   * An example `EpicTreeSortingID` is: `"gid://gitlab/EpicTreeSorting/1"`.
   */
  EpicTreeSortingID: any;
  /**
   * A `GeoBaseRegistryID` is a global ID. It is encoded as a string.
   *
   * An example `GeoBaseRegistryID` is: `"gid://gitlab/Geo::BaseRegistry/1"`.
   */
  GeoBaseRegistryID: any;
  /**
   * A `GitlabErrorTrackingDetailedErrorID` is a global ID. It is encoded as a string.
   *
   * An example `GitlabErrorTrackingDetailedErrorID` is: `"gid://gitlab/Gitlab::ErrorTracking::DetailedError/1"`.
   */
  GitlabErrorTrackingDetailedErrorID: any;
  /**
   * A global identifier.
   *
   * A global identifier represents an object uniquely across the application.
   * An example of a global identifier is `"gid://gitlab/User/1"`.
   *
   * `gid://gitlab` stands for the root name.
   * `User` is the name of the ActiveRecord class of the record.
   * `1` is the record id as per the id in the db table.
   *
   * Global identifiers are encoded as strings.
   */
  GlobalID: any;
  /**
   * A `GroupID` is a global ID. It is encoded as a string.
   *
   * An example `GroupID` is: `"gid://gitlab/Group/1"`.
   */
  GroupID: any;
  /** An ISO 8601-encoded date */
  ISO8601Date: any;
  /**
   * A `IncidentManagementEscalationPolicyID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementEscalationPolicyID` is: `"gid://gitlab/IncidentManagement::EscalationPolicy/1"`.
   */
  IncidentManagementEscalationPolicyID: any;
  /**
   * A `IncidentManagementEscalationRuleID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementEscalationRuleID` is: `"gid://gitlab/IncidentManagement::EscalationRule/1"`.
   */
  IncidentManagementEscalationRuleID: any;
  /**
   * A `IncidentManagementIssuableResourceLinkID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementIssuableResourceLinkID` is: `"gid://gitlab/IncidentManagement::IssuableResourceLink/1"`.
   */
  IncidentManagementIssuableResourceLinkID: any;
  /**
   * A `IncidentManagementOncallParticipantID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementOncallParticipantID` is: `"gid://gitlab/IncidentManagement::OncallParticipant/1"`.
   */
  IncidentManagementOncallParticipantID: any;
  /**
   * A `IncidentManagementOncallRotationID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementOncallRotationID` is: `"gid://gitlab/IncidentManagement::OncallRotation/1"`.
   */
  IncidentManagementOncallRotationID: any;
  /**
   * A `IncidentManagementTimelineEventID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementTimelineEventID` is: `"gid://gitlab/IncidentManagement::TimelineEvent/1"`.
   */
  IncidentManagementTimelineEventID: any;
  /**
   * A `IncidentManagementTimelineEventTagID` is a global ID. It is encoded as a string.
   *
   * An example `IncidentManagementTimelineEventTagID` is: `"gid://gitlab/IncidentManagement::TimelineEventTag/1"`.
   */
  IncidentManagementTimelineEventTagID: any;
  /**
   * A `IntegrationsPrometheusID` is a global ID. It is encoded as a string.
   *
   * An example `IntegrationsPrometheusID` is: `"gid://gitlab/Integrations::Prometheus/1"`.
   * The older format `"gid://gitlab/PrometheusService/1"` was deprecated in 14.1.
   */
  IntegrationsPrometheusID: any;
  /**
   * A `IssuableID` is a global ID. It is encoded as a string.
   *
   * An example `IssuableID` is: `"gid://gitlab/Issuable/1"`.
   */
  IssuableID: any;
  /**
   * A `IssueID` is a global ID. It is encoded as a string.
   *
   * An example `IssueID` is: `"gid://gitlab/Issue/1"`.
   */
  IssueID: any;
  /**
   * A `IssueParentID` is a global ID. It is encoded as a string.
   *
   * An example `IssueParentID` is: `"gid://gitlab/IssueParent/1"`.
   */
  IssueParentID: any;
  /**
   * A `IterationID` is a global ID. It is encoded as a string.
   *
   * An example `IterationID` is: `"gid://gitlab/Iteration/1"`.
   * The older format `"gid://gitlab/EEIteration/1"` was deprecated in 13.3.
   */
  IterationID: any;
  /**
   * A `IterationsCadenceID` is a global ID. It is encoded as a string.
   *
   * An example `IterationsCadenceID` is: `"gid://gitlab/Iterations::Cadence/1"`.
   */
  IterationsCadenceID: any;
  /** Represents untyped JSON */
  JSON: any;
  /**
   * A `CommitStatusID` is a global ID. It is encoded as a string.
   *
   * An example `CommitStatusID` is: `"gid://gitlab/CommitStatus/1"`.
   */
  JobID: any;
  /** JSON object as raw string */
  JsonString: any;
  /**
   * A `LabelID` is a global ID. It is encoded as a string.
   *
   * An example `LabelID` is: `"gid://gitlab/Label/1"`.
   */
  LabelID: any;
  /**
   * A `ListID` is a global ID. It is encoded as a string.
   *
   * An example `ListID` is: `"gid://gitlab/List/1"`.
   */
  ListID: any;
  /**
   * A `MergeRequestID` is a global ID. It is encoded as a string.
   *
   * An example `MergeRequestID` is: `"gid://gitlab/MergeRequest/1"`.
   */
  MergeRequestID: any;
  /**
   * A `MetricsDashboardAnnotationID` is a global ID. It is encoded as a string.
   *
   * An example `MetricsDashboardAnnotationID` is: `"gid://gitlab/Metrics::Dashboard::Annotation/1"`.
   */
  MetricsDashboardAnnotationID: any;
  /**
   * A `MilestoneID` is a global ID. It is encoded as a string.
   *
   * An example `MilestoneID` is: `"gid://gitlab/Milestone/1"`.
   */
  MilestoneID: any;
  /**
   * A `NamespaceID` is a global ID. It is encoded as a string.
   *
   * An example `NamespaceID` is: `"gid://gitlab/Namespace/1"`.
   */
  NamespaceID: any;
  /**
   * A `NamespacesNamespaceBanID` is a global ID. It is encoded as a string.
   *
   * An example `NamespacesNamespaceBanID` is: `"gid://gitlab/Namespaces::NamespaceBan/1"`.
   */
  NamespacesNamespaceBanID: any;
  /**
   * A `NoteID` is a global ID. It is encoded as a string.
   *
   * An example `NoteID` is: `"gid://gitlab/Note/1"`.
   */
  NoteID: any;
  /**
   * A `NoteableID` is a global ID. It is encoded as a string.
   *
   * An example `NoteableID` is: `"gid://gitlab/Noteable/1"`.
   */
  NoteableID: any;
  /**
   * A `PackagesConanFileMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesConanFileMetadatumID` is: `"gid://gitlab/Packages::Conan::FileMetadatum/1"`.
   */
  PackagesConanFileMetadatumID: any;
  /**
   * A `PackagesConanMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesConanMetadatumID` is: `"gid://gitlab/Packages::Conan::Metadatum/1"`.
   */
  PackagesConanMetadatumID: any;
  /**
   * A `PackagesDependencyID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesDependencyID` is: `"gid://gitlab/Packages::Dependency/1"`.
   */
  PackagesDependencyID: any;
  /**
   * A `PackagesDependencyLinkID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesDependencyLinkID` is: `"gid://gitlab/Packages::DependencyLink/1"`.
   */
  PackagesDependencyLinkID: any;
  /**
   * A `PackagesMavenMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesMavenMetadatumID` is: `"gid://gitlab/Packages::Maven::Metadatum/1"`.
   */
  PackagesMavenMetadatumID: any;
  /**
   * A `PackagesNugetDependencyLinkMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesNugetDependencyLinkMetadatumID` is: `"gid://gitlab/Packages::Nuget::DependencyLinkMetadatum/1"`.
   */
  PackagesNugetDependencyLinkMetadatumID: any;
  /**
   * A `PackagesNugetMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesNugetMetadatumID` is: `"gid://gitlab/Packages::Nuget::Metadatum/1"`.
   */
  PackagesNugetMetadatumID: any;
  /**
   * A `PackagesPackageFileID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPackageFileID` is: `"gid://gitlab/Packages::PackageFile/1"`.
   */
  PackagesPackageFileID: any;
  /**
   * A `PackagesPackageID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPackageID` is: `"gid://gitlab/Packages::Package/1"`.
   */
  PackagesPackageID: any;
  /**
   * A `PackagesPypiMetadatumID` is a global ID. It is encoded as a string.
   *
   * An example `PackagesPypiMetadatumID` is: `"gid://gitlab/Packages::Pypi::Metadatum/1"`.
   */
  PackagesPypiMetadatumID: any;
  /**
   * A `PathLockID` is a global ID. It is encoded as a string.
   *
   * An example `PathLockID` is: `"gid://gitlab/PathLock/1"`.
   */
  PathLockID: any;
  /** String or integer. */
  PayloadAlertFieldPathSegment: any;
  /**
   * A `ProjectID` is a global ID. It is encoded as a string.
   *
   * An example `ProjectID` is: `"gid://gitlab/Project/1"`.
   */
  ProjectID: any;
  /**
   * A `ReleaseID` is a global ID. It is encoded as a string.
   *
   * An example `ReleaseID` is: `"gid://gitlab/Release/1"`.
   */
  ReleaseID: any;
  /**
   * A `ReleasesLinkID` is a global ID. It is encoded as a string.
   *
   * An example `ReleasesLinkID` is: `"gid://gitlab/Releases::Link/1"`.
   */
  ReleasesLinkID: any;
  /**
   * A `RemoteDevelopmentWorkspaceID` is a global ID. It is encoded as a string.
   *
   * An example `RemoteDevelopmentWorkspaceID` is: `"gid://gitlab/RemoteDevelopment::Workspace/1"`.
   */
  RemoteDevelopmentWorkspaceID: any;
  /**
   * A `SecurityTrainingProviderID` is a global ID. It is encoded as a string.
   *
   * An example `SecurityTrainingProviderID` is: `"gid://gitlab/Security::TrainingProvider/1"`.
   */
  SecurityTrainingProviderID: any;
  /**
   * A `SnippetID` is a global ID. It is encoded as a string.
   *
   * An example `SnippetID` is: `"gid://gitlab/Snippet/1"`.
   */
  SnippetID: any;
  /**
   * A `SystemNoteMetadataID` is a global ID. It is encoded as a string.
   *
   * An example `SystemNoteMetadataID` is: `"gid://gitlab/SystemNoteMetadata/1"`.
   */
  SystemNoteMetadataID: any;
  /**
   * A `TerraformStateID` is a global ID. It is encoded as a string.
   *
   * An example `TerraformStateID` is: `"gid://gitlab/Terraform::State/1"`.
   */
  TerraformStateID: any;
  /**
   * Time represented in ISO 8601.
   *
   * For example: "2021-03-09T14:58:50+00:00".
   *
   * See `https://www.iso.org/iso-8601-date-and-time-format.html`.
   */
  Time: any;
  /**
   * A `TimelogID` is a global ID. It is encoded as a string.
   *
   * An example `TimelogID` is: `"gid://gitlab/Timelog/1"`.
   */
  TimelogID: any;
  /**
   * A `TodoID` is a global ID. It is encoded as a string.
   *
   * An example `TodoID` is: `"gid://gitlab/Todo/1"`.
   */
  TodoID: any;
  /**
   * A `TodoableID` is a global ID. It is encoded as a string.
   *
   * An example `TodoableID` is: `"gid://gitlab/Todoable/1"`.
   */
  TodoableID: any;
  /** A regexp containing patterns sourced from user input */
  UntrustedRegexp: any;
  Upload: any;
  /**
   * A `UploadID` is a global ID. It is encoded as a string.
   *
   * An example `UploadID` is: `"gid://gitlab/Upload/1"`.
   */
  UploadID: any;
  /**
   * A `UserID` is a global ID. It is encoded as a string.
   *
   * An example `UserID` is: `"gid://gitlab/User/1"`.
   */
  UserID: any;
  /**
   * A `UsersSavedReplyID` is a global ID. It is encoded as a string.
   *
   * An example `UsersSavedReplyID` is: `"gid://gitlab/Users::SavedReply/1"`.
   */
  UsersSavedReplyID: any;
  /**
   * A `VulnerabilitiesExternalIssueLinkID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesExternalIssueLinkID` is: `"gid://gitlab/Vulnerabilities::ExternalIssueLink/1"`.
   */
  VulnerabilitiesExternalIssueLinkID: any;
  /**
   * A `VulnerabilitiesScannerID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilitiesScannerID` is: `"gid://gitlab/Vulnerabilities::Scanner/1"`.
   */
  VulnerabilitiesScannerID: any;
  /**
   * A `VulnerabilityID` is a global ID. It is encoded as a string.
   *
   * An example `VulnerabilityID` is: `"gid://gitlab/Vulnerability/1"`.
   */
  VulnerabilityID: any;
  /**
   * A `WorkItemID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemID` is: `"gid://gitlab/WorkItem/1"`.
   *
   * While we transition from Issues into Work Items this type will temporarily support
   * `IssueID` like: `"gid://gitlab/Issue/1"`. This behavior will be removed without notice in the future.
   */
  WorkItemID: any;
  /**
   * A `WorkItemsTypeID` is a global ID. It is encoded as a string.
   *
   * An example `WorkItemsTypeID` is: `"gid://gitlab/WorkItems::Type/1"`.
   */
  WorkItemsTypeID: any;
};

/** Represents the access level of a relationship between a User and object that it is related to */
export type AccessLevel = {
  __typename?: 'AccessLevel';
  /** Integer representation of access level. */
  integerValue?: Maybe<Scalars['Int']>;
  /** String representation of access level. */
  stringValue?: Maybe<AccessLevelEnum>;
};

/** Access level to a resource */
export type AccessLevelEnum =
  /** Admin access. */
  | 'ADMIN'
  /** Developer access. */
  | 'DEVELOPER'
  /** Guest access. */
  | 'GUEST'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Minimal access. */
  | 'MINIMAL_ACCESS'
  /** No access. */
  | 'NO_ACCESS'
  /** Owner access. */
  | 'OWNER'
  /** Reporter access. */
  | 'REPORTER';

/** Representation of a GitLab group. */
export type AccessLevelGroup = {
  __typename?: 'AccessLevelGroup';
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** ID of the group. */
  id: Scalars['ID'];
  /** Name of the group. */
  name: Scalars['String'];
  /** Parent group. */
  parent?: Maybe<AccessLevelGroup>;
  /** Web URL of the group. */
  webUrl: Scalars['String'];
};

/** Representation of a GitLab user. */
export type AccessLevelUser = {
  __typename?: 'AccessLevelUser';
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** ID of the user. */
  id: Scalars['ID'];
  /**
   * Human-readable name of the user.
   * Returns `****` if the user is a project bot and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
};

export type Achievement = {
  __typename?: 'Achievement';
  /** URL to avatar of the achievement. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Timestamp the achievement was created. */
  createdAt: Scalars['Time'];
  /** Description or notes for the achievement. */
  description?: Maybe<Scalars['String']>;
  /** ID of the achievement. */
  id: Scalars['AchievementsAchievementID'];
  /** Name of the achievement. */
  name: Scalars['String'];
  /** Namespace of the achievement. */
  namespace?: Maybe<Namespace>;
  /** Timestamp the achievement was last updated. */
  updatedAt: Scalars['Time'];
  /**
   * Recipients for the achievement. Introduced in 15.10: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
};


export type AchievementUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Achievement. */
export type AchievementConnection = {
  __typename?: 'AchievementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AchievementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Achievement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AchievementEdge = {
  __typename?: 'AchievementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Achievement>;
};

/** Autogenerated input type of AchievementsAward */
export type AchievementsAwardInput = {
  /** Global ID of the achievement being awarded. */
  achievementId: Scalars['AchievementsAchievementID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the user being awarded the achievement. */
  userId: Scalars['UserID'];
};

/** Autogenerated return type of AchievementsAward */
export type AchievementsAwardPayload = {
  __typename?: 'AchievementsAwardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Achievement award. */
  userAchievement?: Maybe<UserAchievement>;
};

/** Autogenerated input type of AchievementsCreate */
export type AchievementsCreateInput = {
  /** Avatar for the achievement. */
  avatar?: InputMaybe<Scalars['Upload']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of or notes for the achievement. */
  description?: InputMaybe<Scalars['String']>;
  /** Name for the achievement. */
  name: Scalars['String'];
  /** Namespace for the achievement. */
  namespaceId: Scalars['NamespaceID'];
};

/** Autogenerated return type of AchievementsCreate */
export type AchievementsCreatePayload = {
  __typename?: 'AchievementsCreatePayload';
  /** Achievement created. */
  achievement?: Maybe<Achievement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AchievementsDelete */
export type AchievementsDeleteInput = {
  /** Global ID of the achievement being deleted. */
  achievementId: Scalars['AchievementsAchievementID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AchievementsDelete */
export type AchievementsDeletePayload = {
  __typename?: 'AchievementsDeletePayload';
  /** Achievement. */
  achievement?: Maybe<Achievement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AchievementsRevoke */
export type AchievementsRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the user achievement being revoked. */
  userAchievementId: Scalars['AchievementsUserAchievementID'];
};

/** Autogenerated return type of AchievementsRevoke */
export type AchievementsRevokePayload = {
  __typename?: 'AchievementsRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Achievement award. */
  userAchievement?: Maybe<UserAchievement>;
};

/** Autogenerated input type of AchievementsUpdate */
export type AchievementsUpdateInput = {
  /** Global ID of the achievement being updated. */
  achievementId: Scalars['AchievementsAchievementID'];
  /** Avatar for the achievement. */
  avatar?: InputMaybe<Scalars['Upload']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of or notes for the achievement. */
  description?: InputMaybe<Scalars['String']>;
  /** Name for the achievement. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AchievementsUpdate */
export type AchievementsUpdatePayload = {
  __typename?: 'AchievementsUpdatePayload';
  /** Achievement. */
  achievement?: Maybe<Achievement>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AddProjectToSecurityDashboard */
export type AddProjectToSecurityDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to be added to Instance Security Dashboard. */
  id: Scalars['ProjectID'];
};

/** Autogenerated return type of AddProjectToSecurityDashboard */
export type AddProjectToSecurityDashboardPayload = {
  __typename?: 'AddProjectToSecurityDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project that was added to the Instance Security Dashboard. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of AdminSidekiqQueuesDeleteJobs */
export type AdminSidekiqQueuesDeleteJobsInput = {
  /** Delete jobs matching artifact_size in the context metadata. */
  artifactSize?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifact_used_cdn in the context metadata. */
  artifactUsedCdn?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifacts_dependencies_count in the context metadata. */
  artifactsDependenciesCount?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching artifacts_dependencies_size in the context metadata. */
  artifactsDependenciesSize?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching caller_id in the context metadata. */
  callerId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching client_id in the context metadata. */
  clientId?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching feature_category in the context metadata. */
  featureCategory?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching job_id in the context metadata. */
  jobId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching merge_action_status in the context metadata. */
  mergeActionStatus?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching pipeline_id in the context metadata. */
  pipelineId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching project in the context metadata. */
  project?: InputMaybe<Scalars['String']>;
  /** Name of the queue to delete jobs from. */
  queueName: Scalars['String'];
  /** Delete jobs matching related_class in the context metadata. */
  relatedClass?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching remote_ip in the context metadata. */
  remoteIp?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching root_caller_id in the context metadata. */
  rootCallerId?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching root_namespace in the context metadata. */
  rootNamespace?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching subscription_plan in the context metadata. */
  subscriptionPlan?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching user in the context metadata. */
  user?: InputMaybe<Scalars['String']>;
  /** Delete jobs matching user_id in the context metadata. */
  userId?: InputMaybe<Scalars['String']>;
  /** Delete jobs with the given worker class. */
  workerClass?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AdminSidekiqQueuesDeleteJobs */
export type AdminSidekiqQueuesDeleteJobsPayload = {
  __typename?: 'AdminSidekiqQueuesDeleteJobsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Information about the status of the deletion request. */
  result?: Maybe<DeleteJobsResponse>;
};

/** Configuration details for an Agent */
export type AgentConfiguration = {
  __typename?: 'AgentConfiguration';
  /** Name of the agent. */
  agentName?: Maybe<Scalars['String']>;
};

/** The connection type for AgentConfiguration. */
export type AgentConfigurationConnection = {
  __typename?: 'AgentConfigurationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AgentConfigurationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AgentConfiguration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AgentConfigurationEdge = {
  __typename?: 'AgentConfigurationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AgentConfiguration>;
};

/** Information about a connected Agent */
export type AgentMetadata = {
  __typename?: 'AgentMetadata';
  /** Agent version commit. */
  commit?: Maybe<Scalars['String']>;
  /** Name of the pod running the Agent. */
  podName?: Maybe<Scalars['String']>;
  /** Namespace of the pod running the Agent. */
  podNamespace?: Maybe<Scalars['String']>;
  /** Agent version tag. */
  version?: Maybe<Scalars['String']>;
};

/** Agent token statuses */
export type AgentTokenStatus =
  /** Active agent token. */
  | 'ACTIVE'
  /** Revoked agent token. */
  | 'REVOKED';

/** Autogenerated input type of AiAction */
export type AiActionInput = {
  /** Input for analyze_ci_job_failure AI action. */
  analyzeCiJobFailure?: InputMaybe<AnalyzeCiJobFailureInput>;
  /** Input for chat AI action. */
  chat?: InputMaybe<AiChatInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Input for explain_code AI action. */
  explainCode?: InputMaybe<AiExplainCodeInput>;
  /** Input for explain_vulnerability AI action. */
  explainVulnerability?: InputMaybe<AiExplainVulnerabilityInput>;
  /** Input for fill_in_merge_request_template AI action. */
  fillInMergeRequestTemplate?: InputMaybe<AiFillInMergeRequestTemplateInput>;
  /** Input for generate_commit_message AI action. */
  generateCommitMessage?: InputMaybe<AiGenerateCommitMessageInput>;
  /** Input for generate_description AI action. */
  generateDescription?: InputMaybe<AiGenerateDescriptionInput>;
  /** Input for generate_test_file AI action. */
  generateTestFile?: InputMaybe<GenerateTestFileInput>;
  /** Indicates the response format. */
  markupFormat?: InputMaybe<MarkupFormat>;
  /** Input for summarize_comments AI action. */
  summarizeComments?: InputMaybe<AiSummarizeCommentsInput>;
  /** Input for summarize_review AI action. */
  summarizeReview?: InputMaybe<AiSummarizeReviewInput>;
  /** Input for tanuki_bot AI action. */
  tanukiBot?: InputMaybe<AiTanukiBotInput>;
};

/** Autogenerated return type of AiAction */
export type AiActionPayload = {
  __typename?: 'AiActionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** ID of the request. */
  requestId?: Maybe<Scalars['String']>;
};

/** Roles to filter in chat message. */
export type AiCachedMessageRole =
  /** Filter only assistant messages. */
  | 'ASSISTANT'
  /** Filter only user messages. */
  | 'USER';

export type AiCachedMessageType = {
  __typename?: 'AiCachedMessageType';
  /** Content of the message. Can be null for failed responses. */
  content?: Maybe<Scalars['String']>;
  /** Errors that occurred while asynchronously fetching an AI (assistant) response. */
  errors: Array<Scalars['String']>;
  /** UUID of the message. */
  id?: Maybe<Scalars['ID']>;
  /** UUID of the original request message. */
  requestId?: Maybe<Scalars['ID']>;
  /** Message role. */
  role: AiCachedMessageRole;
  /** Message timestamp. */
  timestamp: Scalars['Time'];
};

/** The connection type for AiCachedMessageType. */
export type AiCachedMessageTypeConnection = {
  __typename?: 'AiCachedMessageTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiCachedMessageTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiCachedMessageType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiCachedMessageTypeEdge = {
  __typename?: 'AiCachedMessageTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AiCachedMessageType>;
};

export type AiChatInput = {
  /** Content of the message. */
  content: Scalars['String'];
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiExplainCodeInput = {
  /** Code messages that is passed to be explained by AI. */
  messages: Array<AiExplainCodeMessageInput>;
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiExplainCodeMessageInput = {
  /** Content of the message. */
  content: Scalars['String'];
  /** Role of the message (system, user, assistant). */
  role: Scalars['String'];
};

export type AiExplainVulnerabilityInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiFillInMergeRequestTemplateInput = {
  /** Template content to fill in. */
  content: Scalars['String'];
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
  /** Source branch of the changes. */
  sourceBranch: Scalars['String'];
  /** ID of the project where the changes are from. */
  sourceProjectId?: InputMaybe<Scalars['ID']>;
  /** Target branch of where the changes will be merged into. */
  targetBranch: Scalars['String'];
  /** Title of the merge request to be created. */
  title: Scalars['String'];
};

export type AiGenerateCommitMessageInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiGenerateDescriptionInput = {
  /** Content of the message. */
  content: Scalars['String'];
  /** Name of the description template to use to generate message off of. */
  descriptionTemplateName?: InputMaybe<Scalars['String']>;
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiMessageType = {
  __typename?: 'AiMessageType';
  /** Content of the message or null if loading. */
  content?: Maybe<Scalars['String']>;
  /** Errors that occurred while asynchronously fetching an AI(assistant) response. */
  errors: Array<Scalars['String']>;
  /** Global ID of the message. */
  id?: Maybe<Scalars['ID']>;
  /** Whether the content is still being fetched, for a message with the assistant role. */
  isFetching?: Maybe<Scalars['Boolean']>;
  /** Role of the message (system, user, assistant). */
  role: Scalars['String'];
};

/** The connection type for AiMessageType. */
export type AiMessageTypeConnection = {
  __typename?: 'AiMessageTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AiMessageTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AiMessageType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AiMessageTypeEdge = {
  __typename?: 'AiMessageTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AiMessageType>;
};

export type AiResponse = {
  __typename?: 'AiResponse';
  /** Errors return by AI API as response. */
  errors?: Maybe<Array<Scalars['String']>>;
  /** ID of the original request. */
  requestId?: Maybe<Scalars['String']>;
  /** Response body from AI API. */
  responseBody?: Maybe<Scalars['String']>;
};

export type AiSummarizeCommentsInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiSummarizeReviewInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type AiTanukiBotInput = {
  /** GitLab documentation question for AI to answer. */
  question: Scalars['String'];
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

/** Describes an alert from the project's Alert Management */
export type AlertManagementAlert = NoteableInterface & Todoable & {
  __typename?: 'AlertManagementAlert';
  /** Assignees of the alert. */
  assignees?: Maybe<UserCoreConnection>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Timestamp the alert was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Description of the alert. */
  description?: Maybe<Scalars['String']>;
  /** Alert details. */
  details?: Maybe<Scalars['JSON']>;
  /** URL of the alert detail page. */
  detailsUrl: Scalars['String'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Timestamp the alert ended. */
  endedAt?: Maybe<Scalars['Time']>;
  /** Environment for the alert. */
  environment?: Maybe<Environment>;
  /** Number of events of this alert. */
  eventCount?: Maybe<Scalars['Int']>;
  /** List of hosts the alert came from. */
  hosts?: Maybe<Array<Scalars['String']>>;
  /** ID of the alert. */
  id: Scalars['ID'];
  /** Internal ID of the alert. */
  iid: Scalars['ID'];
  /** Issue attached to the alert. */
  issue?: Maybe<Issue>;
  /**
   * Internal ID of the GitLab issue attached to the alert. Deprecated in 13.10: Use issue field.
   * @deprecated Use issue field. Deprecated in 13.10.
   */
  issueIid?: Maybe<Scalars['ID']>;
  /** Monitoring tool the alert came from. */
  monitoringTool?: Maybe<Scalars['String']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Alert condition for Prometheus. */
  prometheusAlert?: Maybe<PrometheusAlert>;
  /** Runbook for the alert as defined in alert details. */
  runbook?: Maybe<Scalars['String']>;
  /** Service the alert came from. */
  service?: Maybe<Scalars['String']>;
  /** Severity of the alert. */
  severity?: Maybe<AlertManagementSeverity>;
  /** Timestamp the alert was raised. */
  startedAt?: Maybe<Scalars['Time']>;
  /** Status of the alert. */
  status?: Maybe<AlertManagementStatus>;
  /** Title of the alert. */
  title?: Maybe<Scalars['String']>;
  /** To-do items of the current user for the alert. */
  todos?: Maybe<TodoConnection>;
  /** Timestamp the alert was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** URL of the alert. */
  webUrl: Scalars['String'];
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an alert from the project's Alert Management */
export type AlertManagementAlertTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};

/** The connection type for AlertManagementAlert. */
export type AlertManagementAlertConnection = {
  __typename?: 'AlertManagementAlertConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementAlertEdge = {
  __typename?: 'AlertManagementAlertEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementAlert>;
};

/** Values for sorting alerts */
export type AlertManagementAlertSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Created time by ascending order. */
  | 'CREATED_TIME_ASC'
  /** Created time by descending order. */
  | 'CREATED_TIME_DESC'
  /** End time by ascending order. */
  | 'ENDED_AT_ASC'
  /** End time by descending order. */
  | 'ENDED_AT_DESC'
  /** Events count by ascending order. */
  | 'EVENT_COUNT_ASC'
  /** Events count by descending order. */
  | 'EVENT_COUNT_DESC'
  /** Severity from less critical to more critical. */
  | 'SEVERITY_ASC'
  /** Severity from more critical to less critical. */
  | 'SEVERITY_DESC'
  /** Start time by ascending order. */
  | 'STARTED_AT_ASC'
  /** Start time by descending order. */
  | 'STARTED_AT_DESC'
  /** Status by order: `Ignored > Resolved > Acknowledged > Triggered`. */
  | 'STATUS_ASC'
  /** Status by order: `Triggered > Acknowledged > Resolved > Ignored`. */
  | 'STATUS_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created time by ascending order. */
  | 'UPDATED_TIME_ASC'
  /** Created time by descending order. */
  | 'UPDATED_TIME_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Represents total number of alerts for the represented categories */
export type AlertManagementAlertStatusCountsType = {
  __typename?: 'AlertManagementAlertStatusCountsType';
  /** Number of alerts with status ACKNOWLEDGED for the project */
  acknowledged?: Maybe<Scalars['Int']>;
  /** Total number of alerts for the project. */
  all?: Maybe<Scalars['Int']>;
  /** Number of alerts with status IGNORED for the project */
  ignored?: Maybe<Scalars['Int']>;
  /** Number of alerts with status TRIGGERED or ACKNOWLEDGED for the project. */
  open?: Maybe<Scalars['Int']>;
  /** Number of alerts with status RESOLVED for the project */
  resolved?: Maybe<Scalars['Int']>;
  /** Number of alerts with status TRIGGERED for the project */
  triggered?: Maybe<Scalars['Int']>;
};

/** Filters the alerts based on given domain */
export type AlertManagementDomainFilter =
  /** Alerts for operations domain. */
  | 'operations'
  /**
   * Alerts for threat monitoring domain. Deprecated in 15.0: Network policies are
   * deprecated and will be removed in GitLab 16.0.
   */
  | 'threat_monitoring';

/** An endpoint and credentials used to accept alerts for a project */
export type AlertManagementHttpIntegration = AlertManagementIntegration & {
  __typename?: 'AlertManagementHttpIntegration';
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']>;
  /** URL at which Prometheus metrics can be queried to populate the metrics dashboard. */
  apiUrl?: Maybe<Scalars['String']>;
  /** ID of the integration. */
  id: Scalars['ID'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']>;
  /** Extract alert fields from payload example for custom mapping. */
  payloadAlertFields?: Maybe<Array<AlertManagementPayloadAlertField>>;
  /** The custom mapping of GitLab alert attributes to fields from the payload_example. */
  payloadAttributeMappings?: Maybe<Array<AlertManagementPayloadAlertMappingField>>;
  /** Example of an alert payload. */
  payloadExample?: Maybe<Scalars['JsonString']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for AlertManagementHttpIntegration. */
export type AlertManagementHttpIntegrationConnection = {
  __typename?: 'AlertManagementHttpIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementHttpIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementHttpIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementHttpIntegrationEdge = {
  __typename?: 'AlertManagementHttpIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementHttpIntegration>;
};

export type AlertManagementIntegration = {
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']>;
  /** URL at which Prometheus metrics can be queried to populate the metrics dashboard. */
  apiUrl?: Maybe<Scalars['String']>;
  /** ID of the integration. */
  id: Scalars['ID'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for AlertManagementIntegration. */
export type AlertManagementIntegrationConnection = {
  __typename?: 'AlertManagementIntegrationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AlertManagementIntegrationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AlertManagementIntegration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AlertManagementIntegrationEdge = {
  __typename?: 'AlertManagementIntegrationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AlertManagementIntegration>;
};

/** Values of types of integrations */
export type AlertManagementIntegrationType =
  /** Integration with any monitoring tool. */
  | 'HTTP'
  /** Prometheus integration. */
  | 'PROMETHEUS';

/** Parsed field from an alert used for custom mappings */
export type AlertManagementPayloadAlertField = {
  __typename?: 'AlertManagementPayloadAlertField';
  /** Human-readable label of the payload path. */
  label?: Maybe<Scalars['String']>;
  /** Path to value inside payload JSON. */
  path?: Maybe<Array<Scalars['PayloadAlertFieldPathSegment']>>;
  /** Type of the parsed value. */
  type?: Maybe<AlertManagementPayloadAlertFieldType>;
};

/** Field that are available while modifying the custom mapping attributes for an HTTP integration */
export type AlertManagementPayloadAlertFieldInput = {
  /** GitLab alert field name. */
  fieldName: AlertManagementPayloadAlertFieldName;
  /** Human-readable label of the payload path. */
  label?: InputMaybe<Scalars['String']>;
  /** Path to value inside payload JSON. */
  path: Array<Scalars['PayloadAlertFieldPathSegment']>;
  /** Type of the parsed value. */
  type: AlertManagementPayloadAlertFieldType;
};

/** Values for alert field names used in the custom mapping */
export type AlertManagementPayloadAlertFieldName =
  /** A high-level summary of the problem. */
  | 'DESCRIPTION'
  /** The resolved time of the incident. */
  | 'END_TIME'
  /** The unique identifier of the alert. This can be used to group occurrences of the same alert. */
  | 'FINGERPRINT'
  /** The name of the associated GitLab environment. */
  | 'GITLAB_ENVIRONMENT_NAME'
  /** One or more hosts, as to where this incident occurred. */
  | 'HOSTS'
  /** The name of the associated monitoring tool. */
  | 'MONITORING_TOOL'
  /** The affected service. */
  | 'SERVICE'
  /** The severity of the alert. */
  | 'SEVERITY'
  /** The time of the incident. */
  | 'START_TIME'
  /** The title of the incident. */
  | 'TITLE';

/** Values for alert field types used in the custom mapping */
export type AlertManagementPayloadAlertFieldType =
  /** Array field type. */
  | 'ARRAY'
  /** DateTime field type. */
  | 'DATETIME'
  /** String field type. */
  | 'STRING';

/** Parsed field (with its name) from an alert used for custom mappings */
export type AlertManagementPayloadAlertMappingField = {
  __typename?: 'AlertManagementPayloadAlertMappingField';
  /** GitLab alert field name. */
  fieldName?: Maybe<AlertManagementPayloadAlertFieldName>;
  /** Human-readable label of the payload path. */
  label?: Maybe<Scalars['String']>;
  /** Path to value inside payload JSON. */
  path?: Maybe<Array<Scalars['PayloadAlertFieldPathSegment']>>;
  /** Type of the parsed value. */
  type?: Maybe<AlertManagementPayloadAlertFieldType>;
};

/** An endpoint and credentials used to accept Prometheus alerts for a project */
export type AlertManagementPrometheusIntegration = AlertManagementIntegration & {
  __typename?: 'AlertManagementPrometheusIntegration';
  /** Whether the endpoint is currently accepting alerts. */
  active?: Maybe<Scalars['Boolean']>;
  /** URL at which Prometheus metrics can be queried to populate the metrics dashboard. */
  apiUrl?: Maybe<Scalars['String']>;
  /** ID of the integration. */
  id: Scalars['ID'];
  /** Name of the integration. */
  name?: Maybe<Scalars['String']>;
  /** Token used to authenticate alert notification requests. */
  token?: Maybe<Scalars['String']>;
  /** Type of integration. */
  type: AlertManagementIntegrationType;
  /** Endpoint which accepts alert notifications. */
  url?: Maybe<Scalars['String']>;
};

/** Alert severity values */
export type AlertManagementSeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Info severity */
  | 'INFO'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM'
  /** Unknown severity */
  | 'UNKNOWN';

/** Alert status values */
export type AlertManagementStatus =
  /** Someone is actively investigating the problem. */
  | 'ACKNOWLEDGED'
  /** No action will be taken. */
  | 'IGNORED'
  /** The problem has been addressed. */
  | 'RESOLVED'
  /** Investigation has not started. */
  | 'TRIGGERED';

/** Autogenerated input type of AlertSetAssignees */
export type AlertSetAssigneesInput = {
  /** Usernames to assign to the alert. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of AlertSetAssignees */
export type AlertSetAssigneesPayload = {
  __typename?: 'AlertSetAssigneesPayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of AlertTodoCreate */
export type AlertTodoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of AlertTodoCreate */
export type AlertTodoCreatePayload = {
  __typename?: 'AlertTodoCreatePayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

export type AnalyzeCiJobFailureInput = {
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

/** Data associated with configuring API fuzzing scans in GitLab CI */
export type ApiFuzzingCiConfiguration = {
  __typename?: 'ApiFuzzingCiConfiguration';
  /** All available scan modes. */
  scanModes?: Maybe<Array<ApiFuzzingScanMode>>;
  /** All default scan profiles. */
  scanProfiles?: Maybe<Array<ApiFuzzingScanProfile>>;
};

/** All possible ways to specify the API surface for an API fuzzing scan. */
export type ApiFuzzingScanMode =
  /** The API surface is specified by a HAR file. */
  | 'HAR'
  /** The API surface is specified by a OPENAPI file. */
  | 'OPENAPI'
  /** The API surface is specified by a POSTMAN file. */
  | 'POSTMAN';

/** An API Fuzzing scan profile. */
export type ApiFuzzingScanProfile = {
  __typename?: 'ApiFuzzingScanProfile';
  /** Short description of the profile. */
  description?: Maybe<Scalars['String']>;
  /** Unique name of the profile. */
  name?: Maybe<Scalars['String']>;
  /** Syntax highlighted HTML representation of the YAML. */
  yaml?: Maybe<Scalars['String']>;
};

/** Describes a project approval rule regarding who can approve merge requests. */
export type ApprovalProjectRule = {
  __typename?: 'ApprovalProjectRule';
  /** Number of required approvals. */
  approvalsRequired?: Maybe<Scalars['Int']>;
  /** List of users eligible to approve merge requests for this approval rule. */
  eligibleApprovers?: Maybe<UserCoreConnection>;
  /** ID of the rule. */
  id: Scalars['GlobalID'];
  /** Name of the rule. */
  name?: Maybe<Scalars['String']>;
  /** Type of the rule. */
  type?: Maybe<ApprovalRuleType>;
};


/** Describes a project approval rule regarding who can approve merge requests. */
export type ApprovalProjectRuleEligibleApproversArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ApprovalProjectRule. */
export type ApprovalProjectRuleConnection = {
  __typename?: 'ApprovalProjectRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApprovalProjectRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ApprovalProjectRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ApprovalProjectRuleEdge = {
  __typename?: 'ApprovalProjectRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ApprovalProjectRule>;
};

/** Describes a rule for who can approve merge requests. */
export type ApprovalRule = {
  __typename?: 'ApprovalRule';
  /** Indicates if the rule can be ignored if it is invalid. */
  allowMergeWhenInvalid?: Maybe<Scalars['Boolean']>;
  /** Number of required approvals. */
  approvalsRequired?: Maybe<Scalars['Int']>;
  /** Indicates if the rule is satisfied. */
  approved?: Maybe<Scalars['Boolean']>;
  /** List of users defined in the rule that approved the merge request. */
  approvedBy?: Maybe<UserCoreConnection>;
  /** List of users, defined in the rule, who commented on the merge request. */
  commentedBy?: Maybe<UserCoreConnection>;
  /** Indicates if the rule contains approvers from a hidden group. */
  containsHiddenGroups?: Maybe<Scalars['Boolean']>;
  /** List of all users eligible to approve the merge request (defined explicitly and from associated groups). */
  eligibleApprovers?: Maybe<Array<UserCore>>;
  /** List of groups added as approvers for the rule. */
  groups?: Maybe<GroupConnection>;
  /** ID of the rule. */
  id: Scalars['GlobalID'];
  /** Indicates if the rule is invalid and cannot be approved. */
  invalid?: Maybe<Scalars['Boolean']>;
  /** Name of the rule. */
  name?: Maybe<Scalars['String']>;
  /** Indicates if the rule was overridden for the merge request. */
  overridden?: Maybe<Scalars['Boolean']>;
  /** Named section of the Code Owners file that the rule applies to. */
  section?: Maybe<Scalars['String']>;
  /** Source rule used to create the rule. */
  sourceRule?: Maybe<ApprovalRule>;
  /** Type of the rule. */
  type?: Maybe<ApprovalRuleType>;
  /** List of users added as approvers for the rule. */
  users?: Maybe<UserCoreConnection>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleApprovedByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleCommentedByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes a rule for who can approve merge requests. */
export type ApprovalRuleUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The kind of an approval rule. */
export type ApprovalRuleType =
  /** A `any_approver` approval rule. */
  | 'ANY_APPROVER'
  /** A `code_owner` approval rule. */
  | 'CODE_OWNER'
  /** A `regular` approval rule. */
  | 'REGULAR'
  /** A `report_approver` approval rule. */
  | 'REPORT_APPROVER';

/** Autogenerated input type of ApproveDeployment */
export type ApproveDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Comment to go with the approval. */
  comment?: InputMaybe<Scalars['String']>;
  /** ID of the deployment. */
  id: Scalars['DeploymentID'];
  /** Name of the User/Group/Role to use for the approval, when the user belongs to multiple approval rules. */
  representedAs?: InputMaybe<Scalars['String']>;
  /** Status of the approval (either `APPROVED` or `REJECTED`). */
  status: DeploymentsApprovalStatus;
};

/** Autogenerated return type of ApproveDeployment */
export type ApproveDeploymentPayload = {
  __typename?: 'ApproveDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** DeploymentApproval after mutation. */
  deploymentApproval: DeploymentApproval;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of ArtifactDestroy */
export type ArtifactDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the artifact to delete. */
  id: Scalars['CiJobArtifactID'];
};

/** Autogenerated return type of ArtifactDestroy */
export type ArtifactDestroyPayload = {
  __typename?: 'ArtifactDestroyPayload';
  /** Deleted artifact. */
  artifact?: Maybe<CiJobArtifact>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents a vulnerability asset type. */
export type AssetType = {
  __typename?: 'AssetType';
  /** Name of the asset. */
  name: Scalars['String'];
  /** Type of the asset. */
  type: Scalars['String'];
  /** URL of the asset. */
  url: Scalars['String'];
};

/** Assignee ID wildcard values */
export type AssigneeWildcardId =
  /** An assignee is assigned. */
  | 'ANY'
  /** No assignee is assigned. */
  | 'NONE';

/**
 * Represents the YAML definitions for audit events defined in
 * `ee/config/audit_events/types/<event-type-name>.yml` and
 * `config/audit_events/types/<event-type-name>.yml`.
 */
export type AuditEventDefinition = {
  __typename?: 'AuditEventDefinition';
  /** Description of what action the audit event tracks. */
  description: Scalars['String'];
  /** Feature category associated with the event. */
  featureCategory: Scalars['String'];
  /** Link to the issue introducing the event. For olderaudit events, it can be a commit URL rather than amerge request URL. */
  introducedByIssue?: Maybe<Scalars['String']>;
  /**
   * Link to the merge request introducing the event. Forolder audit events, it can
   * be a commit URL rather thana merge request URL.
   */
  introducedByMr?: Maybe<Scalars['String']>;
  /** Milestone the event was introduced in. */
  milestone: Scalars['String'];
  /** Key name of the audit event. */
  name: Scalars['String'];
  /** Indicates if the event is saved to PostgreSQL database. */
  savedToDatabase: Scalars['Boolean'];
  /** Indicates if the event is streamed to an external destination. */
  streamed: Scalars['Boolean'];
};

/** The connection type for AuditEventDefinition. */
export type AuditEventDefinitionConnection = {
  __typename?: 'AuditEventDefinitionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventDefinitionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventDefinition>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventDefinitionEdge = {
  __typename?: 'AuditEventDefinitionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventDefinition>;
};

/** Represents a HTTP header key/value that belongs to an audit streaming destination. */
export type AuditEventStreamingHeader = BaseHeaderInterface & {
  __typename?: 'AuditEventStreamingHeader';
  /** ID of the header. */
  id: Scalars['ID'];
  /** Key of the header. */
  key: Scalars['String'];
  /** Value of the header. */
  value: Scalars['String'];
};

/** The connection type for AuditEventStreamingHeader. */
export type AuditEventStreamingHeaderConnection = {
  __typename?: 'AuditEventStreamingHeaderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventStreamingHeaderEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventStreamingHeader>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventStreamingHeaderEdge = {
  __typename?: 'AuditEventStreamingHeaderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventStreamingHeader>;
};

/** Autogenerated input type of AuditEventsStreamingDestinationEventsAdd */
export type AuditEventsStreamingDestinationEventsAddInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination id. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID'];
  /** List of event type filters to add for streaming. */
  eventTypeFilters: Array<Scalars['String']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationEventsAdd */
export type AuditEventsStreamingDestinationEventsAddPayload = {
  __typename?: 'AuditEventsStreamingDestinationEventsAddPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Event type filters present. */
  eventTypeFilters?: Maybe<Array<Scalars['String']>>;
};

/** Autogenerated input type of AuditEventsStreamingDestinationEventsRemove */
export type AuditEventsStreamingDestinationEventsRemoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination URL. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID'];
  /** List of event type filters to remove from streaming. */
  eventTypeFilters: Array<Scalars['String']>;
};

/** Autogenerated return type of AuditEventsStreamingDestinationEventsRemove */
export type AuditEventsStreamingDestinationEventsRemovePayload = {
  __typename?: 'AuditEventsStreamingDestinationEventsRemovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersCreate */
export type AuditEventsStreamingHeadersCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination to associate header with. */
  destinationId: Scalars['AuditEventsExternalAuditEventDestinationID'];
  /** Header key. */
  key: Scalars['String'];
  /** Header value. */
  value: Scalars['String'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersCreate */
export type AuditEventsStreamingHeadersCreatePayload = {
  __typename?: 'AuditEventsStreamingHeadersCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created header. */
  header?: Maybe<AuditEventStreamingHeader>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersDestroy */
export type AuditEventsStreamingHeadersDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header to delete. */
  headerId: Scalars['AuditEventsStreamingHeaderID'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersDestroy */
export type AuditEventsStreamingHeadersDestroyPayload = {
  __typename?: 'AuditEventsStreamingHeadersDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AuditEventsStreamingHeadersUpdate */
export type AuditEventsStreamingHeadersUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header to update. */
  headerId: Scalars['AuditEventsStreamingHeaderID'];
  /** Header key. */
  key: Scalars['String'];
  /** Header value. */
  value: Scalars['String'];
};

/** Autogenerated return type of AuditEventsStreamingHeadersUpdate */
export type AuditEventsStreamingHeadersUpdatePayload = {
  __typename?: 'AuditEventsStreamingHeadersUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updates header. */
  header?: Maybe<AuditEventStreamingHeader>;
};

/** Represents a HTTP header key/value that belongs to an instance level audit streaming destination. */
export type AuditEventsStreamingInstanceHeader = BaseHeaderInterface & {
  __typename?: 'AuditEventsStreamingInstanceHeader';
  /** ID of the header. */
  id: Scalars['ID'];
  /** Key of the header. */
  key: Scalars['String'];
  /** Value of the header. */
  value: Scalars['String'];
};

/** The connection type for AuditEventsStreamingInstanceHeader. */
export type AuditEventsStreamingInstanceHeaderConnection = {
  __typename?: 'AuditEventsStreamingInstanceHeaderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditEventsStreamingInstanceHeaderEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuditEventsStreamingInstanceHeader>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AuditEventsStreamingInstanceHeaderEdge = {
  __typename?: 'AuditEventsStreamingInstanceHeaderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditEventsStreamingInstanceHeader>;
};

/** Autogenerated input type of AuditEventsStreamingInstanceHeadersCreate */
export type AuditEventsStreamingInstanceHeadersCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Instance level external destination to associate header with. */
  destinationId: Scalars['AuditEventsInstanceExternalAuditEventDestinationID'];
  /** Header key. */
  key: Scalars['String'];
  /** Header value. */
  value: Scalars['String'];
};

/** Autogenerated return type of AuditEventsStreamingInstanceHeadersCreate */
export type AuditEventsStreamingInstanceHeadersCreatePayload = {
  __typename?: 'AuditEventsStreamingInstanceHeadersCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created header. */
  header?: Maybe<AuditEventsStreamingInstanceHeader>;
};

/** Autogenerated input type of AuditEventsStreamingInstanceHeadersDestroy */
export type AuditEventsStreamingInstanceHeadersDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header to delete. */
  headerId: Scalars['AuditEventsStreamingInstanceHeaderID'];
};

/** Autogenerated return type of AuditEventsStreamingInstanceHeadersDestroy */
export type AuditEventsStreamingInstanceHeadersDestroyPayload = {
  __typename?: 'AuditEventsStreamingInstanceHeadersDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AuditEventsStreamingInstanceHeadersUpdate */
export type AuditEventsStreamingInstanceHeadersUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Header to update. */
  headerId: Scalars['AuditEventsStreamingInstanceHeaderID'];
  /** Header key. */
  key: Scalars['String'];
  /** Header value. */
  value: Scalars['String'];
};

/** Autogenerated return type of AuditEventsStreamingInstanceHeadersUpdate */
export type AuditEventsStreamingInstanceHeadersUpdatePayload = {
  __typename?: 'AuditEventsStreamingInstanceHeadersUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updates header. */
  header?: Maybe<AuditEventsStreamingInstanceHeader>;
};

/** User availability status */
export type AvailabilityEnum =
  /** Busy */
  | 'BUSY'
  /** Not Set */
  | 'NOT_SET';

/** Available fields to be exported as CSV */
export type AvailableExportFields =
  /** Author name. */
  | 'AUTHOR'
  /** Author username. */
  | 'AUTHOR_USERNAME'
  /** Date of creation. */
  | 'CREATED_AT'
  /** Description. */
  | 'DESCRIPTION'
  /** Unique identifier. */
  | 'ID'
  /** Title. */
  | 'TITLE'
  /** Type of the work item. */
  | 'TYPE';

/** An emoji awarded by a user */
export type AwardEmoji = {
  __typename?: 'AwardEmoji';
  /** Emoji description. */
  description: Scalars['String'];
  /** Emoji as an icon. */
  emoji: Scalars['String'];
  /** Emoji name. */
  name: Scalars['String'];
  /** Emoji in Unicode. */
  unicode: Scalars['String'];
  /** Unicode version for this emoji. */
  unicodeVersion: Scalars['String'];
  /** User who awarded the emoji. */
  user: UserCore;
};

/** Autogenerated input type of AwardEmojiAdd */
export type AwardEmojiAddInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Emoji name. */
  name: Scalars['String'];
};

/** Autogenerated return type of AwardEmojiAdd */
export type AwardEmojiAddPayload = {
  __typename?: 'AwardEmojiAddPayload';
  /** Award emoji after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for AwardEmoji. */
export type AwardEmojiConnection = {
  __typename?: 'AwardEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AwardEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AwardEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AwardEmojiEdge = {
  __typename?: 'AwardEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AwardEmoji>;
};

/** Autogenerated input type of AwardEmojiRemove */
export type AwardEmojiRemoveInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Emoji name. */
  name: Scalars['String'];
};

/** Autogenerated return type of AwardEmojiRemove */
export type AwardEmojiRemovePayload = {
  __typename?: 'AwardEmojiRemovePayload';
  /** Award emoji after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of AwardEmojiToggle */
export type AwardEmojiToggleInput = {
  /** Global ID of the awardable resource. */
  awardableId: Scalars['AwardableID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Emoji name. */
  name: Scalars['String'];
};

/** Autogenerated return type of AwardEmojiToggle */
export type AwardEmojiTogglePayload = {
  __typename?: 'AwardEmojiTogglePayload';
  /** Award emoji after mutation. */
  awardEmoji?: Maybe<AwardEmoji>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Indicates the status of the emoji. True if the toggle awarded the emoji, and false if the toggle removed the emoji. */
  toggledOn: Scalars['Boolean'];
};

export type BaseHeaderInterface = {
  /** ID of the header. */
  id: Scalars['ID'];
  /** Key of the header. */
  key: Scalars['String'];
  /** Value of the header. */
  value: Scalars['String'];
};

export type BaseService = Service & {
  __typename?: 'BaseService';
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']>;
};

export type Blob = Entry & {
  __typename?: 'Blob';
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** LFS ID of the blob. */
  lfsOid?: Maybe<Scalars['String']>;
  /** Blob mode in numeric format. */
  mode?: Maybe<Scalars['String']>;
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Type of tree entry. */
  type: EntryType;
  /** Web path of the blob. */
  webPath?: Maybe<Scalars['String']>;
  /** Web URL of the blob. */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for Blob. */
export type BlobConnection = {
  __typename?: 'BlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Blob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BlobEdge = {
  __typename?: 'BlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Blob>;
};

/** Represents how the blob content should be displayed */
export type BlobViewer = {
  __typename?: 'BlobViewer';
  /** Shows whether the blob should be displayed collapsed. */
  collapsed: Scalars['Boolean'];
  /** Content file type. */
  fileType: Scalars['String'];
  /** Shows whether the blob content is loaded asynchronously. */
  loadAsync: Scalars['Boolean'];
  /** Loading partial name. */
  loadingPartialName: Scalars['String'];
  /** Error rendering the blob content. */
  renderError?: Maybe<Scalars['String']>;
  /** Shows whether the blob is too large to be displayed. */
  tooLarge: Scalars['Boolean'];
  /** Type of blob viewer. */
  type: BlobViewersType;
};

/** Types of blob viewers */
export type BlobViewersType =
  /** Auxiliary blob viewers type. */
  | 'auxiliary'
  /** Rich blob viewers type. */
  | 'rich'
  /** Simple blob viewers type. */
  | 'simple';

/** Represents a project or group issue board */
export type Board = {
  __typename?: 'Board';
  /** Board assignee. */
  assignee?: Maybe<UserCore>;
  /** Timestamp of when the board was created. */
  createdAt: Scalars['Time'];
  /** Epics associated with board issues. */
  epics?: Maybe<BoardEpicConnection>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: Maybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: Maybe<Scalars['Boolean']>;
  /** ID (global ID) of the board. */
  id: Scalars['ID'];
  /** Board iteration. */
  iteration?: Maybe<Iteration>;
  /** Board iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
  /** Labels of the board. */
  labels?: Maybe<LabelConnection>;
  /** Lists of the board. */
  lists?: Maybe<BoardListConnection>;
  /** Board milestone. */
  milestone?: Maybe<Milestone>;
  /** Name of the board. */
  name?: Maybe<Scalars['String']>;
  /** Timestamp of when the board was last updated. */
  updatedAt: Scalars['Time'];
  /** Web path of the board. */
  webPath: Scalars['String'];
  /** Web URL of the board. */
  webUrl: Scalars['String'];
  /** Weight of the board. */
  weight?: Maybe<Scalars['Int']>;
};


/** Represents a project or group issue board */
export type BoardEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  issueFilters?: InputMaybe<BoardIssueInput>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a project or group issue board */
export type BoardLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a project or group issue board */
export type BoardListsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['ListID']>;
  issueFilters?: InputMaybe<BoardIssueInput>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Board. */
export type BoardConnection = {
  __typename?: 'BoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Board>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BoardEdge = {
  __typename?: 'BoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Board>;
};

/** Represents an epic on an issue board */
export type BoardEpic = CurrentUserTodos & Eventable & NoteableInterface & Todoable & {
  __typename?: 'BoardEpic';
  /** Ancestors (parents) of the epic. */
  ancestors?: Maybe<EpicConnection>;
  /** Author of the epic. */
  author: UserCore;
  /** List of award emojis associated with the epic. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Indicates the epic is blocked. */
  blocked?: Maybe<Scalars['Boolean']>;
  /** Count of epics blocking this epic. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Epics blocking this epic. */
  blockedByEpics?: Maybe<EpicConnection>;
  /** Count of epics that this epic is blocking. */
  blockingCount?: Maybe<Scalars['Int']>;
  /** Children (sub-epics) of the epic. */
  children?: Maybe<EpicConnection>;
  /** Timestamp of when the epic was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Color of the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  color?: Maybe<Scalars['String']>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Indicates if the epic is confidential. */
  confidential?: Maybe<Scalars['Boolean']>;
  /** Timestamp of when the epic was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default Project for issue creation. Based on the project the user created the last issue in. */
  defaultProjectForIssueCreation?: Maybe<Project>;
  /** Number of open and closed descendant epics and issues. */
  descendantCounts?: Maybe<EpicDescendantCount>;
  /** Total weight of open and closed issues in the epic and its descendants. */
  descendantWeightSum?: Maybe<EpicDescendantWeights>;
  /** Description of the epic. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the epic has received. */
  downvotes: Scalars['Int'];
  /** Due date of the epic. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Fixed due date of the epic. */
  dueDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from child epics or milestones. */
  dueDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from milestones. */
  dueDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the due date has been manually set. */
  dueDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
  /** Group to which the epic belongs. */
  group: Group;
  /** Indicates if the epic has children. */
  hasChildren: Scalars['Boolean'];
  /** Indicates if the epic has direct issues. */
  hasIssues: Scalars['Boolean'];
  /** Indicates if the epic has a parent epic. */
  hasParent: Scalars['Boolean'];
  /** Current health status of the epic. */
  healthStatus?: Maybe<EpicHealthStatus>;
  /** ID of the epic. */
  id: Scalars['ID'];
  /** Internal ID of the epic. */
  iid: Scalars['ID'];
  /** A list of issues associated with the epic. */
  issues?: Maybe<EpicIssueConnection>;
  /** Labels assigned to the epic. */
  labels?: Maybe<LabelConnection>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Parent epic of the epic. */
  parent?: Maybe<Epic>;
  /** List of participants for the epic. */
  participants?: Maybe<UserCoreConnection>;
  /** Internal reference of the epic. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** URI path of the epic-issue relationship. */
  relationPath?: Maybe<Scalars['String']>;
  /** Relative position of the epic in the epic tree. */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Start date of the epic. */
  startDate?: Maybe<Scalars['Time']>;
  /** Fixed start date of the epic. */
  startDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from child epics or milestones. */
  startDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from milestones. */
  startDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the start date has been manually set. */
  startDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** State of the epic. */
  state: EpicState;
  /** Indicates the currently logged in user is subscribed to the epic. */
  subscribed: Scalars['Boolean'];
  /** Text color generated for the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  textColor?: Maybe<Scalars['String']>;
  /** Title of the epic. */
  title?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the epic was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Number of upvotes the epic has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the epic. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the epic. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: EpicPermissions;
  /** User preferences for the epic on the issue board. */
  userPreferences?: Maybe<BoardEpicUserPreferences>;
  /** Web path of the epic. */
  webPath: Scalars['String'];
  /** Web URL of the epic. */
  webUrl: Scalars['String'];
};


/** Represents an epic on an issue board */
export type BoardEpicAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['ID']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Represents an epic on an issue board */
export type BoardEpicAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicBlockedByEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['ID']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Represents an epic on an issue board */
export type BoardEpicCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Represents an epic on an issue board */
export type BoardEpicDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic on an issue board */
export type BoardEpicReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

/** The connection type for BoardEpic. */
export type BoardEpicConnection = {
  __typename?: 'BoardEpicConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardEpicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BoardEpic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BoardEpicCreate */
export type BoardEpicCreateInput = {
  /** Global ID of the board that the epic is in. */
  boardId: Scalars['BoardsEpicBoardID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the epic to create is in. */
  groupPath: Scalars['ID'];
  /** Global ID of the epic board list in which epic will be created. */
  listId: Scalars['BoardsEpicListID'];
  /** Title of the epic. */
  title: Scalars['String'];
};

/** Autogenerated return type of BoardEpicCreate */
export type BoardEpicCreatePayload = {
  __typename?: 'BoardEpicCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after creation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type BoardEpicEdge = {
  __typename?: 'BoardEpicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardEpic>;
};

/** Represents user preferences for a board epic */
export type BoardEpicUserPreferences = {
  __typename?: 'BoardEpicUserPreferences';
  /** Indicates epic should be displayed as collapsed. */
  collapsed: Scalars['Boolean'];
};

export type BoardIssueInput = {
  /** Filter by assignee username. */
  assigneeUsername?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames. */
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Filter by epic ID. Incompatible with epicWildcardId. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Filter by epic ID wildcard. Incompatible with epicId. */
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  /** Health status of the issue, "none" and "any" values are supported. */
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  /** List of IIDs of issues. For example `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /** Filter by a list of iteration cadence IDs. */
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  /** Filter by a list of iteration IDs. Incompatible with iterationWildcardId. */
  iterationId?: InputMaybe<Array<Scalars['IterationID']>>;
  /** Filter by iteration title. */
  iterationTitle?: InputMaybe<Scalars['String']>;
  /** Filter by iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by milestone title. */
  milestoneTitle?: InputMaybe<Scalars['String']>;
  /** Filter by milestone ID wildcard. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** List of negated arguments. */
  not?: InputMaybe<NegatedBoardIssueInput>;
  /** List of arguments with inclusive OR. */
  or?: InputMaybe<UnionedIssueFilterInput>;
  /** Filter by release tag. */
  releaseTag?: InputMaybe<Scalars['String']>;
  /** Search query for issue title or description. */
  search?: InputMaybe<Scalars['String']>;
  /** Filter by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter by weight. */
  weight?: InputMaybe<Scalars['String']>;
  /** Filter by weight ID wildcard. Incompatible with weight. */
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};

/** Represents a list for an issue board */
export type BoardList = {
  __typename?: 'BoardList';
  /** Assignee in the list. */
  assignee?: Maybe<UserCore>;
  /** Indicates if the list is collapsed for this user. */
  collapsed?: Maybe<Scalars['Boolean']>;
  /** ID (global ID) of the list. */
  id: Scalars['ID'];
  /** Board issues. */
  issues?: Maybe<IssueConnection>;
  /** Count of issues in the list. */
  issuesCount?: Maybe<Scalars['Int']>;
  /** Iteration of the list. */
  iteration?: Maybe<Iteration>;
  /** Label of the list. */
  label?: Maybe<Label>;
  /** Current limit metric for the list. */
  limitMetric?: Maybe<ListLimitMetric>;
  /** Type of the list. */
  listType: Scalars['String'];
  /** Maximum number of issues in the list. */
  maxIssueCount?: Maybe<Scalars['Int']>;
  /** Maximum weight of issues in the list. */
  maxIssueWeight?: Maybe<Scalars['Int']>;
  /** Milestone of the list. */
  milestone?: Maybe<Milestone>;
  /** Position of list within the board. */
  position?: Maybe<Scalars['Int']>;
  /** Title of the list. */
  title: Scalars['String'];
  /** Total weight of all issues in the list, encoded as a string. */
  totalIssueWeight?: Maybe<Scalars['BigInt']>;
  /**
   * Total weight of all issues in the list. Deprecated in 16.2: Use `totalIssueWeight`.
   * @deprecated Use `totalIssueWeight`. Deprecated in 16.2.
   */
  totalWeight?: Maybe<Scalars['Int']>;
};


/** Represents a list for an issue board */
export type BoardListIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<BoardIssueInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for BoardList. */
export type BoardListConnection = {
  __typename?: 'BoardListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BoardList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of BoardListCreate */
export type BoardListCreateInput = {
  /** Global ID of an existing user. */
  assigneeId?: InputMaybe<Scalars['UserID']>;
  /** Create the backlog list. */
  backlog?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the issue board to mutate. */
  boardId: Scalars['BoardID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of an existing iteration. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** Global ID of an existing label. */
  labelId?: InputMaybe<Scalars['LabelID']>;
  /** Global ID of an existing milestone. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
};

/** Autogenerated return type of BoardListCreate */
export type BoardListCreatePayload = {
  __typename?: 'BoardListCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue list in the issue board. */
  list?: Maybe<BoardList>;
};

/** An edge in a connection. */
export type BoardListEdge = {
  __typename?: 'BoardListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardList>;
};

/** Autogenerated input type of BoardListUpdateLimitMetrics */
export type BoardListUpdateLimitMetricsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** New limit metric type for the list. */
  limitMetric?: InputMaybe<ListLimitMetric>;
  /** Global ID of the list. */
  listId: Scalars['ListID'];
  /** New maximum issue count limit. */
  maxIssueCount?: InputMaybe<Scalars['Int']>;
  /** New maximum issue weight limit. */
  maxIssueWeight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of BoardListUpdateLimitMetrics */
export type BoardListUpdateLimitMetricsPayload = {
  __typename?: 'BoardListUpdateLimitMetricsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated list. */
  list?: Maybe<BoardList>;
};

export type Branch = {
  __typename?: 'Branch';
  /** Commit for the branch. */
  commit?: Maybe<Commit>;
  /** Name of the branch. */
  name: Scalars['String'];
};

/** Branch protection details for a branch rule. */
export type BranchProtection = {
  __typename?: 'BranchProtection';
  /** Toggle force push to the branch for users with write access. */
  allowForcePush: Scalars['Boolean'];
  /** Enforce code owner approvals before allowing a merge. */
  codeOwnerApprovalRequired: Scalars['Boolean'];
  /** Details about who can merge when this branch is the source branch. */
  mergeAccessLevels?: Maybe<MergeAccessLevelConnection>;
  /** Details about who can push when this branch is the source branch. */
  pushAccessLevels?: Maybe<PushAccessLevelConnection>;
  /** Details about who can unprotect this branch. */
  unprotectAccessLevels?: Maybe<UnprotectAccessLevelConnection>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionMergeAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionPushAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Branch protection details for a branch rule. */
export type BranchProtectionUnprotectAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** List of branch rules for a project, grouped by branch name. */
export type BranchRule = {
  __typename?: 'BranchRule';
  /** Merge request approval rules configured for this branch rule. */
  approvalRules?: Maybe<ApprovalProjectRuleConnection>;
  /** Branch protections configured for this branch rule. */
  branchProtection?: Maybe<BranchProtection>;
  /** Timestamp of when the branch rule was created. */
  createdAt: Scalars['Time'];
  /** External status checks configured for this branch rule. */
  externalStatusChecks?: Maybe<ExternalStatusCheckConnection>;
  /** Check if this branch rule protects the project's default branch. */
  isDefault: Scalars['Boolean'];
  /** Check if this branch rule protects access for the branch. */
  isProtected: Scalars['Boolean'];
  /** Number of existing branches that match this branch rule. */
  matchingBranchesCount: Scalars['Int'];
  /** Branch name, with wildcards, for the branch rules. */
  name: Scalars['String'];
  /** Timestamp of when the branch rule was last updated. */
  updatedAt: Scalars['Time'];
};


/** List of branch rules for a project, grouped by branch name. */
export type BranchRuleApprovalRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** List of branch rules for a project, grouped by branch name. */
export type BranchRuleExternalStatusChecksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for BranchRule. */
export type BranchRuleConnection = {
  __typename?: 'BranchRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BranchRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BranchRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type BranchRuleEdge = {
  __typename?: 'BranchRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BranchRule>;
};

/** Autogenerated input type of BuildForecast */
export type BuildForecastInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the context for the forecast to pick an appropriate model. */
  contextId: Scalars['GlobalID'];
  /** Number of data points to forecast. */
  horizon: Scalars['Int'];
  /** Type of the forecast. */
  type: Scalars['String'];
};

/** Autogenerated return type of BuildForecast */
export type BuildForecastPayload = {
  __typename?: 'BuildForecastPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created forecast. */
  forecast: Forecast;
};

/** Autogenerated input type of BulkDestroyJobArtifacts */
export type BulkDestroyJobArtifactsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global IDs of the job artifacts to destroy. */
  ids: Array<Scalars['CiJobArtifactID']>;
  /** Global Project ID of the job artifacts to destroy. Incompatible with projectPath. */
  projectId: Scalars['ProjectID'];
};

/** Autogenerated return type of BulkDestroyJobArtifacts */
export type BulkDestroyJobArtifactsPayload = {
  __typename?: 'BulkDestroyJobArtifactsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Number of job artifacts deleted. */
  destroyedCount?: Maybe<Scalars['Int']>;
  /** IDs of job artifacts that were deleted. */
  destroyedIds?: Maybe<Array<Scalars['CiJobArtifactID']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of BulkEnableDevopsAdoptionNamespaces */
export type BulkEnableDevopsAdoptionNamespacesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Display namespace ID. */
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']>;
  /** List of Namespace IDs. */
  namespaceIds: Array<Scalars['NamespaceID']>;
};

/** Autogenerated return type of BulkEnableDevopsAdoptionNamespaces */
export type BulkEnableDevopsAdoptionNamespacesPayload = {
  __typename?: 'BulkEnableDevopsAdoptionNamespacesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Enabled namespaces after mutation. */
  enabledNamespaces?: Maybe<Array<DevopsAdoptionEnabledNamespace>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of BulkRunnerDelete */
export type BulkRunnerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IDs of the runners to delete. */
  ids?: InputMaybe<Array<Scalars['CiRunnerID']>>;
};

/** Autogenerated return type of BulkRunnerDelete */
export type BulkRunnerDeletePayload = {
  __typename?: 'BulkRunnerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Number of records effectively deleted. Only present if operation was performed synchronously. */
  deletedCount?: Maybe<Scalars['Int']>;
  /** IDs of records effectively deleted. Only present if operation was performed synchronously. */
  deletedIds?: Maybe<Array<Scalars['CiRunnerID']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents the total number of issues and their weights for a particular day */
export type BurnupChartDailyTotals = {
  __typename?: 'BurnupChartDailyTotals';
  /** Number of closed issues as of this day. */
  completedCount: Scalars['Int'];
  /** Total weight of closed issues as of this day. */
  completedWeight: Scalars['Int'];
  /** Date for burnup totals. */
  date: Scalars['ISO8601Date'];
  /** Number of issues as of this day. */
  scopeCount: Scalars['Int'];
  /** Total weight of issues as of this day. */
  scopeWeight: Scalars['Int'];
};

/** Autogenerated input type of CatalogResourcesCreate */
export type CatalogResourcesCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to convert to a catalog resource. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of CatalogResourcesCreate */
export type CatalogResourcesCreatePayload = {
  __typename?: 'CatalogResourcesCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CiAiGenerateConfig */
export type CiAiGenerateConfigInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project path for the project related to the open config editor. */
  projectPath: Scalars['ID'];
  /** Content of the user message to be sent to the language model. */
  userContent: Scalars['String'];
};

/** Autogenerated return type of CiAiGenerateConfig */
export type CiAiGenerateConfigPayload = {
  __typename?: 'CiAiGenerateConfigPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** User chat message. */
  userMessage?: Maybe<AiMessageType>;
};

export type CiApplicationSettings = {
  __typename?: 'CiApplicationSettings';
  /** Whether to keep the latest jobs artifacts. */
  keepLatestArtifact?: Maybe<Scalars['Boolean']>;
};

export type CiBuildNeed = {
  __typename?: 'CiBuildNeed';
  /** ID of the BuildNeed. */
  id: Scalars['ID'];
  /** Name of the job we need to complete. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for CiBuildNeed. */
export type CiBuildNeedConnection = {
  __typename?: 'CiBuildNeedConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiBuildNeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiBuildNeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiBuildNeedEdge = {
  __typename?: 'CiBuildNeedEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiBuildNeed>;
};

export type CiCatalogResource = {
  __typename?: 'CiCatalogResource';
  /**
   * Description of the catalog resource. Introduced in 15.11: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  description?: Maybe<Scalars['String']>;
  /**
   * Number of times the catalog resource has been forked. Introduced in 16.1: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  forksCount: Scalars['Int'];
  /**
   * Icon for the catalog resource. Introduced in 15.11: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  icon?: Maybe<Scalars['String']>;
  /**
   * ID of the catalog resource. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  id: Scalars['ID'];
  /**
   * Latest version of the catalog resource. Introduced in 16.1: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  latestVersion?: Maybe<Release>;
  /**
   * Name of the catalog resource. Introduced in 15.11: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  name?: Maybe<Scalars['String']>;
  /**
   * GitLab Flavored Markdown rendering of `readme` Introduced in 16.1: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  readmeHtml: Scalars['String'];
  /**
   * Root namespace of the catalog resource. Introduced in 16.1: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  rootNamespace?: Maybe<Namespace>;
  /**
   * Number of times the catalog resource has been starred. Introduced in 16.1:
   * This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  starCount: Scalars['Int'];
  /**
   * Versions of the catalog resource. This field can only be resolved for one
   * catalog resource in any single request. Introduced in 16.2: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.
   */
  versions?: Maybe<ReleaseConnection>;
  /**
   * Web path of the catalog resource. Introduced in 16.1: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  webPath?: Maybe<Scalars['String']>;
};


export type CiCatalogResourceVersionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReleaseSort>;
};

/** The connection type for CiCatalogResource. */
export type CiCatalogResourceConnection = {
  __typename?: 'CiCatalogResourceConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiCatalogResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiCatalogResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiCatalogResourceEdge = {
  __typename?: 'CiCatalogResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiCatalogResource>;
};

/** Values for sorting catalog resources */
export type CiCatalogResourceSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

export type CiConfig = {
  __typename?: 'CiConfig';
  /** Linting errors. */
  errors?: Maybe<Array<Scalars['String']>>;
  /** List of included files. */
  includes?: Maybe<Array<CiConfigInclude>>;
  /** Merged CI configuration YAML. */
  mergedYaml?: Maybe<Scalars['String']>;
  /** Stages of the pipeline. */
  stages?: Maybe<CiConfigStageConnection>;
  /** Status of linting, can be either valid or invalid. */
  status?: Maybe<CiConfigStatus>;
  /** Linting warnings. */
  warnings?: Maybe<Array<Scalars['String']>>;
};


export type CiConfigStagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type CiConfigGroup = {
  __typename?: 'CiConfigGroup';
  /** Jobs in group. */
  jobs?: Maybe<CiConfigJobConnection>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']>;
  /** Size of the job group. */
  size?: Maybe<Scalars['Int']>;
};


export type CiConfigGroupJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiConfigGroup. */
export type CiConfigGroupConnection = {
  __typename?: 'CiConfigGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigGroupEdge = {
  __typename?: 'CiConfigGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigGroup>;
};

export type CiConfigInclude = {
  __typename?: 'CiConfigInclude';
  /** File blob location. It can be masked if it contains masked variables. For example, `"https://gitlab.com/gitlab-org/gitlab/-/blob/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml"`. */
  blob?: Maybe<Scalars['String']>;
  /** Current project scope, e.g., "gitlab-org/gitlab". */
  contextProject?: Maybe<Scalars['String']>;
  /** Current sha scope. */
  contextSha?: Maybe<Scalars['String']>;
  /**
   * Extra information for the `include`, which can contain `job_name`, `project`,
   * and `ref`. Values can be masked if they contain masked variables.
   */
  extra?: Maybe<Scalars['JSON']>;
  /** File location. It can be masked if it contains masked variables. For example, `".gitlab/ci/build-images.gitlab-ci.yml"`. */
  location?: Maybe<Scalars['String']>;
  /** File raw location. It can be masked if it contains masked variables. For example, `"https://gitlab.com/gitlab-org/gitlab/-/raw/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml"`. */
  raw?: Maybe<Scalars['String']>;
  /** Include type. */
  type?: Maybe<CiConfigIncludeType>;
};

/** Include type. */
export type CiConfigIncludeType =
  /** Component include. */
  | 'component'
  /** Project file include. */
  | 'file'
  /** Local include. */
  | 'local'
  /** Remote include. */
  | 'remote'
  /** Template include. */
  | 'template';

export type CiConfigJob = {
  __typename?: 'CiConfigJob';
  /** Override a set of commands that are executed after the job. */
  afterScript?: Maybe<Array<Scalars['String']>>;
  /** Allow job to fail. */
  allowFailure?: Maybe<Scalars['Boolean']>;
  /** Override a set of commands that are executed before the job. */
  beforeScript?: Maybe<Array<Scalars['String']>>;
  /** Name of an environment to which the job deploys. */
  environment?: Maybe<Scalars['String']>;
  /** Limit when jobs are not created. */
  except?: Maybe<CiConfigJobRestriction>;
  /** Name of the job group. */
  groupName?: Maybe<Scalars['String']>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']>;
  /** Builds that must complete before the jobs run. */
  needs?: Maybe<CiConfigNeedConnection>;
  /** Jobs are created when these conditions do not apply. */
  only?: Maybe<CiConfigJobRestriction>;
  /** Shell script that is executed by a runner. */
  script?: Maybe<Array<Scalars['String']>>;
  /** Name of the job stage. */
  stage?: Maybe<Scalars['String']>;
  /** List of tags that are used to select a runner. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** When to run the job. */
  when?: Maybe<Scalars['String']>;
};


export type CiConfigJobNeedsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiConfigJob. */
export type CiConfigJobConnection = {
  __typename?: 'CiConfigJobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigJobEdge = {
  __typename?: 'CiConfigJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigJob>;
};

export type CiConfigJobRestriction = {
  __typename?: 'CiConfigJobRestriction';
  /** Git refs the job restriction applies to. */
  refs?: Maybe<Array<Scalars['String']>>;
};

export type CiConfigNeed = {
  __typename?: 'CiConfigNeed';
  /** Name of the need. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for CiConfigNeed. */
export type CiConfigNeedConnection = {
  __typename?: 'CiConfigNeedConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigNeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigNeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigNeedEdge = {
  __typename?: 'CiConfigNeedEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigNeed>;
};

export type CiConfigStage = {
  __typename?: 'CiConfigStage';
  /** Groups of jobs for the stage. */
  groups?: Maybe<CiConfigGroupConnection>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']>;
};


export type CiConfigStageGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiConfigStage. */
export type CiConfigStageConnection = {
  __typename?: 'CiConfigStageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiConfigStageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiConfigStage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiConfigStageEdge = {
  __typename?: 'CiConfigStageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiConfigStage>;
};

/** Values for YAML processor result */
export type CiConfigStatus =
  /** Configuration file is not valid. */
  | 'INVALID'
  /** Configuration file is valid. */
  | 'VALID';

/** CI/CD config variables. */
export type CiConfigVariable = {
  __typename?: 'CiConfigVariable';
  /** Description for the CI/CD config variable. */
  description?: Maybe<Scalars['String']>;
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Value options for the variable. */
  valueOptions?: Maybe<Array<Scalars['String']>>;
};

/** Represents a deployment freeze window of a project */
export type CiFreezePeriod = {
  __typename?: 'CiFreezePeriod';
  /** Time zone for the cron fields, defaults to UTC if not provided. */
  cronTimezone?: Maybe<Scalars['String']>;
  /** End of the freeze period in cron format. */
  endCron: Scalars['String'];
  /** Timestamp (UTC) of when the current/next active period ends. */
  endTime?: Maybe<Scalars['Time']>;
  /** Start of the freeze period in cron format. */
  startCron: Scalars['String'];
  /** Timestamp (UTC) of when the current/next active period starts. */
  startTime?: Maybe<Scalars['Time']>;
  /** Freeze period status. */
  status: CiFreezePeriodStatus;
};

/** Deploy freeze period status */
export type CiFreezePeriodStatus =
  /** Freeze period is active. */
  | 'ACTIVE'
  /** Freeze period is inactive. */
  | 'INACTIVE';

export type CiGroup = {
  __typename?: 'CiGroup';
  /** Detailed status of the group. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** ID for a group. */
  id: Scalars['String'];
  /** Jobs in group. */
  jobs?: Maybe<CiJobConnection>;
  /** Name of the job group. */
  name?: Maybe<Scalars['String']>;
  /** Size of the group. */
  size?: Maybe<Scalars['Int']>;
};


export type CiGroupJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiGroup. */
export type CiGroupConnection = {
  __typename?: 'CiGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupEdge = {
  __typename?: 'CiGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroup>;
};

/** Ci/CD environment scope for a group. */
export type CiGroupEnvironmentScope = {
  __typename?: 'CiGroupEnvironmentScope';
  /** Scope name defininig the enviromnments that can use the variable. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for CiGroupEnvironmentScope. */
export type CiGroupEnvironmentScopeConnection = {
  __typename?: 'CiGroupEnvironmentScopeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupEnvironmentScopeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroupEnvironmentScope>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupEnvironmentScopeEdge = {
  __typename?: 'CiGroupEnvironmentScopeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroupEnvironmentScope>;
};

/** CI/CD variables for a group. */
export type CiGroupVariable = CiVariable & {
  __typename?: 'CiGroupVariable';
  /** Description of the variable. */
  description?: Maybe<Scalars['String']>;
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiGroupVariable. */
export type CiGroupVariableConnection = {
  __typename?: 'CiGroupVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiGroupVariableEdge>>>;
  /** Maximum amount of group CI/CD variables. */
  limit: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiGroupVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiGroupVariableEdge = {
  __typename?: 'CiGroupVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiGroupVariable>;
};

/** CI/CD variables for a GitLab instance. */
export type CiInstanceVariable = CiVariable & {
  __typename?: 'CiInstanceVariable';
  /**
   * Scope defining the environments that can use the variable. Deprecated in 15.3:
   * No longer used, only available for GroupVariableType and ProjectVariableType.
   * @deprecated No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in 15.3.
   */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiInstanceVariable. */
export type CiInstanceVariableConnection = {
  __typename?: 'CiInstanceVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiInstanceVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiInstanceVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiInstanceVariableEdge = {
  __typename?: 'CiInstanceVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiInstanceVariable>;
};

export type CiJob = {
  __typename?: 'CiJob';
  /** Indicates the job is active. */
  active: Scalars['Boolean'];
  /**
   * Ai generated analysis of the root cause of failure. Introduced in 16.1: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  aiFailureAnalysis?: Maybe<Scalars['String']>;
  /** Whether the job is allowed to fail. */
  allowFailure: Scalars['Boolean'];
  /** Artifacts generated by the job. */
  artifacts?: Maybe<CiJobArtifactConnection>;
  /** URL for browsing the artifact's archive. */
  browseArtifactsPath?: Maybe<Scalars['String']>;
  /** Indicates whether the current user can play the job. */
  canPlayJob: Scalars['Boolean'];
  /** Indicates the job can be canceled. */
  cancelable: Scalars['Boolean'];
  /** Path to the commit that triggered the job. */
  commitPath?: Maybe<Scalars['String']>;
  /** Coverage level of the job. */
  coverage?: Maybe<Scalars['Float']>;
  /** When the job was created. */
  createdAt: Scalars['Time'];
  /** Whether the job was created by a tag. */
  createdByTag: Scalars['Boolean'];
  /** Detailed status of the job. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Downstream pipeline for a bridge. */
  downstreamPipeline?: Maybe<Pipeline>;
  /** Duration of the job in seconds. */
  duration?: Maybe<Scalars['Int']>;
  /** When the job was erased. */
  erasedAt?: Maybe<Scalars['Time']>;
  /** Message on why the job failed. */
  failureMessage?: Maybe<Scalars['String']>;
  /** When a job has finished running. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** ID of the job. */
  id?: Maybe<Scalars['JobID']>;
  /** Indicates the type of job. */
  kind: CiJobKind;
  /** Whether the job has a manual action. */
  manualJob?: Maybe<Scalars['Boolean']>;
  /** Variables added to a manual job when the job is triggered. */
  manualVariables?: Maybe<CiManualVariableConnection>;
  /** Name of the job. */
  name?: Maybe<Scalars['String']>;
  /** References to builds that must complete before the jobs run. */
  needs?: Maybe<CiBuildNeedConnection>;
  /** Pipeline the job belongs to. */
  pipeline?: Maybe<Pipeline>;
  /** Play path of the job. */
  playPath?: Maybe<Scalars['String']>;
  /** Indicates the job can be played. */
  playable: Scalars['Boolean'];
  /**
   * Jobs that must complete before the job runs. Returns `BuildNeed`, which is the
   * needed jobs if the job uses the `needs` keyword, or the previous stage jobs otherwise.
   */
  previousStageJobsOrNeeds?: Maybe<JobNeedUnionConnection>;
  /** Project that the job belongs to. */
  project?: Maybe<Project>;
  /** When the job was enqueued and marked as pending. */
  queuedAt?: Maybe<Scalars['Time']>;
  /** How long the job was enqueued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']>;
  /** Ref name of the job. */
  refName?: Maybe<Scalars['String']>;
  /** Path to the ref. */
  refPath?: Maybe<Scalars['String']>;
  /** Indicates that the job has been retried. */
  retried?: Maybe<Scalars['Boolean']>;
  /** Indicates the job can be retried. */
  retryable: Scalars['Boolean'];
  /** Runner assigned to execute the job. */
  runner?: Maybe<CiRunner>;
  /**
   * Runner manager assigned to the job. Introduced in 15.11: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  runnerManager?: Maybe<CiRunnerManager>;
  /** Indicates the job is scheduled. */
  scheduled: Scalars['Boolean'];
  /** Schedule for the build. */
  scheduledAt?: Maybe<Scalars['Time']>;
  /** Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise. */
  schedulingType?: Maybe<Scalars['String']>;
  /** Short SHA1 ID of the commit. */
  shortSha: Scalars['String'];
  /** Stage of the job. */
  stage?: Maybe<CiStage>;
  /** When the job was started. */
  startedAt?: Maybe<Scalars['Time']>;
  /** Status of the job. */
  status?: Maybe<CiJobStatus>;
  /** Indicates the job is stuck. */
  stuck: Scalars['Boolean'];
  /** Tags for the current job. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** Trace generated by the job. */
  trace?: Maybe<CiJobTrace>;
  /** Whether the job was triggered. */
  triggered?: Maybe<Scalars['Boolean']>;
  /** Permissions for the current user on the resource */
  userPermissions: JobPermissions;
  /** Web path of the job. */
  webPath?: Maybe<Scalars['String']>;
};


export type CiJobArtifactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobManualVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobNeedsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobPreviousStageJobsOrNeedsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type CiJobArtifact = {
  __typename?: 'CiJobArtifact';
  /** URL for downloading the artifact's file. */
  downloadPath?: Maybe<Scalars['String']>;
  /** Expiry date of the artifact. */
  expireAt?: Maybe<Scalars['Time']>;
  /** File type of the artifact. */
  fileType?: Maybe<JobArtifactFileType>;
  /** ID of the artifact. */
  id: Scalars['CiJobArtifactID'];
  /** File name of the artifact. */
  name?: Maybe<Scalars['String']>;
  /** Size of the artifact in bytes. */
  size: Scalars['BigInt'];
};

/** The connection type for CiJobArtifact. */
export type CiJobArtifactConnection = {
  __typename?: 'CiJobArtifactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobArtifactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJobArtifact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiJobArtifactEdge = {
  __typename?: 'CiJobArtifactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJobArtifact>;
};

/** The connection type for CiJob. */
export type CiJobConnection = {
  __typename?: 'CiJobConnection';
  /** Limited count of collection. Returns limit + 1 for counts greater than the limit. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiJobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiJob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};


/** The connection type for CiJob. */
export type CiJobConnectionCountArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type CiJobEdge = {
  __typename?: 'CiJobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiJob>;
};

export type CiJobKind =
  /** Bridge CI job connecting a parent and child pipeline. */
  | 'BRIDGE'
  /** Standard CI job. */
  | 'BUILD';

export type CiJobStatus =
  /** A job that is canceled. */
  | 'CANCELED'
  /** A job that is created. */
  | 'CREATED'
  /** A job that is failed. */
  | 'FAILED'
  /** A job that is manual. */
  | 'MANUAL'
  /** A job that is pending. */
  | 'PENDING'
  /** A job that is preparing. */
  | 'PREPARING'
  /** A job that is running. */
  | 'RUNNING'
  /** A job that is scheduled. */
  | 'SCHEDULED'
  /** A job that is skipped. */
  | 'SKIPPED'
  /** A job that is success. */
  | 'SUCCESS'
  /** A job that is waiting for resource. */
  | 'WAITING_FOR_RESOURCE';

/** Autogenerated input type of CiJobTokenScopeAddProject */
export type CiJobTokenScopeAddProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Direction of access, which defaults to INBOUND. Deprecated in 16.0: Outbound
   * job token scope is being removed. This field can now only be set to INBOUND.
   * @deprecated Outbound job token scope is being removed. This field can now only be set to INBOUND. Deprecated in 16.0.
   */
  direction?: InputMaybe<CiJobTokenScopeDirection>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID'];
  /** Project to be added to the CI job token scope. */
  targetProjectPath: Scalars['ID'];
};

/** Autogenerated return type of CiJobTokenScopeAddProject */
export type CiJobTokenScopeAddProjectPayload = {
  __typename?: 'CiJobTokenScopeAddProjectPayload';
  /** CI job token's access scope. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Direction of access. */
export type CiJobTokenScopeDirection =
  /** Target projects in the inbound allowlist can access the scope project through their job tokens. */
  | 'INBOUND'
  /** Job token scope project can access target project in the outbound allowlist. */
  | 'OUTBOUND';

/** Autogenerated input type of CiJobTokenScopeRemoveProject */
export type CiJobTokenScopeRemoveProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Direction of access, which defaults to outbound. */
  direction?: InputMaybe<CiJobTokenScopeDirection>;
  /** Project that the CI job token scope belongs to. */
  projectPath: Scalars['ID'];
  /** Project to be removed from the CI job token scope. */
  targetProjectPath: Scalars['ID'];
};

/** Autogenerated return type of CiJobTokenScopeRemoveProject */
export type CiJobTokenScopeRemoveProjectPayload = {
  __typename?: 'CiJobTokenScopeRemoveProjectPayload';
  /** CI job token's scope of access. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type CiJobTokenScopeType = {
  __typename?: 'CiJobTokenScopeType';
  /** Allow list of projects that can access the current project through its CI Job tokens. */
  inboundAllowlist: ProjectConnection;
  /** Allow list of projects that are accessible using the current project's CI Job tokens. */
  outboundAllowlist: ProjectConnection;
  /**
   * Allow list of projects that can be accessed by CI Job tokens created by this
   * project. Deprecated in 15.9: The `projects` attribute is being deprecated. Use
   * `outbound_allowlist`.
   * @deprecated The `projects` attribute is being deprecated. Use `outbound_allowlist`. Deprecated in 15.9.
   */
  projects: ProjectConnection;
};


export type CiJobTokenScopeTypeInboundAllowlistArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobTokenScopeTypeOutboundAllowlistArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiJobTokenScopeTypeProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type CiJobTrace = {
  __typename?: 'CiJobTrace';
  /**
   * HTML summary containing the last 10 lines of the trace. Introduced in 15.11:
   * This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  htmlSummary: Scalars['String'];
};

/** Representation of duration statistics for a group of CI jobs. */
export type CiJobsDurationStatistics = {
  __typename?: 'CiJobsDurationStatistics';
  /**
   * 50th percentile. 50% of the durations are lower than this value. Introduced in
   * 15.8: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  p50?: Maybe<Scalars['Duration']>;
  /**
   * 75th percentile. 75% of the durations are lower than this value. Introduced in
   * 15.8: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  p75?: Maybe<Scalars['Duration']>;
  /**
   * 90th percentile. 90% of the durations are lower than this value. Introduced in
   * 15.8: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  p90?: Maybe<Scalars['Duration']>;
  /**
   * 95th percentile. 95% of the durations are lower than this value. Introduced in
   * 15.8: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  p95?: Maybe<Scalars['Duration']>;
  /**
   * 99th percentile. 99% of the durations are lower than this value. Introduced in
   * 15.8: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  p99?: Maybe<Scalars['Duration']>;
};

/** Statistics for a group of CI jobs. */
export type CiJobsStatistics = {
  __typename?: 'CiJobsStatistics';
  /**
   * Statistics for amount of time that jobs were waiting to be picked up. The
   * calculation is performed based on the most recent 100 jobs executed by the
   * 5000 most recently created runners in context. If no filter is applied to
   * runners, the calculation is performed based on the most recent 100 jobs
   * globally. Introduced in 15.8: This feature is an Experiment. It can be changed
   * or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  queuedDuration?: Maybe<CiJobsDurationStatistics>;
};

/** CI/CD variables given to a manual job. */
export type CiManualVariable = CiVariable & {
  __typename?: 'CiManualVariable';
  /**
   * Scope defining the environments that can use the variable. Deprecated in 15.3:
   * No longer used, only available for GroupVariableType and ProjectVariableType.
   * @deprecated No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in 15.3.
   */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiManualVariable. */
export type CiManualVariableConnection = {
  __typename?: 'CiManualVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiManualVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiManualVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiManualVariableEdge = {
  __typename?: 'CiManualVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiManualVariable>;
};

export type CiMinutesNamespaceMonthlyUsage = {
  __typename?: 'CiMinutesNamespaceMonthlyUsage';
  /** Total number of units of compute used by all projects in the namespace. */
  minutes?: Maybe<Scalars['Int']>;
  /** Month related to the usage data. */
  month?: Maybe<Scalars['String']>;
  /** Month related to the usage data in ISO 8601 date format. */
  monthIso8601?: Maybe<Scalars['ISO8601Date']>;
  /** Compute usage data for projects in the namespace. */
  projects?: Maybe<CiMinutesProjectMonthlyUsageConnection>;
  /** Total duration (in seconds) of shared runners use by the namespace for the month. */
  sharedRunnersDuration?: Maybe<Scalars['Int']>;
};


export type CiMinutesNamespaceMonthlyUsageProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiMinutesNamespaceMonthlyUsage. */
export type CiMinutesNamespaceMonthlyUsageConnection = {
  __typename?: 'CiMinutesNamespaceMonthlyUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiMinutesNamespaceMonthlyUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiMinutesNamespaceMonthlyUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiMinutesNamespaceMonthlyUsageEdge = {
  __typename?: 'CiMinutesNamespaceMonthlyUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiMinutesNamespaceMonthlyUsage>;
};

export type CiMinutesProjectMonthlyUsage = {
  __typename?: 'CiMinutesProjectMonthlyUsage';
  /** Number of units of compute used by the project in the month. */
  minutes?: Maybe<Scalars['Int']>;
  /**
   * Name of the project. Deprecated in 15.6: Use `project.name`.
   * @deprecated Use `project.name`. Deprecated in 15.6.
   */
  name?: Maybe<Scalars['String']>;
  /** Project having the recorded usage. */
  project?: Maybe<Project>;
  /** Total duration (in seconds) of shared runners use by the project for the month. */
  sharedRunnersDuration?: Maybe<Scalars['Int']>;
};

/** The connection type for CiMinutesProjectMonthlyUsage. */
export type CiMinutesProjectMonthlyUsageConnection = {
  __typename?: 'CiMinutesProjectMonthlyUsageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiMinutesProjectMonthlyUsageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiMinutesProjectMonthlyUsage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiMinutesProjectMonthlyUsageEdge = {
  __typename?: 'CiMinutesProjectMonthlyUsageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiMinutesProjectMonthlyUsage>;
};

/** CI/CD variables for a project. */
export type CiProjectVariable = CiVariable & {
  __typename?: 'CiProjectVariable';
  /** Description of the variable. */
  description?: Maybe<Scalars['String']>;
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for CiProjectVariable. */
export type CiProjectVariableConnection = {
  __typename?: 'CiProjectVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiProjectVariableEdge>>>;
  /** Maximum amount of project CI/CD variables. */
  limit: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiProjectVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiProjectVariableEdge = {
  __typename?: 'CiProjectVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiProjectVariable>;
};

export type CiRunner = {
  __typename?: 'CiRunner';
  /** Access level of the runner. */
  accessLevel: CiRunnerAccessLevel;
  /**
   * Indicates the runner is allowed to receive jobs. Deprecated in 14.8: Use paused.
   * @deprecated Use paused. Deprecated in 14.8.
   */
  active: Scalars['Boolean'];
  /** Admin URL of the runner. Only available for administrators. */
  adminUrl?: Maybe<Scalars['String']>;
  /**
   * Architecture provided by the the runner. Deprecated in 16.2: Use field in `manager` object instead.
   * @deprecated Use field in `manager` object instead. Deprecated in 16.2.
   */
  architectureName?: Maybe<Scalars['String']>;
  /** Timestamp of last contact from this runner. */
  contactedAt?: Maybe<Scalars['Time']>;
  /** Timestamp of creation of this runner. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that created this runner. */
  createdBy?: Maybe<UserCore>;
  /** Description of the runner. */
  description?: Maybe<Scalars['String']>;
  /** Admin form URL of the runner. Only available for administrators. */
  editAdminUrl?: Maybe<Scalars['String']>;
  /**
   * Ephemeral authentication token used for runner manager registration. Only
   * available for the creator of the runner for a limited time during
   * registration. Introduced in 15.9: This feature is an Experiment. It can be
   * changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  ephemeralAuthenticationToken?: Maybe<Scalars['String']>;
  /**
   * URL of the registration page of the runner manager. Only available for the
   * creator of the runner for a limited time during registration. Introduced in
   * 15.11: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  ephemeralRegisterUrl?: Maybe<Scalars['String']>;
  /**
   * Executor last advertised by the runner. Deprecated in 16.2: Use field in `manager` object instead.
   * @deprecated Use field in `manager` object instead. Deprecated in 16.2.
   */
  executorName?: Maybe<Scalars['String']>;
  /** Groups the runner is associated with. For group runners only. */
  groups?: Maybe<GroupConnection>;
  /** ID of the runner. */
  id: Scalars['CiRunnerID'];
  /**
   * IP address of the runner. Deprecated in 16.2: Use field in `manager` object instead.
   * @deprecated Use field in `manager` object instead. Deprecated in 16.2.
   */
  ipAddress?: Maybe<Scalars['String']>;
  /** Number of jobs processed by the runner (limited to 1000, plus one to indicate that more items exist). */
  jobCount?: Maybe<Scalars['Int']>;
  /**
   * Job execution status of the runner. Introduced in 15.7: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.
   */
  jobExecutionStatus?: Maybe<CiRunnerJobExecutionStatus>;
  /** Jobs assigned to the runner. This field can only be resolved for one runner in any single request. */
  jobs?: Maybe<CiJobConnection>;
  /** Indicates the runner is locked. */
  locked?: Maybe<Scalars['Boolean']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `maintenance_note` */
  maintenanceNoteHtml?: Maybe<Scalars['String']>;
  /**
   * Machines associated with the runner configuration. Introduced in 15.10: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  managers?: Maybe<CiRunnerManagerConnection>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: Maybe<Scalars['Int']>;
  /** Project that owns the runner. For project runners only. */
  ownerProject?: Maybe<Project>;
  /** Indicates the runner is paused and not available to run jobs. */
  paused: Scalars['Boolean'];
  /**
   * Platform provided by the runner. Deprecated in 16.2: Use field in `manager` object instead.
   * @deprecated Use field in `manager` object instead. Deprecated in 16.2.
   */
  platformName?: Maybe<Scalars['String']>;
  /** Private projects' "compute cost factor" associated with the runner (GitLab.com only). */
  privateProjectsMinutesCostFactor?: Maybe<Scalars['Float']>;
  /** Number of projects that the runner is associated with. */
  projectCount?: Maybe<Scalars['Int']>;
  /** Find projects the runner is associated with. For project runners only. */
  projects?: Maybe<ProjectConnection>;
  /** Public projects' "compute cost factor" associated with the runner (GitLab.com only). */
  publicProjectsMinutesCostFactor?: Maybe<Scalars['Float']>;
  /**
   * URL of the temporary registration page of the runner. Only available before
   * the runner is registered. Only available for administrators.
   */
  registerAdminUrl?: Maybe<Scalars['String']>;
  /**
   * Revision of the runner. Deprecated in 16.2: Use field in `manager` object instead.
   * @deprecated Use field in `manager` object instead. Deprecated in 16.2.
   */
  revision?: Maybe<Scalars['String']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged: Scalars['Boolean'];
  /** Type of the runner. */
  runnerType: CiRunnerType;
  /** First eight characters of the runner's token used to authenticate new job requests. Used as the runner's unique ID. */
  shortSha?: Maybe<Scalars['String']>;
  /** Status of the runner. */
  status: CiRunnerStatus;
  /** Tags associated with the runner. */
  tagList?: Maybe<Array<Scalars['String']>>;
  /** Runner token expiration time. */
  tokenExpiresAt?: Maybe<Scalars['Time']>;
  /**
   * Availability of upgrades for the runner. Introduced in 14.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 14.10.
   */
  upgradeStatus?: Maybe<CiRunnerUpgradeStatus>;
  /** Permissions for the current user on the resource */
  userPermissions: RunnerPermissions;
  /**
   * Version of the runner. Deprecated in 16.2: Use field in `manager` object instead.
   * @deprecated Use field in `manager` object instead. Deprecated in 16.2.
   */
  version?: Maybe<Scalars['String']>;
};


export type CiRunnerGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiRunnerJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
};


export type CiRunnerManagersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiRunnerProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membership?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']>;
  sort?: InputMaybe<Scalars['String']>;
  topics?: InputMaybe<Array<Scalars['String']>>;
};


export type CiRunnerStatusArgs = {
  legacyMode?: InputMaybe<Scalars['String']>;
};

export type CiRunnerAccessLevel =
  /** A runner that is not protected. */
  | 'NOT_PROTECTED'
  /** A runner that is ref protected. */
  | 'REF_PROTECTED';

/** The connection type for CiRunner. */
export type CiRunnerConnection = {
  __typename?: 'CiRunnerConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiRunnerEdge>>>;
  /** Jobs statistics for jobs executed by a collection of runners. Available only to admins. */
  jobsStatistics?: Maybe<CiJobsStatistics>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiRunner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiRunnerEdge = {
  __typename?: 'CiRunnerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /**
   * Web URL of the runner edit page. The value depends on where you put this field
   * in the query. You can use it for projects or groups.
   */
  editUrl?: Maybe<Scalars['String']>;
  /** The item at the end of the edge. */
  node?: Maybe<CiRunner>;
  /** Web URL of the runner. The value depends on where you put this field in the query. You can use it for projects or groups. */
  webUrl?: Maybe<Scalars['String']>;
};

export type CiRunnerJobExecutionStatus =
  /** Runner is idle. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time. */
  | 'IDLE'
  /** Runner is executing jobs. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time. */
  | 'RUNNING';

export type CiRunnerManager = {
  __typename?: 'CiRunnerManager';
  /** Architecture provided by the runner manager. */
  architectureName?: Maybe<Scalars['String']>;
  /** Timestamp of last contact from the runner manager. */
  contactedAt?: Maybe<Scalars['Time']>;
  /** Timestamp of creation of the runner manager. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Executor last advertised by the runner. */
  executorName?: Maybe<Scalars['String']>;
  /** ID of the runner manager. */
  id: Scalars['CiRunnerManagerID'];
  /** IP address of the runner manager. */
  ipAddress?: Maybe<Scalars['String']>;
  /** Platform provided by the runner manager. */
  platformName?: Maybe<Scalars['String']>;
  /** Revision of the runner. */
  revision?: Maybe<Scalars['String']>;
  /** Runner configuration for the runner manager. */
  runner?: Maybe<CiRunner>;
  /** Status of the runner manager. */
  status: CiRunnerStatus;
  /** System ID associated with the runner manager. */
  systemId: Scalars['String'];
  /**
   * Availability of upgrades for the runner manager. Introduced in 16.1: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  upgradeStatus?: Maybe<CiRunnerUpgradeStatus>;
  /** Version of the runner. */
  version?: Maybe<Scalars['String']>;
};

/** The connection type for CiRunnerManager. */
export type CiRunnerManagerConnection = {
  __typename?: 'CiRunnerManagerConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiRunnerManagerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiRunnerManager>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiRunnerManagerEdge = {
  __typename?: 'CiRunnerManagerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiRunnerManager>;
};

/** Values for filtering runners in namespaces. The previous type name `RunnerMembershipFilter` was deprecated in 15.4. */
export type CiRunnerMembershipFilter =
  /**
   * Include all runners. This list includes runners for all projects in the group
   * and subgroups, as well as for the parent groups and instance. Introduced in
   * 15.5: This feature is an Experiment. It can be changed or removed at any time.
   */
  | 'ALL_AVAILABLE'
  /**
   * Include runners that have either a direct or inherited relationship. These
   * runners can be specific to a project or a group.
   */
  | 'DESCENDANTS'
  /** Include runners that have a direct relationship. */
  | 'DIRECT';

/** Values for sorting runners */
export type CiRunnerSort =
  /** Ordered by contacted_at in ascending order. */
  | 'CONTACTED_ASC'
  /** Ordered by contacted_at in descending order. */
  | 'CONTACTED_DESC'
  /** Ordered by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Ordered by created_at in descending order. */
  | 'CREATED_DESC'
  /** Ordered by token_expires_at in ascending order. */
  | 'TOKEN_EXPIRES_AT_ASC'
  /** Ordered by token_expires_at in descending order. */
  | 'TOKEN_EXPIRES_AT_DESC';

export type CiRunnerStatus =
  /** Runner that is not paused. Deprecated in 14.6: This was renamed. */
  | 'ACTIVE'
  /** Runner that has never contacted this instance. */
  | 'NEVER_CONTACTED'
  /**
   * Runner that has not contacted this instance within the last 2 hours. Will be
   * considered `STALE` if offline for more than 3 months.
   */
  | 'OFFLINE'
  /** Runner that contacted this instance within the last 2 hours. */
  | 'ONLINE'
  /** Runner that is paused. Deprecated in 14.6: This was renamed. */
  | 'PAUSED'
  /** Runner that has not contacted this instance within the last 3 months. */
  | 'STALE';

export type CiRunnerType =
  /** A runner that is group type. */
  | 'GROUP_TYPE'
  /** A runner that is instance type. */
  | 'INSTANCE_TYPE'
  /** A runner that is project type. */
  | 'PROJECT_TYPE';

export type CiRunnerUpgradeStatus =
  /** Upgrade is available for the runner. */
  | 'AVAILABLE'
  /** Runner version is not valid. */
  | 'INVALID'
  /** Upgrade is not available for the runner. */
  | 'NOT_AVAILABLE'
  /** Upgrade is available and recommended for the runner. */
  | 'RECOMMENDED';

/** Represents the Geo replication and verification state of a ci_secure_file. */
export type CiSecureFileRegistry = {
  __typename?: 'CiSecureFileRegistry';
  /** ID of the Ci Secure File. */
  ciSecureFileId: Scalars['ID'];
  /** Timestamp when the CiSecureFileRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the CiSecureFileRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the CiSecureFileRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the CiSecureFileRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the CiSecureFileRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the CiSecureFileRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the CiSecureFileRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the CiSecureFileRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the CiSecureFileRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for CiSecureFileRegistry. */
export type CiSecureFileRegistryConnection = {
  __typename?: 'CiSecureFileRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiSecureFileRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiSecureFileRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiSecureFileRegistryEdge = {
  __typename?: 'CiSecureFileRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiSecureFileRegistry>;
};

export type CiStage = {
  __typename?: 'CiStage';
  /** Detailed status of the stage. */
  detailedStatus?: Maybe<DetailedStatus>;
  /** Group of jobs for the stage. */
  groups?: Maybe<CiGroupConnection>;
  /** ID of the stage. */
  id: Scalars['ID'];
  /** Jobs for the stage. */
  jobs?: Maybe<CiJobConnection>;
  /** Name of the stage. */
  name?: Maybe<Scalars['String']>;
  /** Status of the pipeline stage. */
  status?: Maybe<Scalars['String']>;
};


export type CiStageGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CiStageJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CiStage. */
export type CiStageConnection = {
  __typename?: 'CiStageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CiStageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CiStage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CiStageEdge = {
  __typename?: 'CiStageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CiStage>;
};

/** GitLab CI/CD configuration template. */
export type CiTemplate = {
  __typename?: 'CiTemplate';
  /** Contents of the CI template. */
  content: Scalars['String'];
  /** Name of the CI template. */
  name: Scalars['String'];
};

export type CiVariable = {
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** Attributes for defining a CI/CD variable. */
export type CiVariableInput = {
  /** Name of the variable. */
  key: Scalars['String'];
  /** Value of the variable. */
  value: Scalars['String'];
};

/** Values for sorting variables */
export type CiVariableSort =
  /** Sorted by key in ascending order. */
  | 'KEY_ASC'
  /** Sorted by key in descending order. */
  | 'KEY_DESC';

export type CiVariableType =
  /** Env var type. */
  | 'ENV_VAR'
  /** File type. */
  | 'FILE';

export type ClusterAgent = {
  __typename?: 'ClusterAgent';
  /** Recent activity for the cluster agent. */
  activityEvents?: Maybe<ClusterAgentActivityEventConnection>;
  /** Active connections for the cluster agent */
  connections?: Maybe<ConnectedAgentConnection>;
  /** Timestamp the cluster agent was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User object, containing information about the person who created the agent. */
  createdByUser?: Maybe<UserCore>;
  /** ID of the cluster agent. */
  id: Scalars['ID'];
  /** Name of the cluster agent. */
  name?: Maybe<Scalars['String']>;
  /** Project this cluster agent is associated with. */
  project?: Maybe<Project>;
  /** Tokens associated with the cluster agent. */
  tokens?: Maybe<ClusterAgentTokenConnection>;
  /** Timestamp the cluster agent was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Container images reported on the agent vulnerabilities. */
  vulnerabilityImages?: Maybe<VulnerabilityContainerImageConnection>;
  /** Web path of the cluster agent. */
  webPath?: Maybe<Scalars['String']>;
};


export type ClusterAgentActivityEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ClusterAgentConnectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ClusterAgentTokensArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ClusterAgentVulnerabilityImagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ClusterAgentActivityEvent = {
  __typename?: 'ClusterAgentActivityEvent';
  /** Agent token associated with the event. */
  agentToken?: Maybe<ClusterAgentToken>;
  /** Type of event. */
  kind?: Maybe<Scalars['String']>;
  /** Severity of the event. */
  level?: Maybe<Scalars['String']>;
  /** Timestamp the event was recorded. */
  recordedAt?: Maybe<Scalars['Time']>;
  /** User associated with the event. */
  user?: Maybe<UserCore>;
};

/** The connection type for ClusterAgentActivityEvent. */
export type ClusterAgentActivityEventConnection = {
  __typename?: 'ClusterAgentActivityEventConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentActivityEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentActivityEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClusterAgentActivityEventEdge = {
  __typename?: 'ClusterAgentActivityEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentActivityEvent>;
};

export type ClusterAgentAuthorizationCiAccess = {
  __typename?: 'ClusterAgentAuthorizationCiAccess';
  /** Authorized cluster agent. */
  agent?: Maybe<ClusterAgent>;
  /** Configuration for the authorized project. */
  config?: Maybe<Scalars['JSON']>;
};

/** The connection type for ClusterAgentAuthorizationCiAccess. */
export type ClusterAgentAuthorizationCiAccessConnection = {
  __typename?: 'ClusterAgentAuthorizationCiAccessConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentAuthorizationCiAccessEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentAuthorizationCiAccess>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClusterAgentAuthorizationCiAccessEdge = {
  __typename?: 'ClusterAgentAuthorizationCiAccessEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentAuthorizationCiAccess>;
};

export type ClusterAgentAuthorizationUserAccess = {
  __typename?: 'ClusterAgentAuthorizationUserAccess';
  /** Authorized cluster agent. */
  agent?: Maybe<ClusterAgent>;
  /** Configuration for the authorized project. */
  config?: Maybe<Scalars['JSON']>;
};

/** The connection type for ClusterAgentAuthorizationUserAccess. */
export type ClusterAgentAuthorizationUserAccessConnection = {
  __typename?: 'ClusterAgentAuthorizationUserAccessConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentAuthorizationUserAccessEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentAuthorizationUserAccess>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ClusterAgentAuthorizationUserAccessEdge = {
  __typename?: 'ClusterAgentAuthorizationUserAccessEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentAuthorizationUserAccess>;
};

/** The connection type for ClusterAgent. */
export type ClusterAgentConnection = {
  __typename?: 'ClusterAgentConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ClusterAgentDelete */
export type ClusterAgentDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the cluster agent that will be deleted. */
  id: Scalars['ClustersAgentID'];
};

/** Autogenerated return type of ClusterAgentDelete */
export type ClusterAgentDeletePayload = {
  __typename?: 'ClusterAgentDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type ClusterAgentEdge = {
  __typename?: 'ClusterAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgent>;
};

export type ClusterAgentToken = {
  __typename?: 'ClusterAgentToken';
  /** Cluster agent this token is associated with. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Timestamp the token was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User who created the token. */
  createdByUser?: Maybe<UserCore>;
  /** Description of the token. */
  description?: Maybe<Scalars['String']>;
  /** Global ID of the token. */
  id: Scalars['ClustersAgentTokenID'];
  /** Timestamp the token was last used. */
  lastUsedAt?: Maybe<Scalars['Time']>;
  /** Name given to the token. */
  name?: Maybe<Scalars['String']>;
  /** Current status of the token. */
  status?: Maybe<AgentTokenStatus>;
};

/** The connection type for ClusterAgentToken. */
export type ClusterAgentTokenConnection = {
  __typename?: 'ClusterAgentTokenConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClusterAgentTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ClusterAgentToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ClusterAgentTokenCreate */
export type ClusterAgentTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the cluster agent that will be associated with the new token. */
  clusterAgentId: Scalars['ClustersAgentID'];
  /** Description of the token. */
  description?: InputMaybe<Scalars['String']>;
  /** Name of the token. */
  name: Scalars['String'];
};

/** Autogenerated return type of ClusterAgentTokenCreate */
export type ClusterAgentTokenCreatePayload = {
  __typename?: 'ClusterAgentTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Token secret value. Make sure you save it - you won't be able to access it again. */
  secret?: Maybe<Scalars['String']>;
  /** Token created after mutation. */
  token?: Maybe<ClusterAgentToken>;
};

/** An edge in a connection. */
export type ClusterAgentTokenEdge = {
  __typename?: 'ClusterAgentTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ClusterAgentToken>;
};

/** Autogenerated input type of ClusterAgentTokenRevoke */
export type ClusterAgentTokenRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the agent token that will be revoked. */
  id: Scalars['ClustersAgentTokenID'];
};

/** Autogenerated return type of ClusterAgentTokenRevoke */
export type ClusterAgentTokenRevokePayload = {
  __typename?: 'ClusterAgentTokenRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents the code coverage activity for a group */
export type CodeCoverageActivity = {
  __typename?: 'CodeCoverageActivity';
  /** Average percentage of the different code coverage results available for the group. */
  averageCoverage?: Maybe<Scalars['Float']>;
  /** Number of different code coverage results available for the group. */
  coverageCount?: Maybe<Scalars['Int']>;
  /** Date when the code coverage was created. */
  date: Scalars['Date'];
  /** Number of projects with code coverage results for the group. */
  projectCount?: Maybe<Scalars['Int']>;
};

/** The connection type for CodeCoverageActivity. */
export type CodeCoverageActivityConnection = {
  __typename?: 'CodeCoverageActivityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeCoverageActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeCoverageActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CodeCoverageActivityEdge = {
  __typename?: 'CodeCoverageActivityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeCoverageActivity>;
};

/** Represents the code coverage summary for a project */
export type CodeCoverageSummary = {
  __typename?: 'CodeCoverageSummary';
  /** Average percentage of the different code coverage results available for the project. */
  averageCoverage?: Maybe<Scalars['Float']>;
  /** Number of different code coverage results available. */
  coverageCount?: Maybe<Scalars['Int']>;
  /** Latest date when the code coverage was created for the project. */
  lastUpdatedOn?: Maybe<Scalars['Date']>;
};

/** Represents a code quality degradation on the pipeline. */
export type CodeQualityDegradation = {
  __typename?: 'CodeQualityDegradation';
  /** Description of the code quality degradation. */
  description: Scalars['String'];
  /** Code Quality plugin that reported the finding. */
  engineName: Scalars['String'];
  /** Unique fingerprint to identify the code quality degradation. For example, an MD5 hash. */
  fingerprint: Scalars['String'];
  /** Line on which the code quality degradation occurred. */
  line: Scalars['Int'];
  /** Relative path to the file containing the code quality degradation. */
  path: Scalars['String'];
  /** Status of the degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN). */
  severity: CodeQualityDegradationSeverity;
  /** URL to the file along with line number. */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for CodeQualityDegradation. */
export type CodeQualityDegradationConnection = {
  __typename?: 'CodeQualityDegradationConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeQualityDegradationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeQualityDegradation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CodeQualityDegradationEdge = {
  __typename?: 'CodeQualityDegradationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeQualityDegradation>;
};

export type CodeQualityDegradationSeverity =
  /** Code Quality degradation has a status of blocker. */
  | 'BLOCKER'
  /** Code Quality degradation has a status of critical. */
  | 'CRITICAL'
  /** Code Quality degradation has a status of info. */
  | 'INFO'
  /** Code Quality degradation has a status of major. */
  | 'MAJOR'
  /** Code Quality degradation has a status of minor. */
  | 'MINOR'
  /** Code Quality degradation has a status of unknown. */
  | 'UNKNOWN';

/** Code Quality report for a pipeline */
export type CodeQualityReportSummary = {
  __typename?: 'CodeQualityReportSummary';
  /** Total number of blocker status. */
  blocker?: Maybe<Scalars['Int']>;
  /** Total number of Code Quality reports. */
  count?: Maybe<Scalars['Int']>;
  /** Total number of critical status. */
  critical?: Maybe<Scalars['Int']>;
  /** Total number of info status. */
  info?: Maybe<Scalars['Int']>;
  /** Total number of major status. */
  major?: Maybe<Scalars['Int']>;
  /** Total number of minor status. */
  minor?: Maybe<Scalars['Int']>;
  /** Total number of unknown status. */
  unknown?: Maybe<Scalars['Int']>;
};

export type Commit = Todoable & {
  __typename?: 'Commit';
  /** Author of the commit. */
  author?: Maybe<UserCore>;
  /** Commit author's email. */
  authorEmail?: Maybe<Scalars['String']>;
  /** Commit authors gravatar. */
  authorGravatar?: Maybe<Scalars['String']>;
  /** Commit authors name. */
  authorName?: Maybe<Scalars['String']>;
  /** Timestamp of when the commit was authored. */
  authoredDate?: Maybe<Scalars['Time']>;
  /** Description of the commit message. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Full title of the commit message. */
  fullTitle?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `full_title` */
  fullTitleHtml?: Maybe<Scalars['String']>;
  /** ID (global ID) of the commit. */
  id: Scalars['ID'];
  /** Raw commit message. */
  message?: Maybe<Scalars['String']>;
  /** Pipelines of the commit ordered latest first. */
  pipelines?: Maybe<PipelineConnection>;
  /** SHA1 ID of the commit. */
  sha: Scalars['String'];
  /** Short SHA1 ID of the commit. */
  shortId: Scalars['String'];
  /** Signature of the commit. */
  signature?: Maybe<CommitSignature>;
  /** Rendered HTML of the commit signature. */
  signatureHtml?: Maybe<Scalars['String']>;
  /** Title of the commit message. */
  title?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Web path of the commit. */
  webPath: Scalars['String'];
  /** Web URL of the commit. */
  webUrl: Scalars['String'];
};


export type CommitPipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  ref?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<PipelineScopeEnum>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<PipelineStatusEnum>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};

export type CommitAction = {
  /** Action to perform: create, delete, move, update, or chmod. */
  action: CommitActionMode;
  /** Content of the file. */
  content?: InputMaybe<Scalars['String']>;
  /** Encoding of the file. Default is text. */
  encoding?: InputMaybe<CommitEncoding>;
  /** Enables/disables the execute flag on the file. */
  executeFilemode?: InputMaybe<Scalars['Boolean']>;
  /** Full path to the file. */
  filePath: Scalars['String'];
  /** Last known file commit ID. */
  lastCommitId?: InputMaybe<Scalars['String']>;
  /** Original full path to the file being moved. */
  previousPath?: InputMaybe<Scalars['String']>;
};

/** Mode of a commit action */
export type CommitActionMode =
  /** Chmod command. */
  | 'CHMOD'
  /** Create command. */
  | 'CREATE'
  /** Delete command. */
  | 'DELETE'
  /** Move command. */
  | 'MOVE'
  /** Update command. */
  | 'UPDATE';

/** The connection type for Commit. */
export type CommitConnection = {
  __typename?: 'CommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CommitCreate */
export type CommitCreateInput = {
  /** Array of action hashes to commit as a batch. */
  actions: Array<CommitAction>;
  /** Name of the branch to commit into, it can be a new branch. */
  branch: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Raw commit message. */
  message: Scalars['String'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID'];
  /** If on a new branch, name of the original branch. */
  startBranch?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CommitCreate */
export type CommitCreatePayload = {
  __typename?: 'CommitCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Commit after mutation. */
  commit?: Maybe<Commit>;
  /** ETag path for the commit's pipeline. */
  commitPipelinePath?: Maybe<Scalars['String']>;
  /** Contents of the commit. */
  content?: Maybe<Array<Scalars['String']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type CommitEdge = {
  __typename?: 'CommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Commit>;
};

export type CommitEncoding =
  /** Base64 encoding. */
  | 'BASE64'
  /** Text encoding. */
  | 'TEXT';

export type CommitParentNames = {
  __typename?: 'CommitParentNames';
  /** Names of the commit parent (branch or tag). */
  names?: Maybe<Array<Scalars['String']>>;
};

export type CommitReferences = {
  __typename?: 'CommitReferences';
  /** Get branch names containing a given commit. */
  containingBranches?: Maybe<CommitParentNames>;
  /** Get tag names containing a given commit. */
  containingTags?: Maybe<CommitParentNames>;
  /** Get branch names tipping at a given commit. */
  tippingBranches?: Maybe<CommitParentNames>;
  /** Get tag names tipping at a given commit. */
  tippingTags?: Maybe<CommitParentNames>;
};


export type CommitReferencesContainingBranchesArgs = {
  excludeTipped?: Scalars['Boolean'];
  limit?: Scalars['Int'];
};


export type CommitReferencesContainingTagsArgs = {
  excludeTipped?: Scalars['Boolean'];
  limit?: Scalars['Int'];
};


export type CommitReferencesTippingBranchesArgs = {
  limit?: Scalars['Int'];
};


export type CommitReferencesTippingTagsArgs = {
  limit?: Scalars['Int'];
};

/** Represents signing information for a commit */
export type CommitSignature = {
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

/** Comparable security report type */
export type ComparableSecurityReportType =
  /** API Fuzzing report */
  | 'API_FUZZING'
  /** Container Scanning report */
  | 'CONTAINER_SCANNING'
  /** Coverage Fuzzing report */
  | 'COVERAGE_FUZZING'
  /** DAST report */
  | 'DAST'
  /** Dependency Scanning report */
  | 'DEPENDENCY_SCANNING'
  /** SAST report */
  | 'SAST'
  /** Secret Detection report */
  | 'SECRET_DETECTION';

/** Represents compared security report. */
export type ComparedSecurityReport = {
  __typename?: 'ComparedSecurityReport';
  /**
   * New vulnerability findings. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  added?: Maybe<Array<ComparedSecurityReportFinding>>;
  /** Time of the base report creation. */
  baseReportCreatedAt?: Maybe<Scalars['Time']>;
  /** Indicates whether the base report out of date. */
  baseReportOutOfDate?: Maybe<Scalars['Boolean']>;
  /**
   * Fixed vulnerability findings. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  fixed?: Maybe<Array<ComparedSecurityReportFinding>>;
  /** Time of the base report creation. */
  headReportCreatedAt?: Maybe<Scalars['Time']>;
};

/** Represents finding. */
export type ComparedSecurityReportFinding = {
  __typename?: 'ComparedSecurityReportFinding';
  /** Description of the vulnerability finding. */
  description?: Maybe<Scalars['String']>;
  /** IID of the pipeline. */
  foundByPipelineIid?: Maybe<Scalars['String']>;
  /** Severity of the vulnerability finding. */
  severity?: Maybe<VulnerabilitySeverity>;
  /** Finding status. */
  state?: Maybe<VulnerabilityState>;
  /** Title of the vulnerability finding. */
  title?: Maybe<Scalars['String']>;
  /** UUIDv5 digest based on the vulnerability's report type, primary identifier, location, fingerprint, project identifier. */
  uuid?: Maybe<Scalars['String']>;
};

/** Represents a ComplianceFramework associated with a Project */
export type ComplianceFramework = {
  __typename?: 'ComplianceFramework';
  /** Hexadecimal representation of compliance framework's label color. */
  color: Scalars['String'];
  /** Default compliance framework for the group. */
  default?: Maybe<Scalars['Boolean']>;
  /** Description of the compliance framework. */
  description: Scalars['String'];
  /** Compliance framework ID. */
  id: Scalars['ID'];
  /** Name of the compliance framework. */
  name: Scalars['String'];
  /**
   * Full path of the compliance pipeline configuration stored in a project
   * repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`
   * **(ULTIMATE)**.
   */
  pipelineConfigurationFullPath?: Maybe<Scalars['String']>;
};

/** The connection type for ComplianceFramework. */
export type ComplianceFrameworkConnection = {
  __typename?: 'ComplianceFrameworkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceFrameworkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceFramework>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceFrameworkEdge = {
  __typename?: 'ComplianceFrameworkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceFramework>;
};

export type ComplianceFrameworkFilters = {
  /** ID of the compliance framework. */
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
  /** Negated compliance framework filter input. */
  not?: InputMaybe<NegatedComplianceFrameworkFilters>;
  /** Checks presence of compliance framework of the project, "none" and "any" values are supported. */
  presenceFilter?: InputMaybe<ComplianceFrameworkPresenceFilter>;
};

export type ComplianceFrameworkInput = {
  /** New color representation of the compliance framework in hex format. e.g. #FCA121. */
  color?: InputMaybe<Scalars['String']>;
  /** Set this compliance framework as the default framework for the group. */
  default?: InputMaybe<Scalars['Boolean']>;
  /** New description for the compliance framework. */
  description?: InputMaybe<Scalars['String']>;
  /** New name for the compliance framework. */
  name?: InputMaybe<Scalars['String']>;
  /**
   * Full path of the compliance pipeline configuration stored in a project
   * repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa`
   * **(ULTIMATE)**.
   */
  pipelineConfigurationFullPath?: InputMaybe<Scalars['String']>;
};

/** ComplianceFramework of a project for filtering */
export type ComplianceFrameworkPresenceFilter =
  /** Any compliance framework is assigned. */
  | 'ANY'
  /** No compliance framework is assigned. */
  | 'NONE';

/** Compliance violation associated with a merged merge request. */
export type ComplianceViolation = {
  __typename?: 'ComplianceViolation';
  /** Compliance violation ID. */
  id: Scalars['ID'];
  /** Merge request the compliance violation occurred in. */
  mergeRequest: MergeRequest;
  /** Reason the compliance violation occurred. */
  reason: ComplianceViolationReason;
  /** Severity of the compliance violation. */
  severityLevel: ComplianceViolationSeverity;
  /** User suspected of causing the compliance violation. */
  violatingUser: UserCore;
};

/** The connection type for ComplianceViolation. */
export type ComplianceViolationConnection = {
  __typename?: 'ComplianceViolationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ComplianceViolationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ComplianceViolation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ComplianceViolationEdge = {
  __typename?: 'ComplianceViolationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ComplianceViolation>;
};

export type ComplianceViolationInput = {
  /** Merge requests merged after this date (inclusive). */
  mergedAfter?: InputMaybe<Scalars['Date']>;
  /** Merge requests merged before this date (inclusive). */
  mergedBefore?: InputMaybe<Scalars['Date']>;
  /** Filter compliance violations by project. */
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
  /** Filter compliance violations by target branch. */
  targetBranch?: InputMaybe<Scalars['String']>;
};

/** Reason for the compliance violation. */
export type ComplianceViolationReason =
  /** Approved by committer */
  | 'APPROVED_BY_COMMITTER'
  /** Approved by insufficient users */
  | 'APPROVED_BY_INSUFFICIENT_USERS'
  /** Approved by merge request author */
  | 'APPROVED_BY_MERGE_REQUEST_AUTHOR';

/** Severity of the compliance violation. */
export type ComplianceViolationSeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Info severity */
  | 'INFO'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM';

/** Compliance violation sort values. */
export type ComplianceViolationSort =
  /** Date merged in ascending order, further sorted by ID in ascending order. */
  | 'MERGED_AT_ASC'
  /** Date merged in descending order, further sorted by ID in descending order. */
  | 'MERGED_AT_DESC'
  /** Merge request title in ascending order, further sorted by ID in ascending order. */
  | 'MERGE_REQUEST_TITLE_ASC'
  /** Merge request title in descending order, further sorted by ID in descending order. */
  | 'MERGE_REQUEST_TITLE_DESC'
  /** Severity in ascending order, further sorted by ID in ascending order. */
  | 'SEVERITY_LEVEL_ASC'
  /** Severity in descending order, further sorted by ID in descending order. */
  | 'SEVERITY_LEVEL_DESC'
  /** Violation reason in ascending order, further sorted by ID in ascending order. */
  | 'VIOLATION_REASON_ASC'
  /** Violation reason in descending order, further sorted by ID in descending order. */
  | 'VIOLATION_REASON_DESC';

/** Composer metadata */
export type ComposerMetadata = {
  __typename?: 'ComposerMetadata';
  /** Data of the Composer JSON file. */
  composerJson: PackageComposerJsonType;
  /** Target SHA of the package. */
  targetSha: Scalars['String'];
};

/** Conan file metadata */
export type ConanFileMetadata = PackageFileMetadata & {
  __typename?: 'ConanFileMetadata';
  /** Type of the Conan file. */
  conanFileType: ConanMetadatumFileTypeEnum;
  /** Reference of the Conan package. */
  conanPackageReference?: Maybe<Scalars['String']>;
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the metadatum. */
  id: Scalars['PackagesConanFileMetadatumID'];
  /** Revision of the package. */
  packageRevision?: Maybe<Scalars['String']>;
  /** Revision of the Conan recipe. */
  recipeRevision: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Conan metadata */
export type ConanMetadata = {
  __typename?: 'ConanMetadata';
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the metadatum. */
  id: Scalars['PackagesConanMetadatumID'];
  /** Channel of the Conan package. */
  packageChannel: Scalars['String'];
  /** Username of the Conan package. */
  packageUsername: Scalars['String'];
  /** Recipe of the Conan package. */
  recipe: Scalars['String'];
  /** Recipe path of the Conan package. */
  recipePath: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Conan file types */
export type ConanMetadatumFileTypeEnum =
  /** A package file type. */
  | 'PACKAGE_FILE'
  /** A recipe file type. */
  | 'RECIPE_FILE';

/** Autogenerated input type of ConfigureContainerScanning */
export type ConfigureContainerScanningInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ConfigureContainerScanning */
export type ConfigureContainerScanningPayload = {
  __typename?: 'ConfigureContainerScanningPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureDependencyScanning */
export type ConfigureDependencyScanningInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ConfigureDependencyScanning */
export type ConfigureDependencyScanningPayload = {
  __typename?: 'ConfigureDependencyScanningPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureSastIac */
export type ConfigureSastIacInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ConfigureSastIac */
export type ConfigureSastIacPayload = {
  __typename?: 'ConfigureSastIacPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureSast */
export type ConfigureSastInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** SAST CI configuration for the project. */
  configuration: SastCiConfigurationInput;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ConfigureSast */
export type ConfigureSastPayload = {
  __typename?: 'ConfigureSastPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ConfigureSecretDetection */
export type ConfigureSecretDetectionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ConfigureSecretDetection */
export type ConfigureSecretDetectionPayload = {
  __typename?: 'ConfigureSecretDetectionPayload';
  /** Branch that has the new/modified `.gitlab-ci.yml` file. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Redirect path to use when the response is successful. */
  successPath?: Maybe<Scalars['String']>;
};

/** Connection details for an Agent */
export type ConnectedAgent = {
  __typename?: 'ConnectedAgent';
  /** When the connection was established. */
  connectedAt?: Maybe<Scalars['Time']>;
  /** ID of the connection. */
  connectionId?: Maybe<Scalars['BigInt']>;
  /** Information about the Agent. */
  metadata?: Maybe<AgentMetadata>;
};

/** The connection type for ConnectedAgent. */
export type ConnectedAgentConnection = {
  __typename?: 'ConnectedAgentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectedAgentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ConnectedAgent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ConnectedAgentEdge = {
  __typename?: 'ConnectedAgentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectedAgent>;
};

/** Values for sorting contacts */
export type ContactSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Description in ascending order. */
  | 'DESCRIPTION_ASC'
  /** Description in descending order. */
  | 'DESCRIPTION_DESC'
  /** Email in ascending order. */
  | 'EMAIL_ASC'
  /** Email in descending order. */
  | 'EMAIL_DESC'
  /** First name in ascending order. */
  | 'FIRST_NAME_ASC'
  /** First name in descending order. */
  | 'FIRST_NAME_DESC'
  /** Last name in ascending order. */
  | 'LAST_NAME_ASC'
  /** Last name in descending order. */
  | 'LAST_NAME_DESC'
  /** Organization in ascending order. */
  | 'ORGANIZATION_ASC'
  /** Organization in descending order. */
  | 'ORGANIZATION_DESC'
  /** Phone in ascending order. */
  | 'PHONE_ASC'
  /** Phone in descending order. */
  | 'PHONE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Represents the total number of contacts for the represented states. */
export type ContactStateCounts = {
  __typename?: 'ContactStateCounts';
  /** Number of contacts with state `ACTIVE` */
  active?: Maybe<Scalars['Int']>;
  /** Number of contacts with state `ALL` */
  all?: Maybe<Scalars['Int']>;
  /** Number of contacts with state `INACTIVE` */
  inactive?: Maybe<Scalars['Int']>;
};

/** A tag expiration policy designed to keep only the images that matter most */
export type ContainerExpirationPolicy = {
  __typename?: 'ContainerExpirationPolicy';
  /** This container expiration policy schedule. */
  cadence: ContainerExpirationPolicyCadenceEnum;
  /** Timestamp of when the container expiration policy was created. */
  createdAt: Scalars['Time'];
  /** Indicates whether this container expiration policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Number of tags to retain. */
  keepN?: Maybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching this regex pattern will expire. */
  nameRegex?: Maybe<Scalars['UntrustedRegexp']>;
  /** Tags with names matching this regex pattern will be preserved. */
  nameRegexKeep?: Maybe<Scalars['UntrustedRegexp']>;
  /** Next time that this container expiration policy will get executed. */
  nextRunAt?: Maybe<Scalars['Time']>;
  /** Tags older that this will expire. */
  olderThan?: Maybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Timestamp of when the container expiration policy was updated. */
  updatedAt: Scalars['Time'];
};

export type ContainerExpirationPolicyCadenceEnum =
  /** Every day */
  | 'EVERY_DAY'
  /** Every month */
  | 'EVERY_MONTH'
  /** Every three months */
  | 'EVERY_THREE_MONTHS'
  /** Every two weeks */
  | 'EVERY_TWO_WEEKS'
  /** Every week */
  | 'EVERY_WEEK';

export type ContainerExpirationPolicyKeepEnum =
  /** 50 tags per image name */
  | 'FIFTY_TAGS'
  /** 5 tags per image name */
  | 'FIVE_TAGS'
  /** 100 tags per image name */
  | 'ONE_HUNDRED_TAGS'
  /** 1 tag per image name */
  | 'ONE_TAG'
  /** 10 tags per image name */
  | 'TEN_TAGS'
  /** 25 tags per image name */
  | 'TWENTY_FIVE_TAGS';

export type ContainerExpirationPolicyOlderThanEnum =
  /** 14 days until tags are automatically removed */
  | 'FOURTEEN_DAYS'
  /** 90 days until tags are automatically removed */
  | 'NINETY_DAYS'
  /** 7 days until tags are automatically removed */
  | 'SEVEN_DAYS'
  /** 60 days until tags are automatically removed */
  | 'SIXTY_DAYS'
  /** 30 days until tags are automatically removed */
  | 'THIRTY_DAYS';

/** A container repository */
export type ContainerRepository = {
  __typename?: 'ContainerRepository';
  /** Can the current user delete the container repository. */
  canDelete: Scalars['Boolean'];
  /** Timestamp when the container repository was created. */
  createdAt: Scalars['Time'];
  /** Tags cleanup status for the container repository. */
  expirationPolicyCleanupStatus?: Maybe<ContainerRepositoryCleanupStatus>;
  /** Timestamp when the cleanup done by the expiration policy was started on the container repository. */
  expirationPolicyStartedAt?: Maybe<Scalars['Time']>;
  /** ID of the container repository. */
  id: Scalars['ID'];
  /** Number of deleted tags from the last cleanup. */
  lastCleanupDeletedTagsCount?: Maybe<Scalars['Int']>;
  /** URL of the container repository. */
  location: Scalars['String'];
  /** Migration state of the container repository. */
  migrationState: Scalars['String'];
  /** Name of the container repository. */
  name: Scalars['String'];
  /** Path of the container repository. */
  path: Scalars['String'];
  /** Project of the container registry. */
  project: Project;
  /** Status of the container repository. */
  status?: Maybe<ContainerRepositoryStatus>;
  /** Number of tags associated with this image. */
  tagsCount: Scalars['Int'];
  /** Timestamp when the container repository was updated. */
  updatedAt: Scalars['Time'];
};

/** Status of the tags cleanup of a container repository */
export type ContainerRepositoryCleanupStatus =
  /** Tags cleanup is ongoing. */
  | 'ONGOING'
  /** Tags cleanup is scheduled and is going to be executed shortly. */
  | 'SCHEDULED'
  /** Tags cleanup has been partially executed. There are still remaining tags to delete. */
  | 'UNFINISHED'
  /** Tags cleanup is not scheduled. This is the default state. */
  | 'UNSCHEDULED';

/** The connection type for ContainerRepository. */
export type ContainerRepositoryConnection = {
  __typename?: 'ContainerRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Details of a container repository */
export type ContainerRepositoryDetails = {
  __typename?: 'ContainerRepositoryDetails';
  /** Can the current user delete the container repository. */
  canDelete: Scalars['Boolean'];
  /** Timestamp when the container repository was created. */
  createdAt: Scalars['Time'];
  /** Tags cleanup status for the container repository. */
  expirationPolicyCleanupStatus?: Maybe<ContainerRepositoryCleanupStatus>;
  /** Timestamp when the cleanup done by the expiration policy was started on the container repository. */
  expirationPolicyStartedAt?: Maybe<Scalars['Time']>;
  /** ID of the container repository. */
  id: Scalars['ID'];
  /** Number of deleted tags from the last cleanup. */
  lastCleanupDeletedTagsCount?: Maybe<Scalars['Int']>;
  /** URL of the container repository. */
  location: Scalars['String'];
  /** Migration state of the container repository. */
  migrationState: Scalars['String'];
  /** Name of the container repository. */
  name: Scalars['String'];
  /** Path of the container repository. */
  path: Scalars['String'];
  /** Project of the container registry. */
  project: Project;
  /**
   * Deduplicated size of the image repository in bytes. This is only available on
   * GitLab.com for repositories created after `2021-11-04`.
   */
  size?: Maybe<Scalars['Float']>;
  /** Status of the container repository. */
  status?: Maybe<ContainerRepositoryStatus>;
  /** Tags of the container repository. */
  tags?: Maybe<ContainerRepositoryTagConnection>;
  /** Number of tags associated with this image. */
  tagsCount: Scalars['Int'];
  /** Timestamp when the container repository was updated. */
  updatedAt: Scalars['Time'];
};


/** Details of a container repository */
export type ContainerRepositoryDetailsTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<ContainerRepositoryTagSort>;
};

/** An edge in a connection. */
export type ContainerRepositoryEdge = {
  __typename?: 'ContainerRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepository>;
};

/** Represents the Geo replication and verification state of an Container Repository. */
export type ContainerRepositoryRegistry = {
  __typename?: 'ContainerRepositoryRegistry';
  /** ID of the ContainerRepository. */
  containerRepositoryId: Scalars['ID'];
  /** Timestamp when the ContainerRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the ContainerRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the ContainerRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the ContainerRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the ContainerRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the ContainerRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the ContainerRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the ContainerRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the ContainerRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for ContainerRepositoryRegistry. */
export type ContainerRepositoryRegistryConnection = {
  __typename?: 'ContainerRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerRepositoryRegistryEdge = {
  __typename?: 'ContainerRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepositoryRegistry>;
};

/** Values for sorting container repositories */
export type ContainerRepositorySort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Status of a container repository */
export type ContainerRepositoryStatus =
  /** Delete Failed status. */
  | 'DELETE_FAILED'
  /** Delete Ongoing status. */
  | 'DELETE_ONGOING'
  /** Delete Scheduled status. */
  | 'DELETE_SCHEDULED';

/** A tag from a container repository */
export type ContainerRepositoryTag = {
  __typename?: 'ContainerRepositoryTag';
  /** Can the current user delete this tag. */
  canDelete: Scalars['Boolean'];
  /** Timestamp when the tag was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Digest of the tag. */
  digest?: Maybe<Scalars['String']>;
  /** URL of the tag. */
  location: Scalars['String'];
  /** Name of the tag. */
  name: Scalars['String'];
  /** Path of the tag. */
  path: Scalars['String'];
  /** Revision of the tag. */
  revision?: Maybe<Scalars['String']>;
  /** Short revision of the tag. */
  shortRevision?: Maybe<Scalars['String']>;
  /** Size of the tag. */
  totalSize?: Maybe<Scalars['BigInt']>;
};

/** The connection type for ContainerRepositoryTag. */
export type ContainerRepositoryTagConnection = {
  __typename?: 'ContainerRepositoryTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContainerRepositoryTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContainerRepositoryTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContainerRepositoryTagEdge = {
  __typename?: 'ContainerRepositoryTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContainerRepositoryTag>;
};

/** Values for sorting tags */
export type ContainerRepositoryTagSort =
  /** Ordered by name in ascending order. */
  | 'NAME_ASC'
  /** Ordered by name in descending order. */
  | 'NAME_DESC';

/** Represents the contributions of a user. */
export type ContributionAnalyticsContribution = {
  __typename?: 'ContributionAnalyticsContribution';
  /** Number of issues closed by the user. */
  issuesClosed?: Maybe<Scalars['Int']>;
  /** Number of issues created by the user. */
  issuesCreated?: Maybe<Scalars['Int']>;
  /** Number of merge requests approved by the user. */
  mergeRequestsApproved?: Maybe<Scalars['Int']>;
  /** Number of merge requests closed by the user. */
  mergeRequestsClosed?: Maybe<Scalars['Int']>;
  /** Number of merge requests created by the user. */
  mergeRequestsCreated?: Maybe<Scalars['Int']>;
  /** Number of merge requests merged by the user. */
  mergeRequestsMerged?: Maybe<Scalars['Int']>;
  /** Number of repository pushes the user made. */
  repoPushed?: Maybe<Scalars['Int']>;
  /** Total number of events contributed by the user. */
  totalEvents?: Maybe<Scalars['Int']>;
  /** Contributor User object. */
  user?: Maybe<UserCore>;
};

/** The connection type for ContributionAnalyticsContribution. */
export type ContributionAnalyticsContributionConnection = {
  __typename?: 'ContributionAnalyticsContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContributionAnalyticsContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContributionAnalyticsContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ContributionAnalyticsContributionEdge = {
  __typename?: 'ContributionAnalyticsContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ContributionAnalyticsContribution>;
};

/** Autogenerated input type of CorpusCreate */
export type CorpusCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the corpus belongs to. */
  fullPath: Scalars['ID'];
  /** ID of the corpus package. */
  packageId: Scalars['PackagesPackageID'];
};

/** Autogenerated return type of CorpusCreate */
export type CorpusCreatePayload = {
  __typename?: 'CorpusCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Corpus for a coverage fuzzing job. */
export type CoverageFuzzingCorpus = {
  __typename?: 'CoverageFuzzingCorpus';
  /** ID of the corpus. */
  id: Scalars['AppSecFuzzingCoverageCorpusID'];
  /** Package of the corpus. */
  package: PackageDetailsType;
};

/** The connection type for CoverageFuzzingCorpus. */
export type CoverageFuzzingCorpusConnection = {
  __typename?: 'CoverageFuzzingCorpusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CoverageFuzzingCorpusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CoverageFuzzingCorpus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CoverageFuzzingCorpusEdge = {
  __typename?: 'CoverageFuzzingCorpusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CoverageFuzzingCorpus>;
};

/** Autogenerated input type of CreateAlertIssue */
export type CreateAlertIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of CreateAlertIssue */
export type CreateAlertIssuePayload = {
  __typename?: 'CreateAlertIssuePayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of CreateAnnotation */
export type CreateAnnotationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the cluster to add an annotation to. */
  clusterId?: InputMaybe<Scalars['ClustersClusterID']>;
  /** Path to a file defining the dashboard on which the annotation should be added. */
  dashboardPath: Scalars['String'];
  /** Description of the annotation. */
  description: Scalars['String'];
  /** Timestamp indicating ending moment to which the annotation relates. */
  endingAt?: InputMaybe<Scalars['Time']>;
  /** Global ID of the environment to add an annotation to. */
  environmentId?: InputMaybe<Scalars['EnvironmentID']>;
  /** Timestamp indicating starting moment to which the annotation relates. */
  startingAt: Scalars['Time'];
};

/** Autogenerated return type of CreateAnnotation */
export type CreateAnnotationPayload = {
  __typename?: 'CreateAnnotationPayload';
  /** Created annotation. */
  annotation?: Maybe<MetricsDashboardAnnotation>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateBoard */
export type CreateBoardInput = {
  /** ID of user to be assigned to the board. */
  assigneeId?: InputMaybe<Scalars['UserID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** ID of iteration cadence to be assigned to the board. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** ID of iteration to be assigned to the board. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** ID of milestone to be assigned to the board. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Weight value to be assigned to the board. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of CreateBoard */
export type CreateBoardPayload = {
  __typename?: 'CreateBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateBranch */
export type CreateBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the branch. */
  name: Scalars['String'];
  /** Project full path the branch is associated with. */
  projectPath: Scalars['ID'];
  /** Branch name or commit SHA to create branch from. */
  ref: Scalars['String'];
};

/** Autogenerated return type of CreateBranch */
export type CreateBranchPayload = {
  __typename?: 'CreateBranchPayload';
  /** Branch after mutation. */
  branch?: Maybe<Branch>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateClusterAgent */
export type CreateClusterAgentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the cluster agent. */
  name: Scalars['String'];
  /** Full path of the associated project for the cluster agent. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of CreateClusterAgent */
export type CreateClusterAgentPayload = {
  __typename?: 'CreateClusterAgentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Cluster agent created after mutation. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateComplianceFramework */
export type CreateComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the namespace to add the compliance framework to. */
  namespacePath: Scalars['ID'];
  /** Parameters to update the compliance framework with. */
  params: ComplianceFrameworkInput;
};

/** Autogenerated return type of CreateComplianceFramework */
export type CreateComplianceFrameworkPayload = {
  __typename?: 'CreateComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created compliance framework. */
  framework?: Maybe<ComplianceFramework>;
};

/** Autogenerated input type of CreateCustomEmoji */
export type CreateCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Namespace full path the emoji is associated with. */
  groupPath: Scalars['ID'];
  /** Name of the emoji. */
  name: Scalars['String'];
  /** Location of the emoji file. */
  url: Scalars['String'];
};

/** Autogenerated return type of CreateCustomEmoji */
export type CreateCustomEmojiPayload = {
  __typename?: 'CreateCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** New custom emoji. */
  customEmoji?: Maybe<CustomEmoji>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateDiffNote */
export type CreateDiffNoteInput = {
  /** Content of the note. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Confidentiality flag of a note. Default is false. Deprecated in 15.3: This was renamed.
   * @deprecated This was renamed. Please use `internal`. Deprecated in 15.3.
   */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID'];
  /** Position of this note on a diff. */
  position: DiffPositionInput;
};

/** Autogenerated return type of CreateDiffNote */
export type CreateDiffNotePayload = {
  __typename?: 'CreateDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of CreateEpic */
export type CreateEpicInput = {
  /** IDs of labels to be added to the epic. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Array of labels to be added to the epic. */
  addLabels?: InputMaybe<Array<Scalars['String']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Color of the epic. Available only when feature flag `epic_color_highlight` is
   * enabled. This flag is disabled by default, because the feature is experimental
   * and is subject to change without notice.
   */
  color?: InputMaybe<Scalars['Color']>;
  /** Indicates if the epic is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Description of the epic. */
  description?: InputMaybe<Scalars['String']>;
  /** End date of the epic. */
  dueDateFixed?: InputMaybe<Scalars['String']>;
  /** Indicates end date should be sourced from due_date_fixed field not the issue milestones. */
  dueDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** Group the epic to mutate is in. */
  groupPath: Scalars['ID'];
  /** IDs of labels to be removed from the epic. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Start date of the epic. */
  startDateFixed?: InputMaybe<Scalars['String']>;
  /** Indicates start date should be sourced from start_date_fixed field not the issue milestones. */
  startDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** Title of the epic. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateEpic */
export type CreateEpicPayload = {
  __typename?: 'CreateEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created epic. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of CreateImageDiffNote */
export type CreateImageDiffNoteInput = {
  /** Content of the note. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Confidentiality flag of a note. Default is false. Deprecated in 15.3: This was renamed.
   * @deprecated This was renamed. Please use `internal`. Deprecated in 15.3.
   */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID'];
  /** Position of this note on a diff. */
  position: DiffImagePositionInput;
};

/** Autogenerated return type of CreateImageDiffNote */
export type CreateImageDiffNotePayload = {
  __typename?: 'CreateImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of CreateIssue */
export type CreateIssueInput = {
  /** Array of user IDs to assign to the issue. */
  assigneeIds?: InputMaybe<Array<Scalars['UserID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates the issue is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Timestamp when the issue was created. Available only for admins and project owners. */
  createdAt?: InputMaybe<Scalars['Time']>;
  /** Description of the issue. */
  description?: InputMaybe<Scalars['String']>;
  /** ID of a discussion to resolve. Also pass `merge_request_to_resolve_discussions_of`. */
  discussionToResolve?: InputMaybe<Scalars['String']>;
  /** Due date of the issue. */
  dueDate?: InputMaybe<Scalars['ISO8601Date']>;
  /** ID of an epic to associate the issue with. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Desired health status. */
  healthStatus?: InputMaybe<HealthStatus>;
  /** IID (internal ID) of a project issue. Only admins and project owners can modify. */
  iid?: InputMaybe<Scalars['Int']>;
  /** Global iteration cadence ID. Required when `iterationWildcardId` is provided. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Global iteration ID. Mutually exlusive argument with `iterationWildcardId`. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /**
   * Iteration wildcard ID. Supported values are: `CURRENT`. Mutually exclusive
   * argument with `iterationId`. iterationCadenceId also required when this
   * argument is provided.
   */
  iterationWildcardId?: InputMaybe<IssueCreationIterationWildcardId>;
  /** IDs of labels to be added to the issue. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** Indicates discussion is locked on the issue. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** IID of a merge request for which to resolve discussions. */
  mergeRequestToResolveDiscussionsOf?: InputMaybe<Scalars['MergeRequestID']>;
  /** ID of the milestone to assign to the issue. On update milestone will be removed if set to null. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** Global ID of issue that should be placed after the current issue. */
  moveAfterId?: InputMaybe<Scalars['IssueID']>;
  /** Global ID of issue that should be placed before the current issue. */
  moveBeforeId?: InputMaybe<Scalars['IssueID']>;
  /** Project full path the issue is associated with. */
  projectPath: Scalars['ID'];
  /** Title of the issue. */
  title: Scalars['String'];
  /** Type of the issue. */
  type?: InputMaybe<IssueType>;
  /** Weight of the issue. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of CreateIssue */
export type CreateIssuePayload = {
  __typename?: 'CreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of CreateIteration */
export type CreateIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Global ID of the iteration cadence to be assigned to the new iteration. */
  iterationsCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateIteration */
export type CreateIterationPayload = {
  __typename?: 'CreateIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  /** Content of the note. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Confidentiality flag of a note. Default is false. Deprecated in 15.3: This was renamed.
   * @deprecated This was renamed. Please use `internal`. Deprecated in 15.3.
   */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the discussion the note is in reply to. */
  discussionId?: InputMaybe<Scalars['DiscussionID']>;
  /** Internal flag for a note. Default is false. */
  internal?: InputMaybe<Scalars['Boolean']>;
  /** SHA of the head commit which is used to ensure that the merge request has not been updated since the request was sent. */
  mergeRequestDiffHeadSha?: InputMaybe<Scalars['String']>;
  /** Global ID of the resource to add a note to. */
  noteableId: Scalars['NoteableID'];
};

/** Autogenerated return type of CreateNote */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of CreateRequirement */
export type CreateRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the requirement. */
  description?: InputMaybe<Scalars['String']>;
  /** Full project path the requirement is associated with. */
  projectPath: Scalars['ID'];
  /** Title of the requirement. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateRequirement */
export type CreateRequirementPayload = {
  __typename?: 'CreateRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requirement after mutation. */
  requirement?: Maybe<Requirement>;
};

/** Autogenerated input type of CreateSnippet */
export type CreateSnippetInput = {
  /** Actions to perform over the snippet repository and blobs. */
  blobActions?: InputMaybe<Array<SnippetBlobActionInputType>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the snippet. */
  description?: InputMaybe<Scalars['String']>;
  /** Full path of the project the snippet is associated with. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Title of the snippet. */
  title: Scalars['String'];
  /** Paths to files uploaded in the snippet description. */
  uploadedFiles?: InputMaybe<Array<Scalars['String']>>;
  /** Visibility level of the snippet. */
  visibilityLevel: VisibilityLevelsEnum;
};

/** Autogenerated return type of CreateSnippet */
export type CreateSnippetPayload = {
  __typename?: 'CreateSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Autogenerated input type of CreateTestCase */
export type CreateTestCaseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Test case description. */
  description?: InputMaybe<Scalars['String']>;
  /** IDs of labels to be added to the test case. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Project full path to create the test case in. */
  projectPath: Scalars['ID'];
  /** Test case title. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateTestCase */
export type CreateTestCasePayload = {
  __typename?: 'CreateTestCasePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Test case created. */
  testCase?: Maybe<Issue>;
};

/** Represents the current license */
export type CurrentLicense = {
  __typename?: 'CurrentLicense';
  /** Date when the license was activated. */
  activatedAt?: Maybe<Scalars['Date']>;
  /** Number of billable users on the system. */
  billableUsersCount?: Maybe<Scalars['Int']>;
  /** Date, including grace period, when licensed features will be blocked. */
  blockChangesAt?: Maybe<Scalars['Date']>;
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']>;
  /** Date when the license was added. */
  createdAt?: Maybe<Scalars['Date']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']>;
  /** ID of the license extracted from the license data. */
  id: Scalars['ID'];
  /** Date when the license was last synced. */
  lastSync?: Maybe<Scalars['Time']>;
  /** Highest number of billable users on the system during the term of the current license. */
  maximumUserCount?: Maybe<Scalars['Int']>;
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']>;
  /** Name of the subscription plan. */
  plan: Scalars['String'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']>;
  /** Type of the license. */
  type: Scalars['String'];
  /** Number of paid users in the license. */
  usersInLicenseCount?: Maybe<Scalars['Int']>;
  /** Number of users over the paid users in the license. */
  usersOverLicenseCount?: Maybe<Scalars['Int']>;
};

export type CurrentUserTodos = {
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
};


export type CurrentUserTodosCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};

/** A custom emoji uploaded by user */
export type CustomEmoji = {
  __typename?: 'CustomEmoji';
  /** Whether the emoji is an external link. */
  external: Scalars['Boolean'];
  /** ID of the emoji. */
  id: Scalars['CustomEmojiID'];
  /** Name of the emoji. */
  name: Scalars['String'];
  /** Link to file of the emoji. */
  url: Scalars['String'];
};

/** The connection type for CustomEmoji. */
export type CustomEmojiConnection = {
  __typename?: 'CustomEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomEmojiEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomEmoji>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CustomEmojiEdge = {
  __typename?: 'CustomEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomEmoji>;
};

export type CustomerRelationsContact = {
  __typename?: 'CustomerRelationsContact';
  /** State of the contact. */
  active: Scalars['Boolean'];
  /** Timestamp the contact was created. */
  createdAt: Scalars['Time'];
  /** Description of or notes for the contact. */
  description?: Maybe<Scalars['String']>;
  /** Email address of the contact. */
  email?: Maybe<Scalars['String']>;
  /** First name of the contact. */
  firstName: Scalars['String'];
  /** Internal ID of the contact. */
  id: Scalars['ID'];
  /** Last name of the contact. */
  lastName: Scalars['String'];
  /** Organization of the contact. */
  organization?: Maybe<CustomerRelationsOrganization>;
  /** Phone number of the contact. */
  phone?: Maybe<Scalars['String']>;
  /** Timestamp the contact was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for CustomerRelationsContact. */
export type CustomerRelationsContactConnection = {
  __typename?: 'CustomerRelationsContactConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerRelationsContactEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerRelationsContact>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerRelationsContactCreate */
export type CustomerRelationsContactCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of or notes for the contact. */
  description?: InputMaybe<Scalars['String']>;
  /** Email address of the contact. */
  email?: InputMaybe<Scalars['String']>;
  /** First name of the contact. */
  firstName: Scalars['String'];
  /** Group for the contact. */
  groupId: Scalars['GroupID'];
  /** Last name of the contact. */
  lastName: Scalars['String'];
  /** Organization for the contact. */
  organizationId?: InputMaybe<Scalars['CustomerRelationsOrganizationID']>;
  /** Phone number of the contact. */
  phone?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CustomerRelationsContactCreate */
export type CustomerRelationsContactCreatePayload = {
  __typename?: 'CustomerRelationsContactCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Contact after the mutation. */
  contact?: Maybe<CustomerRelationsContact>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type CustomerRelationsContactEdge = {
  __typename?: 'CustomerRelationsContactEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerRelationsContact>;
};

export type CustomerRelationsContactState =
  /** Active contacts. */
  | 'active'
  /** All available contacts. */
  | 'all'
  /** Inactive contacts. */
  | 'inactive';

/** Autogenerated input type of CustomerRelationsContactUpdate */
export type CustomerRelationsContactUpdateInput = {
  /** State of the contact. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of or notes for the contact. */
  description?: InputMaybe<Scalars['String']>;
  /** Email address of the contact. */
  email?: InputMaybe<Scalars['String']>;
  /** First name of the contact. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Global ID of the contact. */
  id: Scalars['CustomerRelationsContactID'];
  /** Last name of the contact. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Organization of the contact. */
  organizationId?: InputMaybe<Scalars['CustomerRelationsOrganizationID']>;
  /** Phone number of the contact. */
  phone?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CustomerRelationsContactUpdate */
export type CustomerRelationsContactUpdatePayload = {
  __typename?: 'CustomerRelationsContactUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Contact after the mutation. */
  contact?: Maybe<CustomerRelationsContact>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type CustomerRelationsOrganization = {
  __typename?: 'CustomerRelationsOrganization';
  /** State of the organization. */
  active: Scalars['Boolean'];
  /** Timestamp the organization was created. */
  createdAt: Scalars['Time'];
  /** Standard billing rate for the organization. */
  defaultRate?: Maybe<Scalars['Float']>;
  /** Description of or notes for the organization. */
  description?: Maybe<Scalars['String']>;
  /** Internal ID of the organization. */
  id: Scalars['ID'];
  /** Name of the organization. */
  name: Scalars['String'];
  /** Timestamp the organization was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for CustomerRelationsOrganization. */
export type CustomerRelationsOrganizationConnection = {
  __typename?: 'CustomerRelationsOrganizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomerRelationsOrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomerRelationsOrganization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of CustomerRelationsOrganizationCreate */
export type CustomerRelationsOrganizationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Standard billing rate for the organization. */
  defaultRate?: InputMaybe<Scalars['Float']>;
  /** Description of or notes for the organization. */
  description?: InputMaybe<Scalars['String']>;
  /** Group for the organization. */
  groupId: Scalars['GroupID'];
  /** Name of the organization. */
  name: Scalars['String'];
};

/** Autogenerated return type of CustomerRelationsOrganizationCreate */
export type CustomerRelationsOrganizationCreatePayload = {
  __typename?: 'CustomerRelationsOrganizationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Organization after the mutation. */
  organization?: Maybe<CustomerRelationsOrganization>;
};

/** An edge in a connection. */
export type CustomerRelationsOrganizationEdge = {
  __typename?: 'CustomerRelationsOrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomerRelationsOrganization>;
};

export type CustomerRelationsOrganizationState =
  /** Active organizations. */
  | 'active'
  /** All available organizations. */
  | 'all'
  /** Inactive organizations. */
  | 'inactive';

/** Autogenerated input type of CustomerRelationsOrganizationUpdate */
export type CustomerRelationsOrganizationUpdateInput = {
  /** State of the organization. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Standard billing rate for the organization. */
  defaultRate?: InputMaybe<Scalars['Float']>;
  /** Description of or notes for the organization. */
  description?: InputMaybe<Scalars['String']>;
  /** Global ID of the organization. */
  id: Scalars['CustomerRelationsOrganizationID'];
  /** Name of the organization. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CustomerRelationsOrganizationUpdate */
export type CustomerRelationsOrganizationUpdatePayload = {
  __typename?: 'CustomerRelationsOrganizationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Organization after the mutation. */
  organization: CustomerRelationsOrganization;
};

/** Autogenerated input type of DastOnDemandScanCreate */
export type DastOnDemandScanCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the scanner profile to be used for the scan. */
  dastScannerProfileId?: InputMaybe<Scalars['DastScannerProfileID']>;
  /** ID of the site profile to be used for the scan. */
  dastSiteProfileId: Scalars['DastSiteProfileID'];
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID'];
};

/** Autogenerated return type of DastOnDemandScanCreate */
export type DastOnDemandScanCreatePayload = {
  __typename?: 'DastOnDemandScanCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** URL of the pipeline that was created. */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Represents a DAST Pre Scan Verification */
export type DastPreScanVerification = {
  __typename?: 'DastPreScanVerification';
  /** Pre Scan Verifications Steps. */
  preScanVerificationSteps?: Maybe<Array<DastPreScanVerificationStep>>;
  /** Status of the pre scan verification. */
  status?: Maybe<DastPreScanVerificationStatus>;
  /** Whether or not the configuration has changed after the last pre scan run. */
  valid: Scalars['Boolean'];
};

/** Check type of the pre scan verification step. */
export type DastPreScanVerificationCheckType =
  /** Authentication check */
  | 'AUTHENTICATION'
  /** Connection check */
  | 'CONNECTION'
  /** Crawling check */
  | 'CRAWLING';

/** Status of DAST pre scan verification. */
export type DastPreScanVerificationStatus =
  /** Pre Scan Verification complete without errors. */
  | 'COMPLETE'
  /** Pre Scan Verification finished with one or more errors. */
  | 'COMPLETE_WITH_ERRORS'
  /** Pre Scan Validation unable to finish. */
  | 'FAILED'
  /** Pre Scan Verification in execution. */
  | 'RUNNING';

/** Represents a DAST Pre Scan Verification Step */
export type DastPreScanVerificationStep = {
  __typename?: 'DastPreScanVerificationStep';
  /** Type of the pre scan verification check. */
  checkType?: Maybe<DastPreScanVerificationCheckType>;
  /** Errors that occurred in the pre scan verification step. */
  errors?: Maybe<Array<Scalars['String']>>;
  /**
   * Name of the pre scan verification step. Deprecated in 15.10: This was renamed.
   * @deprecated This was renamed. Please use `DastPreScanVerificationStep.checkType`. Deprecated in 15.10.
   */
  name?: Maybe<Scalars['String']>;
  /** Whether or not the pre scan verification step has errors. */
  success: Scalars['Boolean'];
};

/** Represents a DAST Profile */
export type DastProfile = {
  __typename?: 'DastProfile';
  /** Associated branch. */
  branch?: Maybe<DastProfileBranch>;
  /**
   * DAST Pre Scan Verification associated with the site profile. Will always
   * return `null` if `dast_on_demand_scans_scheduler` feature flag is disabled.
   */
  dastPreScanVerification?: Maybe<DastPreScanVerification>;
  /** Associated profile schedule. */
  dastProfileSchedule?: Maybe<DastProfileSchedule>;
  /** Associated scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Associated site profile. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Description of the scan. */
  description?: Maybe<Scalars['String']>;
  /** Relative web path to the edit page of a profile. */
  editPath?: Maybe<Scalars['String']>;
  /** ID of the profile. */
  id: Scalars['DastProfileID'];
  /** Name of the profile. */
  name?: Maybe<Scalars['String']>;
  /** Runner tags associated with the profile. */
  tagList?: Maybe<Array<Scalars['String']>>;
};

/** Represents a DAST Profile Branch */
export type DastProfileBranch = {
  __typename?: 'DastProfileBranch';
  /** Indicates whether or not the branch exists. */
  exists?: Maybe<Scalars['Boolean']>;
  /** Name of the branch. */
  name?: Maybe<Scalars['String']>;
};

/** Represents DAST Profile Cadence. */
export type DastProfileCadence = {
  __typename?: 'DastProfileCadence';
  /** Duration of the DAST profile cadence. */
  duration?: Maybe<Scalars['Int']>;
  /** Unit for the duration of DAST profile cadence. */
  unit?: Maybe<DastProfileCadenceUnit>;
};

/** Represents DAST Profile Cadence. */
export type DastProfileCadenceInput = {
  /** Duration of the DAST Profile Cadence. */
  duration?: InputMaybe<Scalars['Int']>;
  /** Unit for the duration of DAST Profile Cadence. */
  unit?: InputMaybe<DastProfileCadenceUnit>;
};

/** Unit for the duration of Dast Profile Cadence. */
export type DastProfileCadenceUnit =
  /** DAST Profile Cadence duration in days. */
  | 'DAY'
  /** DAST Profile Cadence duration in months. */
  | 'MONTH'
  /** DAST Profile Cadence duration in weeks. */
  | 'WEEK'
  /** DAST Profile Cadence duration in years. */
  | 'YEAR';

/** The connection type for DastProfile. */
export type DastProfileConnection = {
  __typename?: 'DastProfileConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastProfileCreate */
export type DastProfileCreateInput = {
  /** Associated branch. */
  branchName?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Represents a DAST Profile Schedule. */
  dastProfileSchedule?: InputMaybe<DastProfileScheduleInput>;
  /** ID of the scanner profile to be associated. */
  dastScannerProfileId: Scalars['DastScannerProfileID'];
  /** ID of the site profile to be associated. */
  dastSiteProfileId: Scalars['DastSiteProfileID'];
  /** Description of the profile. Defaults to an empty string. */
  description?: InputMaybe<Scalars['String']>;
  /** Project the profile belongs to. */
  fullPath: Scalars['ID'];
  /** Name of the profile. */
  name: Scalars['String'];
  /** Run scan using profile after creation. Defaults to false. */
  runAfterCreate?: InputMaybe<Scalars['Boolean']>;
  /** Indicates the runner tags associated with the profile. */
  tagList?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of DastProfileCreate */
export type DastProfileCreatePayload = {
  __typename?: 'DastProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created profile. */
  dastProfile?: Maybe<DastProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** URL of the pipeline that was created. Requires `runAfterCreate` to be set to `true`. */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DastProfileDelete */
export type DastProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the profile to be deleted. */
  id: Scalars['DastProfileID'];
};

/** Autogenerated return type of DastProfileDelete */
export type DastProfileDeletePayload = {
  __typename?: 'DastProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type DastProfileEdge = {
  __typename?: 'DastProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastProfile>;
};

/** Autogenerated input type of DastProfileRun */
export type DastProfileRunInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Full path for the project the scanner profile belongs to. Deprecated in 14.5: Full path not required to qualify Global ID.
   * @deprecated Full path not required to qualify Global ID. Deprecated in 14.5.
   */
  fullPath?: InputMaybe<Scalars['ID']>;
  /** ID of the profile to be used for the scan. */
  id: Scalars['DastProfileID'];
};

/** Autogenerated return type of DastProfileRun */
export type DastProfileRunPayload = {
  __typename?: 'DastProfileRunPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** URL of the pipeline that was created. */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Represents a DAST profile schedule. */
export type DastProfileSchedule = {
  __typename?: 'DastProfileSchedule';
  /** Status of the DAST profile schedule. */
  active?: Maybe<Scalars['Boolean']>;
  /** Cadence of the DAST profile schedule. */
  cadence?: Maybe<DastProfileCadence>;
  /** ID of the DAST profile schedule. */
  id: Scalars['DastProfileScheduleID'];
  /** Next run time of the DAST profile schedule in the given timezone. */
  nextRunAt?: Maybe<Scalars['Time']>;
  /** Status of the current owner of the DAST profile schedule. */
  ownerValid?: Maybe<Scalars['Boolean']>;
  /** Start time of the DAST profile schedule in the given timezone. */
  startsAt?: Maybe<Scalars['Time']>;
  /** Time zone of the start time of the DAST profile schedule. */
  timezone?: Maybe<Scalars['String']>;
};

/** Input type for DAST Profile Schedules */
export type DastProfileScheduleInput = {
  /** Status of a Dast Profile Schedule. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Cadence of a Dast Profile Schedule. */
  cadence?: InputMaybe<DastProfileCadenceInput>;
  /** Start time of a Dast Profile Schedule. */
  startsAt?: InputMaybe<Scalars['Time']>;
  /** Time Zone for the Start time of a Dast Profile Schedule. */
  timezone?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of DastProfileUpdate */
export type DastProfileUpdateInput = {
  /** Associated branch. */
  branchName?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Represents a DAST profile schedule. */
  dastProfileSchedule?: InputMaybe<DastProfileScheduleInput>;
  /** ID of the scanner profile to be associated. */
  dastScannerProfileId?: InputMaybe<Scalars['DastScannerProfileID']>;
  /** ID of the site profile to be associated. */
  dastSiteProfileId?: InputMaybe<Scalars['DastSiteProfileID']>;
  /** Description of the profile. Defaults to an empty string. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Project the profile belongs to. Deprecated in 14.5: Full path not required to qualify Global ID.
   * @deprecated Full path not required to qualify Global ID. Deprecated in 14.5.
   */
  fullPath?: InputMaybe<Scalars['ID']>;
  /** ID of the profile to be deleted. */
  id: Scalars['DastProfileID'];
  /** Name of the profile. */
  name?: InputMaybe<Scalars['String']>;
  /** Run scan using profile after update. Defaults to false. */
  runAfterUpdate?: InputMaybe<Scalars['Boolean']>;
  /** Indicates the runner tags associated with the profile. */
  tagList?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of DastProfileUpdate */
export type DastProfileUpdatePayload = {
  __typename?: 'DastProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated profile. */
  dastProfile?: Maybe<DastProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * The URL of the pipeline that was created. Requires the input argument
   * `runAfterUpdate` to be set to `true` when calling the mutation, otherwise no
   * pipeline will be created.
   */
  pipelineUrl?: Maybe<Scalars['String']>;
};

/** Scan method to be used by the scanner. */
export type DastScanMethodType =
  /** GraphQL scan method. */
  | 'GRAPHQL'
  /** HAR scan method. */
  | 'HAR'
  /** OpenAPI scan method. */
  | 'OPENAPI'
  /** Postman scan method. */
  | 'POSTMAN_COLLECTION'
  /** Website scan method. */
  | 'WEBSITE';

export type DastScanTypeEnum =
  /** Active DAST scan. This scan will make active attacks against the target site. */
  | 'ACTIVE'
  /** Passive DAST scan. This scan will not make active attacks against the target site. */
  | 'PASSIVE';

/** Represents a DAST scanner profile */
export type DastScannerProfile = {
  __typename?: 'DastScannerProfile';
  /** Relative web path to the edit page of a scanner profile. */
  editPath?: Maybe<Scalars['String']>;
  /** ID of the DAST scanner profile. */
  id: Scalars['DastScannerProfileID'];
  /** Name of the DAST scanner profile. */
  profileName?: Maybe<Scalars['String']>;
  /** List of security policy names that are referencing given project. */
  referencedInSecurityPolicies?: Maybe<Array<Scalars['String']>>;
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: Maybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages: Scalars['Boolean'];
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout?: Maybe<Scalars['Int']>;
  /**
   * Runner tags associated with the scanner profile. Deprecated in 15.8: Moved to DastProfile.
   * @deprecated Moved to DastProfile. Deprecated in 15.8.
   */
  tagList?: Maybe<Array<Scalars['String']>>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout?: Maybe<Scalars['Int']>;
  /**
   * Indicates if the AJAX spider should be used to crawl the target site. True to
   * run the AJAX spider in addition to the traditional spider, and false to run
   * only the traditional spider.
   */
  useAjaxSpider: Scalars['Boolean'];
};

/** The connection type for DastScannerProfile. */
export type DastScannerProfileConnection = {
  __typename?: 'DastScannerProfileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastScannerProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastScannerProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastScannerProfileCreate */
export type DastScannerProfileCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the scanner profile belongs to. */
  fullPath: Scalars['ID'];
  /** Name of the scanner profile. */
  profileName: Scalars['String'];
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: InputMaybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages?: InputMaybe<Scalars['Boolean']>;
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout?: InputMaybe<Scalars['Int']>;
  /**
   * Indicates the runner tags associated with the scanner profile. Deprecated in 15.8: Moved to DastProfile.
   * @deprecated Moved to DastProfile. Deprecated in 15.8.
   */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout?: InputMaybe<Scalars['Int']>;
  /**
   * Indicates if the AJAX spider should be used to crawl the target site. True to
   * run the AJAX spider in addition to the traditional spider, and false to run
   * only the traditional spider.
   */
  useAjaxSpider?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DastScannerProfileCreate */
export type DastScannerProfileCreatePayload = {
  __typename?: 'DastScannerProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the scanner profile. Deprecated in 14.10: use `dastScannerProfile` field.
   * @deprecated use `dastScannerProfile` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastScannerProfileID']>;
};

/** Autogenerated input type of DastScannerProfileDelete */
export type DastScannerProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Full path for the project the scanner profile belongs to. Deprecated in 14.5: Full path not required to qualify Global ID.
   * @deprecated Full path not required to qualify Global ID. Deprecated in 14.5.
   */
  fullPath?: InputMaybe<Scalars['ID']>;
  /** ID of the scanner profile to be deleted. */
  id: Scalars['DastScannerProfileID'];
};

/** Autogenerated return type of DastScannerProfileDelete */
export type DastScannerProfileDeletePayload = {
  __typename?: 'DastScannerProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type DastScannerProfileEdge = {
  __typename?: 'DastScannerProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastScannerProfile>;
};

/** Autogenerated input type of DastScannerProfileUpdate */
export type DastScannerProfileUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Project the scanner profile belongs to. Deprecated in 14.5: Full path not required to qualify Global ID.
   * @deprecated Full path not required to qualify Global ID. Deprecated in 14.5.
   */
  fullPath?: InputMaybe<Scalars['ID']>;
  /** ID of the scanner profile to be updated. */
  id: Scalars['DastScannerProfileID'];
  /** Name of the scanner profile. */
  profileName: Scalars['String'];
  /** Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan. */
  scanType?: InputMaybe<DastScanTypeEnum>;
  /** Indicates if debug messages should be included in DAST console output. True to include the debug messages. */
  showDebugMessages?: InputMaybe<Scalars['Boolean']>;
  /** Maximum number of minutes allowed for the spider to traverse the site. */
  spiderTimeout: Scalars['Int'];
  /**
   * Indicates the runner tags associated with the scanner profile. Deprecated in 15.8: Moved to DastProfile.
   * @deprecated Moved to DastProfile. Deprecated in 15.8.
   */
  tagList?: InputMaybe<Array<Scalars['String']>>;
  /** Maximum number of seconds allowed for the site under test to respond to a request. */
  targetTimeout: Scalars['Int'];
  /**
   * Indicates if the AJAX spider should be used to crawl the target site. True to
   * run the AJAX spider in addition to the traditional spider, and false to run
   * only the traditional spider.
   */
  useAjaxSpider?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of DastScannerProfileUpdate */
export type DastScannerProfileUpdatePayload = {
  __typename?: 'DastScannerProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated scanner profile. */
  dastScannerProfile?: Maybe<DastScannerProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the scanner profile. Deprecated in 14.10: use `dastScannerProfile` field.
   * @deprecated use `dastScannerProfile` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastScannerProfileID']>;
};

/** Represents a DAST Site Profile */
export type DastSiteProfile = {
  __typename?: 'DastSiteProfile';
  /** Target authentication details. */
  auth?: Maybe<DastSiteProfileAuth>;
  /** Relative web path to the edit page of a site profile. */
  editPath?: Maybe<Scalars['String']>;
  /** URLs to skip during an authenticated scan. */
  excludedUrls?: Maybe<Array<Scalars['String']>>;
  /** ID of the site profile. */
  id: Scalars['DastSiteProfileID'];
  /** Normalized URL of the target to be scanned. */
  normalizedTargetUrl?: Maybe<Scalars['String']>;
  /** Name of the site profile. */
  profileName?: Maybe<Scalars['String']>;
  /** List of security policy names that are referencing given project. */
  referencedInSecurityPolicies?: Maybe<Array<Scalars['String']>>;
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: Maybe<Scalars['String']>;
  /** Scan File Path used as input for the scanner. */
  scanFilePath?: Maybe<Scalars['String']>;
  /** Scan method used by the scanner. */
  scanMethod?: Maybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: Maybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: Maybe<Scalars['String']>;
  /** Permissions for the current user on the resource */
  userPermissions: DastSiteProfilePermissions;
  /** Site profile validation start time. */
  validationStartedAt?: Maybe<Scalars['Time']>;
  /** Current validation status of the site profile. */
  validationStatus?: Maybe<DastSiteProfileValidationStatusEnum>;
};

/** Input type for DastSiteProfile authentication */
export type DastSiteProfileAuth = {
  __typename?: 'DastSiteProfileAuth';
  /** Indicates whether authentication is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Redacted password to authenticate with on the target website. */
  password?: Maybe<Scalars['String']>;
  /** Name of password field at the sign-in HTML form. */
  passwordField?: Maybe<Scalars['String']>;
  /** Name or ID of sign-in submit button at the sign-in HTML form. */
  submitField?: Maybe<Scalars['String']>;
  /** The URL of the page containing the sign-in HTML form on the target website. */
  url?: Maybe<Scalars['String']>;
  /** Username to authenticate with on the target website. */
  username?: Maybe<Scalars['String']>;
  /** Name of username field at the sign-in HTML form. */
  usernameField?: Maybe<Scalars['String']>;
};

/** Input type for DastSiteProfile authentication */
export type DastSiteProfileAuthInput = {
  /** Indicates whether authentication is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Password to authenticate with on the target. */
  password?: InputMaybe<Scalars['String']>;
  /** Name of password field at the sign-in HTML form. */
  passwordField?: InputMaybe<Scalars['String']>;
  /** Name or ID of sign-in submit button at the sign-in HTML form. */
  submitField?: InputMaybe<Scalars['String']>;
  /** The URL of the page containing the sign-in HTML form on the target website. */
  url?: InputMaybe<Scalars['String']>;
  /** Username to authenticate with on the target. */
  username?: InputMaybe<Scalars['String']>;
  /** Name of username field at the sign-in HTML form. */
  usernameField?: InputMaybe<Scalars['String']>;
};

/** The connection type for DastSiteProfile. */
export type DastSiteProfileConnection = {
  __typename?: 'DastSiteProfileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastSiteProfileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastSiteProfile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastSiteProfileCreate */
export type DastSiteProfileCreateInput = {
  /** Parameters for authentication. */
  auth?: InputMaybe<DastSiteProfileAuthInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** URLs to skip during an authenticated scan. Defaults to `[]`. */
  excludedUrls?: InputMaybe<Array<Scalars['String']>>;
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID'];
  /** Name of the site profile. */
  profileName: Scalars['String'];
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: InputMaybe<Scalars['String']>;
  /** File Path or URL used as input for the scan method. */
  scanFilePath?: InputMaybe<Scalars['String']>;
  /** Scan method by the scanner. */
  scanMethod?: InputMaybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: InputMaybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DastSiteProfileCreate */
export type DastSiteProfileCreatePayload = {
  __typename?: 'DastSiteProfileCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Site Profile object. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the site profile. Deprecated in 14.10: use `dastSiteProfile.id` field.
   * @deprecated use `dastSiteProfile.id` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastSiteProfileID']>;
};

/** Autogenerated input type of DastSiteProfileDelete */
export type DastSiteProfileDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Project the site profile belongs to. Deprecated in 14.5: Full path not required to qualify Global ID.
   * @deprecated Full path not required to qualify Global ID. Deprecated in 14.5.
   */
  fullPath?: InputMaybe<Scalars['ID']>;
  /** ID of the site profile to be deleted. */
  id: Scalars['DastSiteProfileID'];
};

/** Autogenerated return type of DastSiteProfileDelete */
export type DastSiteProfileDeletePayload = {
  __typename?: 'DastSiteProfileDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type DastSiteProfileEdge = {
  __typename?: 'DastSiteProfileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastSiteProfile>;
};

/** Check permissions for the current user on site profile */
export type DastSiteProfilePermissions = {
  __typename?: 'DastSiteProfilePermissions';
  /** Indicates the user can perform `create_on_demand_dast_scan` on this resource */
  createOnDemandDastScan: Scalars['Boolean'];
};

/** Autogenerated input type of DastSiteProfileUpdate */
export type DastSiteProfileUpdateInput = {
  /** Parameters for authentication. */
  auth?: InputMaybe<DastSiteProfileAuthInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** URLs to skip during an authenticated scan. */
  excludedUrls?: InputMaybe<Array<Scalars['String']>>;
  /**
   * Project the site profile belongs to. Deprecated in 14.5: Full path not required to qualify Global ID.
   * @deprecated Full path not required to qualify Global ID. Deprecated in 14.5.
   */
  fullPath?: InputMaybe<Scalars['ID']>;
  /** ID of the site profile to be updated. */
  id: Scalars['DastSiteProfileID'];
  /** Name of the site profile. */
  profileName: Scalars['String'];
  /** Comma-separated list of request header names and values to be added to every request made by DAST. */
  requestHeaders?: InputMaybe<Scalars['String']>;
  /** File Path or URL used as input for the scan method. */
  scanFilePath?: InputMaybe<Scalars['String']>;
  /** Scan method by the scanner. */
  scanMethod?: InputMaybe<DastScanMethodType>;
  /** Type of target to be scanned. */
  targetType?: InputMaybe<DastTargetTypeEnum>;
  /** URL of the target to be scanned. */
  targetUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DastSiteProfileUpdate */
export type DastSiteProfileUpdatePayload = {
  __typename?: 'DastSiteProfileUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Site profile object. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /**
   * ID of the site profile. Deprecated in 14.10: use `dastSiteProfile.id` field.
   * @deprecated use `dastSiteProfile.id` field. Deprecated in 14.10.
   */
  id?: Maybe<Scalars['DastSiteProfileID']>;
};

export type DastSiteProfileValidationStatusEnum =
  /** Site validation process finished but failed. */
  | 'FAILED_VALIDATION'
  /** Site validation process is in progress. */
  | 'INPROGRESS_VALIDATION'
  /** No site validation exists. */
  | 'NONE'
  /** Site validation process finished successfully. */
  | 'PASSED_VALIDATION'
  /** Site validation process has not started. */
  | 'PENDING_VALIDATION';

/** Autogenerated input type of DastSiteTokenCreate */
export type DastSiteTokenCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the site token belongs to. */
  fullPath: Scalars['ID'];
  /** URL of the target to be validated. */
  targetUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DastSiteTokenCreate */
export type DastSiteTokenCreatePayload = {
  __typename?: 'DastSiteTokenCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** ID of the site token. */
  id?: Maybe<Scalars['DastSiteTokenID']>;
  /** Current validation status of the target. */
  status?: Maybe<DastSiteProfileValidationStatusEnum>;
  /** Token string. */
  token?: Maybe<Scalars['String']>;
};

/** Represents a DAST Site Validation */
export type DastSiteValidation = {
  __typename?: 'DastSiteValidation';
  /** Global ID of the site validation. */
  id: Scalars['DastSiteValidationID'];
  /** Normalized URL of the target to be validated. */
  normalizedTargetUrl?: Maybe<Scalars['String']>;
  /** Status of the site validation. */
  status: DastSiteProfileValidationStatusEnum;
  /** Timestamp of when the validation started. */
  validationStartedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for DastSiteValidation. */
export type DastSiteValidationConnection = {
  __typename?: 'DastSiteValidationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DastSiteValidationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DastSiteValidation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of DastSiteValidationCreate */
export type DastSiteValidationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the site token. */
  dastSiteTokenId: Scalars['DastSiteTokenID'];
  /** Project the site profile belongs to. */
  fullPath: Scalars['ID'];
  /** Validation strategy to be used. */
  strategy?: InputMaybe<DastSiteValidationStrategyEnum>;
  /** Path to be requested during validation. */
  validationPath: Scalars['String'];
};

/** Autogenerated return type of DastSiteValidationCreate */
export type DastSiteValidationCreatePayload = {
  __typename?: 'DastSiteValidationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** ID of the site validation. */
  id?: Maybe<Scalars['DastSiteValidationID']>;
  /** Current validation status. */
  status?: Maybe<DastSiteProfileValidationStatusEnum>;
};

/** An edge in a connection. */
export type DastSiteValidationEdge = {
  __typename?: 'DastSiteValidationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DastSiteValidation>;
};

/** Autogenerated input type of DastSiteValidationRevoke */
export type DastSiteValidationRevokeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project the site validation belongs to. */
  fullPath: Scalars['ID'];
  /** Normalized URL of the target to be revoked. */
  normalizedTargetUrl: Scalars['String'];
};

/** Autogenerated return type of DastSiteValidationRevoke */
export type DastSiteValidationRevokePayload = {
  __typename?: 'DastSiteValidationRevokePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type DastSiteValidationStatusEnum =
  /** Site validation process finished but failed. */
  | 'FAILED_VALIDATION'
  /** Site validation process is in progress. */
  | 'INPROGRESS_VALIDATION'
  /** Site validation process finished successfully. */
  | 'PASSED_VALIDATION'
  /** Site validation process has not started. */
  | 'PENDING_VALIDATION';

export type DastSiteValidationStrategyEnum =
  /** Header validation. */
  | 'HEADER'
  /** Meta tag validation. */
  | 'META_TAG'
  /** Text file validation. */
  | 'TEXT_FILE';

export type DastTargetTypeEnum =
  /** API target. */
  | 'API'
  /** Website target. */
  | 'WEBSITE';

/** Color of the data visualization palette */
export type DataVisualizationColorEnum =
  /** Aqua color */
  | 'AQUA'
  /** Blue color */
  | 'BLUE'
  /** Green color */
  | 'GREEN'
  /** Magenta color */
  | 'MAGENTA'
  /** Orange color */
  | 'ORANGE';

/** Weight of the data visualization palette */
export type DataVisualizationWeightEnum =
  /** 50 weight */
  | 'WEIGHT_50'
  /** 100 weight */
  | 'WEIGHT_100'
  /** 200 weight */
  | 'WEIGHT_200'
  /** 300 weight */
  | 'WEIGHT_300'
  /** 400 weight */
  | 'WEIGHT_400'
  /** 500 weight */
  | 'WEIGHT_500'
  /** 600 weight */
  | 'WEIGHT_600'
  /** 700 weight */
  | 'WEIGHT_700'
  /** 800 weight */
  | 'WEIGHT_800'
  /** 900 weight */
  | 'WEIGHT_900'
  /** 950 weight */
  | 'WEIGHT_950';

/** Autogenerated input type of DeleteAnnotation */
export type DeleteAnnotationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the annotation to delete. */
  id: Scalars['MetricsDashboardAnnotationID'];
};

/** Autogenerated return type of DeleteAnnotation */
export type DeleteAnnotationPayload = {
  __typename?: 'DeleteAnnotationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The response from the AdminSidekiqQueuesDeleteJobs mutation */
export type DeleteJobsResponse = {
  __typename?: 'DeleteJobsResponse';
  /** Whether or not the entire queue was processed in time; if not, retrying the same request is safe. */
  completed?: Maybe<Scalars['Boolean']>;
  /** Number of matching jobs deleted. */
  deletedJobs?: Maybe<Scalars['Int']>;
  /** Queue size after processing. */
  queueSize?: Maybe<Scalars['Int']>;
};

export type DeletedNote = {
  __typename?: 'DeletedNote';
  /** ID of the discussion for the deleted note. */
  discussionId?: Maybe<Scalars['DiscussionID']>;
  /** ID of the deleted note. */
  id: Scalars['NoteID'];
  /** Whether deleted note is the last note in the discussion. */
  lastDiscussionNote?: Maybe<Scalars['Boolean']>;
};

/** A software dependency used by a project */
export type Dependency = {
  __typename?: 'Dependency';
  /** ID of the dependency. */
  id: Scalars['GlobalID'];
  /** Information about where the dependency is located. */
  location?: Maybe<Location>;
  /** Name of the dependency. */
  name: Scalars['String'];
  /** Description of the tool used to manage the dependency. */
  packager?: Maybe<PackageManager>;
  /** Version of the dependency. */
  version?: Maybe<Scalars['String']>;
};

/** The connection type for Dependency. */
export type DependencyConnection = {
  __typename?: 'DependencyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Dependency>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyEdge = {
  __typename?: 'DependencyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Dependency>;
};

/** Represents metadata associated with a dependency link */
export type DependencyLinkMetadata = NugetDependencyLinkMetadata;

/** Dependency proxy blob */
export type DependencyProxyBlob = {
  __typename?: 'DependencyProxyBlob';
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Name of the blob. */
  fileName: Scalars['String'];
  /** Size of the blob file. */
  size: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** The connection type for DependencyProxyBlob. */
export type DependencyProxyBlobConnection = {
  __typename?: 'DependencyProxyBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyBlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyBlobEdge = {
  __typename?: 'DependencyProxyBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyBlob>;
};

/** Represents the Geo replication and verification state of a dependency_proxy_blob */
export type DependencyProxyBlobRegistry = {
  __typename?: 'DependencyProxyBlobRegistry';
  /** Timestamp when the DependencyProxyBlobRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Dependency Proxy Blob. */
  dependencyProxyBlobId: Scalars['ID'];
  /** ID of the DependencyProxyBlobRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the DependencyProxyBlobRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the DependencyProxyBlobRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the DependencyProxyBlobRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the DependencyProxyBlobRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the DependencyProxyBlobRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the DependencyProxyBlobRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the DependencyProxyBlobRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for DependencyProxyBlobRegistry. */
export type DependencyProxyBlobRegistryConnection = {
  __typename?: 'DependencyProxyBlobRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyBlobRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyBlobRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyBlobRegistryEdge = {
  __typename?: 'DependencyProxyBlobRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyBlobRegistry>;
};

/** Group-level Dependency Proxy TTL policy settings */
export type DependencyProxyImageTtlGroupPolicy = {
  __typename?: 'DependencyProxyImageTtlGroupPolicy';
  /** Timestamp of creation. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled: Scalars['Boolean'];
  /** Number of days to retain a cached image file. */
  ttl?: Maybe<Scalars['Int']>;
  /** Timestamp of the most recent update. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** Dependency proxy manifest */
export type DependencyProxyManifest = {
  __typename?: 'DependencyProxyManifest';
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Digest of the manifest. */
  digest: Scalars['String'];
  /** Name of the manifest. */
  fileName: Scalars['String'];
  /** ID of the manifest. */
  id: Scalars['DependencyProxyManifestID'];
  /** Name of the image. */
  imageName: Scalars['String'];
  /** Size of the manifest file. */
  size: Scalars['String'];
  /** Status of the manifest (default, pending_destruction, processing, error) */
  status: DependencyProxyManifestStatus;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** The connection type for DependencyProxyManifest. */
export type DependencyProxyManifestConnection = {
  __typename?: 'DependencyProxyManifestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyManifestEdge = {
  __typename?: 'DependencyProxyManifestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyManifest>;
};

/** Represents the Geo replication and verification state of a dependency_proxy_manifest */
export type DependencyProxyManifestRegistry = {
  __typename?: 'DependencyProxyManifestRegistry';
  /** Timestamp when the DependencyProxyManifestRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Dependency Proxy Manifest. */
  dependencyProxyManifestId: Scalars['ID'];
  /** ID of the DependencyProxyManifestRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the DependencyProxyManifestRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the DependencyProxyManifestRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the DependencyProxyManifestRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the DependencyProxyManifestRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the DependencyProxyManifestRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the DependencyProxyManifestRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the DependencyProxyManifestRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for DependencyProxyManifestRegistry. */
export type DependencyProxyManifestRegistryConnection = {
  __typename?: 'DependencyProxyManifestRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DependencyProxyManifestRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DependencyProxyManifestRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DependencyProxyManifestRegistryEdge = {
  __typename?: 'DependencyProxyManifestRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DependencyProxyManifestRegistry>;
};

export type DependencyProxyManifestStatus =
  /** Dependency proxy manifest has a status of default. */
  | 'DEFAULT'
  /** Dependency proxy manifest has a status of error. */
  | 'ERROR'
  /** Dependency proxy manifest has a status of pending_destruction. */
  | 'PENDING_DESTRUCTION'
  /** Dependency proxy manifest has a status of processing. */
  | 'PROCESSING';

/** Group-level Dependency Proxy settings */
export type DependencyProxySetting = {
  __typename?: 'DependencyProxySetting';
  /** Indicates whether the dependency proxy is enabled for the group. */
  enabled: Scalars['Boolean'];
};

/** Values for sorting dependencies */
export type DependencySort =
  /** Name by ascending order. */
  | 'NAME_ASC'
  /** Name by descending order. */
  | 'NAME_DESC'
  /** Packager by ascending order. */
  | 'PACKAGER_ASC'
  /** Packager by descending order. */
  | 'PACKAGER_DESC';

/** The deployment of an environment */
export type Deployment = {
  __typename?: 'Deployment';
  /** Approval summary of the deployment.This field can only be resolved for one deployment in any single request. */
  approvalSummary?: Maybe<DeploymentApprovalSummary>;
  /** Current approvals of the deployment. */
  approvals?: Maybe<Array<DeploymentApproval>>;
  /** Commit details of the deployment. */
  commit?: Maybe<Commit>;
  /** When the deployment record was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** When the deployment finished. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** Global ID of the deployment. */
  id?: Maybe<Scalars['ID']>;
  /** Project-level internal ID of the deployment. */
  iid?: Maybe<Scalars['ID']>;
  /** Pipeline job of the deployment. */
  job?: Maybe<CiJob>;
  /** Number of pending unified approvals on the deployment. */
  pendingApprovalCount?: Maybe<Scalars['Int']>;
  /** Git-Ref that the deployment ran on. */
  ref?: Maybe<Scalars['String']>;
  /** Git-SHA that the deployment ran on. */
  sha?: Maybe<Scalars['String']>;
  /** Status of the deployment. */
  status?: Maybe<DeploymentStatus>;
  /** True or false if the deployment ran on a Git-tag. */
  tag?: Maybe<Scalars['Boolean']>;
  /** Git tags that contain this deployment. This field can only be resolved for two deployments in any single request. */
  tags?: Maybe<Array<DeploymentTag>>;
  /** User who executed the deployment. */
  triggerer?: Maybe<UserCore>;
  /** When the deployment record was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Permissions for the current user on the resource */
  userPermissions: DeploymentPermissions;
};

/** Approval of the deployment. */
export type DeploymentApproval = {
  __typename?: 'DeploymentApproval';
  /** Additional comment. */
  comment?: Maybe<Scalars['String']>;
  /** When the user approved/rejected first time. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Whether the deployment was approved/rejected. */
  status?: Maybe<DeploymentsApprovalStatus>;
  /** When the user updated the approval. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User who approved or rejected the deployment. */
  user?: Maybe<UserCore>;
};

/** Approval summary of the deployment. */
export type DeploymentApprovalSummary = {
  __typename?: 'DeploymentApprovalSummary';
  /** Approval Rules for the deployment. */
  rules?: Maybe<Array<ProtectedEnvironmentApprovalRuleForSummary>>;
  /** Status of the approvals. */
  status?: Maybe<DeploymentApprovalSummaryStatus>;
  /** Total pending approval count. */
  totalPendingApprovalCount?: Maybe<Scalars['Int']>;
  /** Total number of required approvals. */
  totalRequiredApprovals?: Maybe<Scalars['Int']>;
};

/** Status of the deployment approval summary. */
export type DeploymentApprovalSummaryStatus =
  /** Summarized deployment approval status that is approved. */
  | 'APPROVED'
  /** Summarized deployment approval status that is pending approval. */
  | 'PENDING_APPROVAL'
  /** Summarized deployment approval status that is rejected. */
  | 'REJECTED';

/** The connection type for Deployment. */
export type DeploymentConnection = {
  __typename?: 'DeploymentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DeploymentEdge = {
  __typename?: 'DeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Deployment>;
};

export type DeploymentPermissions = {
  __typename?: 'DeploymentPermissions';
  /**
   * Indicates the user can perform `approve_deployment` on this resource. This
   * field can only be resolved for one environment in any single request.
   */
  approveDeployment: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_deployment` on this resource */
  destroyDeployment: Scalars['Boolean'];
  /** Indicates the user can perform `update_deployment` on this resource */
  updateDeployment: Scalars['Boolean'];
};

/** All deployment statuses. */
export type DeploymentStatus =
  /** A deployment that is blocked. */
  | 'BLOCKED'
  /** A deployment that is canceled. */
  | 'CANCELED'
  /** A deployment that is created. */
  | 'CREATED'
  /** A deployment that is failed. */
  | 'FAILED'
  /** A deployment that is running. */
  | 'RUNNING'
  /** A deployment that is skipped. */
  | 'SKIPPED'
  /** A deployment that is success. */
  | 'SUCCESS';

/** Tags for a given deployment */
export type DeploymentTag = {
  __typename?: 'DeploymentTag';
  /** Name of this git tag. */
  name?: Maybe<Scalars['String']>;
  /** Path for this tag. */
  path?: Maybe<Scalars['String']>;
};

/** All environment deployment tiers. */
export type DeploymentTier =
  /** Development. */
  | 'DEVELOPMENT'
  /** Other. */
  | 'OTHER'
  /** Production. */
  | 'PRODUCTION'
  /** Staging. */
  | 'STAGING'
  /** Testing. */
  | 'TESTING';

/** Status of the deployment approval. */
export type DeploymentsApprovalStatus =
  /** A deployment approval that is approved. */
  | 'APPROVED'
  /** A deployment approval that is rejected. */
  | 'REJECTED';

/** Values for ordering deployments by a specific field */
export type DeploymentsOrderByInput = {
  /** Order by Created time. */
  createdAt?: InputMaybe<SortDirectionEnum>;
  /** Order by Finished time. */
  finishedAt?: InputMaybe<SortDirectionEnum>;
};

export type DescriptionVersion = {
  __typename?: 'DescriptionVersion';
  /**
   * Whether current user can delete description version associated to the note
   * metadata. Deprecated in 15.7: For backwards compatibility with REST API
   * version and to be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.
   */
  canDelete?: Maybe<Scalars['Boolean']>;
  /**
   * Web path to delete description version associated to the note metadata.
   * Deprecated in 15.7: For backwards compatibility with REST API version and to
   * be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.
   */
  deletePath?: Maybe<Scalars['String']>;
  /**
   * Whether description version associated to the note metadata is deleted.
   * Deprecated in 15.7: For backwards compatibility with REST API version and to
   * be removed in a next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.
   */
  deleted?: Maybe<Scalars['Boolean']>;
  /** Content of the given description version. */
  description?: Maybe<Scalars['String']>;
  /** Description diff between versions. */
  diff?: Maybe<Scalars['String']>;
  /**
   * Web path to description version associated to the note metadata. Deprecated in
   * 15.7: For backwards compatibility with REST API version and to be removed in a
   * next iteration.
   * @deprecated For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.
   */
  diffPath?: Maybe<Scalars['String']>;
  /** ID of the description version. */
  id: Scalars['DescriptionVersionID'];
};


export type DescriptionVersionDiffArgs = {
  versionId?: InputMaybe<Scalars['DescriptionVersionID']>;
};

/** A single design */
export type Design = CurrentUserTodos & DesignFields & NoteableInterface & Todoable & {
  __typename?: 'Design';
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Description of the design. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Diff refs for this design. */
  diffRefs: DiffRefs;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** How this design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String'];
  /** Full path to the design file. */
  fullPath: Scalars['String'];
  /** ID of this design. */
  id: Scalars['ID'];
  /** URL of the full-sized image. */
  image: Scalars['String'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Total count of user-created notes for this design. */
  notesCount: Scalars['Int'];
  /** Project the design belongs to. */
  project: Project;
  /** All versions related to this design ordered newest first. */
  versions: DesignVersionConnection;
  /** URL of the design. */
  webUrl: Scalars['String'];
};


/** A single design */
export type DesignCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A single design */
export type DesignCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** A single design */
export type DesignDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A single design */
export type DesignNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A single design */
export type DesignVersionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  earlierOrEqualToId?: InputMaybe<Scalars['DesignManagementVersionID']>;
  earlierOrEqualToSha?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A design pinned to a specific version. The image field reflects the design as of the associated version */
export type DesignAtVersion = DesignFields & {
  __typename?: 'DesignAtVersion';
  /** Underlying design. */
  design: Design;
  /** Diff refs for this design. */
  diffRefs: DiffRefs;
  /** How this design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String'];
  /** Full path to the design file. */
  fullPath: Scalars['String'];
  /** ID of this design. */
  id: Scalars['ID'];
  /** URL of the full-sized image. */
  image: Scalars['String'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Total count of user-created notes for this design. */
  notesCount: Scalars['Int'];
  /** Project the design belongs to. */
  project: Project;
  /** Version this design-at-versions is pinned to. */
  version: DesignVersion;
};

/** The connection type for DesignAtVersion. */
export type DesignAtVersionConnection = {
  __typename?: 'DesignAtVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignAtVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignAtVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignAtVersionEdge = {
  __typename?: 'DesignAtVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignAtVersion>;
};

/** A collection of designs */
export type DesignCollection = {
  __typename?: 'DesignCollection';
  /** Copy state of the design collection. */
  copyState?: Maybe<DesignCollectionCopyState>;
  /** Find a specific design. */
  design?: Maybe<Design>;
  /** Find a design as of a version. */
  designAtVersion?: Maybe<DesignAtVersion>;
  /** All designs for the design collection. */
  designs: DesignConnection;
  /** Issue associated with the design collection. */
  issue: Issue;
  /** Project associated with the design collection. */
  project: Project;
  /** A specific version. */
  version?: Maybe<DesignVersion>;
  /** All versions related to all designs, ordered newest first. */
  versions: DesignVersionConnection;
};


/** A collection of designs */
export type DesignCollectionDesignArgs = {
  filename?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['DesignManagementDesignID']>;
};


/** A collection of designs */
export type DesignCollectionDesignAtVersionArgs = {
  id: Scalars['DesignManagementDesignAtVersionID'];
};


/** A collection of designs */
export type DesignCollectionDesignsArgs = {
  after?: InputMaybe<Scalars['String']>;
  atVersion?: InputMaybe<Scalars['DesignManagementVersionID']>;
  before?: InputMaybe<Scalars['String']>;
  filenames?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['DesignManagementDesignID']>>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A collection of designs */
export type DesignCollectionVersionArgs = {
  id?: InputMaybe<Scalars['DesignManagementVersionID']>;
  sha?: InputMaybe<Scalars['String']>;
};


/** A collection of designs */
export type DesignCollectionVersionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  earlierOrEqualToId?: InputMaybe<Scalars['DesignManagementVersionID']>;
  earlierOrEqualToSha?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Copy state of a DesignCollection */
export type DesignCollectionCopyState =
  /** The DesignCollection encountered an error during a copy */
  | 'ERROR'
  /** The DesignCollection is being copied */
  | 'IN_PROGRESS'
  /** The DesignCollection has no copy in progress */
  | 'READY';

/** The connection type for Design. */
export type DesignConnection = {
  __typename?: 'DesignConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Design>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignEdge = {
  __typename?: 'DesignEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Design>;
};

export type DesignFields = {
  /** Diff refs for this design. */
  diffRefs: DiffRefs;
  /** How this design was changed in the current version. */
  event: DesignVersionEvent;
  /** Filename of the design. */
  filename: Scalars['String'];
  /** Full path to the design file. */
  fullPath: Scalars['String'];
  /** ID of this design. */
  id: Scalars['ID'];
  /** URL of the full-sized image. */
  image: Scalars['String'];
  /** The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated */
  imageV432x230?: Maybe<Scalars['String']>;
  /** Issue the design belongs to. */
  issue: Issue;
  /** Total count of user-created notes for this design. */
  notesCount: Scalars['Int'];
  /** Project the design belongs to. */
  project: Project;
};

export type DesignManagement = {
  __typename?: 'DesignManagement';
  /** Find a design as of a version. */
  designAtVersion?: Maybe<DesignAtVersion>;
  /** Find a version. */
  version?: Maybe<DesignVersion>;
};


export type DesignManagementDesignAtVersionArgs = {
  id: Scalars['DesignManagementDesignAtVersionID'];
};


export type DesignManagementVersionArgs = {
  id: Scalars['DesignManagementVersionID'];
};

/** Autogenerated input type of DesignManagementDelete */
export type DesignManagementDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Filenames of the designs to delete. */
  filenames: Array<Scalars['String']>;
  /** IID of the issue to modify designs for. */
  iid: Scalars['ID'];
  /** Project where the issue is to upload designs for. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of DesignManagementDelete */
export type DesignManagementDeletePayload = {
  __typename?: 'DesignManagementDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** New version in which the designs are deleted. */
  version?: Maybe<DesignVersion>;
};

/** Autogenerated input type of DesignManagementMove */
export type DesignManagementMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the design to move. */
  id: Scalars['DesignManagementDesignID'];
  /** ID of the immediately following design. */
  next?: InputMaybe<Scalars['DesignManagementDesignID']>;
  /** ID of the immediately preceding design. */
  previous?: InputMaybe<Scalars['DesignManagementDesignID']>;
};

/** Autogenerated return type of DesignManagementMove */
export type DesignManagementMovePayload = {
  __typename?: 'DesignManagementMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Current state of the collection. */
  designCollection?: Maybe<DesignCollection>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents the Geo replication and verification state of a Design Management Repository */
export type DesignManagementRepositoryRegistry = {
  __typename?: 'DesignManagementRepositoryRegistry';
  /** Timestamp when the DesignManagementRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Design Management Repository. */
  designManagementRepositoryId: Scalars['ID'];
  /** ID of the DesignManagementRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the DesignManagementRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the DesignManagementRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the DesignManagementRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the DesignManagementRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the DesignManagementRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the DesignManagementRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the DesignManagementRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for DesignManagementRepositoryRegistry. */
export type DesignManagementRepositoryRegistryConnection = {
  __typename?: 'DesignManagementRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignManagementRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignManagementRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignManagementRepositoryRegistryEdge = {
  __typename?: 'DesignManagementRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignManagementRepositoryRegistry>;
};

/** Autogenerated input type of DesignManagementUpdate */
export type DesignManagementUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the design. */
  description?: InputMaybe<Scalars['String']>;
  /** ID of the design to update. */
  id: Scalars['DesignManagementDesignID'];
};

/** Autogenerated return type of DesignManagementUpdate */
export type DesignManagementUpdatePayload = {
  __typename?: 'DesignManagementUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated design. */
  design: Design;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DesignManagementUpload */
export type DesignManagementUploadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Files to upload. */
  files: Array<Scalars['Upload']>;
  /** IID of the issue to modify designs for. */
  iid: Scalars['ID'];
  /** Project where the issue is to upload designs for. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of DesignManagementUpload */
export type DesignManagementUploadPayload = {
  __typename?: 'DesignManagementUploadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Designs that were uploaded by the mutation. */
  designs: Array<Design>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Any designs that were skipped from the upload due to there being no change to their content since their last version */
  skippedDesigns: Array<Design>;
};

/** A specific version in which designs were added, modified or deleted */
export type DesignVersion = {
  __typename?: 'DesignVersion';
  /** Author of the version. */
  author: UserCore;
  /** Timestamp of when the version was created. */
  createdAt: Scalars['Time'];
  /** A particular design as of this version, provided it is visible at this version. */
  designAtVersion: DesignAtVersion;
  /** All designs that were changed in the version. */
  designs: DesignConnection;
  /** All designs that are visible at this version, as of this version. */
  designsAtVersion: DesignAtVersionConnection;
  /** ID of the design version. */
  id: Scalars['ID'];
  /** SHA of the design version. */
  sha: Scalars['ID'];
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignAtVersionArgs = {
  designId?: InputMaybe<Scalars['DesignManagementDesignID']>;
  filename?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['DesignManagementDesignAtVersionID']>;
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A specific version in which designs were added, modified or deleted */
export type DesignVersionDesignsAtVersionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filenames?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['DesignManagementDesignID']>>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DesignVersion. */
export type DesignVersionConnection = {
  __typename?: 'DesignVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DesignVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DesignVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DesignVersionEdge = {
  __typename?: 'DesignVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DesignVersion>;
};

/** Mutation event of a design within a version */
export type DesignVersionEvent =
  /** A creation event */
  | 'CREATION'
  /** A deletion event */
  | 'DELETION'
  /** A modification event */
  | 'MODIFICATION'
  /** No change. */
  | 'NONE';

/** Autogenerated input type of DestroyBoard */
export type DestroyBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the board to destroy. */
  id: Scalars['BoardID'];
};

/** Autogenerated input type of DestroyBoardList */
export type DestroyBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the list to destroy. Only label lists are accepted. */
  listId: Scalars['ListID'];
};

/** Autogenerated return type of DestroyBoardList */
export type DestroyBoardListPayload = {
  __typename?: 'DestroyBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** List after mutation. */
  list?: Maybe<BoardList>;
};

/** Autogenerated return type of DestroyBoard */
export type DestroyBoardPayload = {
  __typename?: 'DestroyBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyComplianceFramework */
export type DestroyComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the compliance framework to destroy. */
  id: Scalars['ComplianceManagementFrameworkID'];
};

/** Autogenerated return type of DestroyComplianceFramework */
export type DestroyComplianceFrameworkPayload = {
  __typename?: 'DestroyComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyContainerRepository */
export type DestroyContainerRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the container repository. */
  id: Scalars['ContainerRepositoryID'];
};

/** Autogenerated return type of DestroyContainerRepository */
export type DestroyContainerRepositoryPayload = {
  __typename?: 'DestroyContainerRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Container repository policy after scheduling the deletion. */
  containerRepository: ContainerRepository;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyContainerRepositoryTags */
export type DestroyContainerRepositoryTagsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the container repository. */
  id: Scalars['ContainerRepositoryID'];
  /** Container repository tag(s) to delete. Total number can't be greater than 20 */
  tagNames: Array<Scalars['String']>;
};

/** Autogenerated return type of DestroyContainerRepositoryTags */
export type DestroyContainerRepositoryTagsPayload = {
  __typename?: 'DestroyContainerRepositoryTagsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Deleted container repository tags. */
  deletedTagNames: Array<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyCustomEmoji */
export type DestroyCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the custom emoji to destroy. */
  id: Scalars['CustomEmojiID'];
};

/** Autogenerated return type of DestroyCustomEmoji */
export type DestroyCustomEmojiPayload = {
  __typename?: 'DestroyCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Deleted custom emoji. */
  customEmoji?: Maybe<CustomEmoji>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyEpicBoard */
export type DestroyEpicBoardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the board to destroy. */
  id: Scalars['BoardsEpicBoardID'];
};

/** Autogenerated return type of DestroyEpicBoard */
export type DestroyEpicBoardPayload = {
  __typename?: 'DestroyEpicBoardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic board after mutation. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyNote */
export type DestroyNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the note to destroy. */
  id: Scalars['NoteID'];
};

/** Autogenerated return type of DestroyNote */
export type DestroyNotePayload = {
  __typename?: 'DestroyNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of DestroyPackageFile */
export type DestroyPackageFileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Package file. */
  id: Scalars['PackagesPackageFileID'];
};

/** Autogenerated return type of DestroyPackageFile */
export type DestroyPackageFilePayload = {
  __typename?: 'DestroyPackageFilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyPackageFiles */
export type DestroyPackageFilesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IDs of the Package file. */
  ids: Array<Scalars['PackagesPackageFileID']>;
  /** Project path where the packages cleanup policy is located. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of DestroyPackageFiles */
export type DestroyPackageFilesPayload = {
  __typename?: 'DestroyPackageFilesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyPackage */
export type DestroyPackageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Package. */
  id: Scalars['PackagesPackageID'];
};

/** Autogenerated return type of DestroyPackage */
export type DestroyPackagePayload = {
  __typename?: 'DestroyPackagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroyPackages */
export type DestroyPackagesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global IDs of the Packages. Max 20 */
  ids: Array<Scalars['PackagesPackageID']>;
};

/** Autogenerated return type of DestroyPackages */
export type DestroyPackagesPayload = {
  __typename?: 'DestroyPackagesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DestroySnippet */
export type DestroySnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the snippet to destroy. */
  id: Scalars['SnippetID'];
};

/** Autogenerated return type of DestroySnippet */
export type DestroySnippetPayload = {
  __typename?: 'DestroySnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Detailed representation of whether a GitLab merge request can be merged. */
export type DetailedMergeStatus =
  /** Merge request is blocked by another merge request. */
  | 'BLOCKED_STATUS'
  /** Can not merge the source into the target branch, potential conflict. */
  | 'BROKEN_STATUS'
  /** Currently checking for mergeability. */
  | 'CHECKING'
  /** Pipeline must succeed before merging. */
  | 'CI_MUST_PASS'
  /** Pipeline is still running. */
  | 'CI_STILL_RUNNING'
  /** Discussions must be resolved before merging. */
  | 'DISCUSSIONS_NOT_RESOLVED'
  /** Merge request must not be draft before merging. */
  | 'DRAFT_STATUS'
  /** Status checks must pass. */
  | 'EXTERNAL_STATUS_CHECKS'
  /** Branch can be merged. */
  | 'MERGEABLE'
  /** Merge request must be approved before merging. */
  | 'NOT_APPROVED'
  /** Merge request must be open before merging. */
  | 'NOT_OPEN'
  /** There are denied policies for the merge request. */
  | 'POLICIES_DENIED'
  /** Merge request diff is being created. */
  | 'PREPARING'
  /** Merge status has not been checked. */
  | 'UNCHECKED';

export type DetailedStatus = {
  __typename?: 'DetailedStatus';
  /** Action information for the status. This includes method, button title, icon, path, and title. */
  action?: Maybe<StatusAction>;
  /** Path of the details for the status. */
  detailsPath?: Maybe<Scalars['String']>;
  /** Favicon of the status. */
  favicon?: Maybe<Scalars['String']>;
  /** Group of the status. */
  group?: Maybe<Scalars['String']>;
  /** Indicates if the status has further details. */
  hasDetails?: Maybe<Scalars['Boolean']>;
  /** Icon of the status. */
  icon?: Maybe<Scalars['String']>;
  /** ID for a detailed status. */
  id: Scalars['String'];
  /** Label of the status. */
  label?: Maybe<Scalars['String']>;
  /** Text of the status. */
  text?: Maybe<Scalars['String']>;
  /** Tooltip associated with the status. */
  tooltip?: Maybe<Scalars['String']>;
};

/** Enabled namespace for DevopsAdoption */
export type DevopsAdoptionEnabledNamespace = {
  __typename?: 'DevopsAdoptionEnabledNamespace';
  /** Namespace where data should be displayed. */
  displayNamespace?: Maybe<Namespace>;
  /** ID of the enabled namespace. */
  id: Scalars['ID'];
  /** Metrics snapshot for previous month for the enabled namespace. */
  latestSnapshot?: Maybe<DevopsAdoptionSnapshot>;
  /** Namespace which should be calculated. */
  namespace?: Maybe<Namespace>;
  /** Data snapshots of the namespace. */
  snapshots?: Maybe<DevopsAdoptionSnapshotConnection>;
};


/** Enabled namespace for DevopsAdoption */
export type DevopsAdoptionEnabledNamespaceSnapshotsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endTimeAfter?: InputMaybe<Scalars['Time']>;
  endTimeBefore?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DevopsAdoptionEnabledNamespace. */
export type DevopsAdoptionEnabledNamespaceConnection = {
  __typename?: 'DevopsAdoptionEnabledNamespaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DevopsAdoptionEnabledNamespaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DevopsAdoptionEnabledNamespace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DevopsAdoptionEnabledNamespaceEdge = {
  __typename?: 'DevopsAdoptionEnabledNamespaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DevopsAdoptionEnabledNamespace>;
};

/** Snapshot */
export type DevopsAdoptionSnapshot = {
  __typename?: 'DevopsAdoptionSnapshot';
  /** Total number of projects with existing CODEOWNERS file. */
  codeOwnersUsedCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with enabled coverage fuzzing. */
  coverageFuzzingEnabledCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with enabled DAST. */
  dastEnabledCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with enabled dependency scanning. */
  dependencyScanningEnabledCount?: Maybe<Scalars['Int']>;
  /** At least one deployment succeeded. */
  deploySucceeded: Scalars['Boolean'];
  /** End time for the snapshot where the data points were collected. */
  endTime: Scalars['Time'];
  /** At least one issue was opened. */
  issueOpened: Scalars['Boolean'];
  /** At least one merge request was approved. */
  mergeRequestApproved: Scalars['Boolean'];
  /** At least one merge request was opened. */
  mergeRequestOpened: Scalars['Boolean'];
  /** At least one pipeline succeeded. */
  pipelineSucceeded: Scalars['Boolean'];
  /** Time the snapshot was recorded. */
  recordedAt: Scalars['Time'];
  /** At least one runner was used. */
  runnerConfigured: Scalars['Boolean'];
  /** Total number of projects with enabled SAST. */
  sastEnabledCount?: Maybe<Scalars['Int']>;
  /** Start time for the snapshot where the data points were collected. */
  startTime: Scalars['Time'];
  /** Total number of projects. */
  totalProjectsCount?: Maybe<Scalars['Int']>;
  /** Total number of projects with vulnerability management used at least once. */
  vulnerabilityManagementUsedCount?: Maybe<Scalars['Int']>;
};

/** The connection type for DevopsAdoptionSnapshot. */
export type DevopsAdoptionSnapshotConnection = {
  __typename?: 'DevopsAdoptionSnapshotConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DevopsAdoptionSnapshotEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DevopsAdoptionSnapshot>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DevopsAdoptionSnapshotEdge = {
  __typename?: 'DevopsAdoptionSnapshotEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DevopsAdoptionSnapshot>;
};

export type DiffImagePositionInput = {
  /** Merge base of the branch the comment was made on. */
  baseSha?: InputMaybe<Scalars['String']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String'];
  /** Total height of the image. */
  height: Scalars['Int'];
  /**
   * The paths of the file that was changed. Both of the properties of this input
   * are optional, but at least one of them is required
   */
  paths: DiffPathsInput;
  /** SHA of the branch being compared against. */
  startSha: Scalars['String'];
  /** Total width of the image. */
  width: Scalars['Int'];
  /** X position of the note. */
  x: Scalars['Int'];
  /** Y position of the note. */
  y: Scalars['Int'];
};

export type DiffPathsInput = {
  /** Path of the file on the HEAD SHA. */
  newPath?: InputMaybe<Scalars['String']>;
  /** Path of the file on the start SHA. */
  oldPath?: InputMaybe<Scalars['String']>;
};

export type DiffPosition = {
  __typename?: 'DiffPosition';
  /** Information about the branch, HEAD, and base at the time of commenting. */
  diffRefs: DiffRefs;
  /** Path of the file that was changed. */
  filePath: Scalars['String'];
  /** Total height of the image. */
  height?: Maybe<Scalars['Int']>;
  /** Line on HEAD SHA that was changed. */
  newLine?: Maybe<Scalars['Int']>;
  /** Path of the file on the HEAD SHA. */
  newPath?: Maybe<Scalars['String']>;
  /** Line on start SHA that was changed. */
  oldLine?: Maybe<Scalars['Int']>;
  /** Path of the file on the start SHA. */
  oldPath?: Maybe<Scalars['String']>;
  /** Type of file the position refers to. */
  positionType: DiffPositionType;
  /** Total width of the image. */
  width?: Maybe<Scalars['Int']>;
  /** X position of the note. */
  x?: Maybe<Scalars['Int']>;
  /** Y position of the note. */
  y?: Maybe<Scalars['Int']>;
};

export type DiffPositionInput = {
  /** Merge base of the branch the comment was made on. */
  baseSha?: InputMaybe<Scalars['String']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String'];
  /**
   * Line on HEAD SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff)
   * for more information on how to use this field.
   */
  newLine?: InputMaybe<Scalars['Int']>;
  /**
   * Line on start SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff)
   * for more information on how to use this field.
   */
  oldLine?: InputMaybe<Scalars['Int']>;
  /**
   * The paths of the file that was changed. Both of the properties of this input
   * are optional, but at least one of them is required
   */
  paths: DiffPathsInput;
  /** SHA of the branch being compared against. */
  startSha: Scalars['String'];
};

/** Type of file the position refers to */
export type DiffPositionType =
  /** An image. */
  | 'image'
  /** Text file. */
  | 'text';

export type DiffRefs = {
  __typename?: 'DiffRefs';
  /** Merge base of the branch the comment was made on. */
  baseSha?: Maybe<Scalars['String']>;
  /** SHA of the HEAD at the time the comment was made. */
  headSha: Scalars['String'];
  /** SHA of the branch being compared against. */
  startSha: Scalars['String'];
};

/** Changes to a single file */
export type DiffStats = {
  __typename?: 'DiffStats';
  /** Number of lines added to this file. */
  additions: Scalars['Int'];
  /** Number of lines deleted from this file. */
  deletions: Scalars['Int'];
  /** File path, relative to repository root. */
  path: Scalars['String'];
};

/** Aggregated summary of changes */
export type DiffStatsSummary = {
  __typename?: 'DiffStatsSummary';
  /** Number of lines added. */
  additions: Scalars['Int'];
  /** Number of lines changed. */
  changes: Scalars['Int'];
  /** Number of lines deleted. */
  deletions: Scalars['Int'];
  /** Number of files changed. */
  fileCount: Scalars['Int'];
};

/** Autogenerated input type of DisableDevopsAdoptionNamespace */
export type DisableDevopsAdoptionNamespaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** One or many IDs of the enabled namespaces to disable. */
  id: Array<Scalars['AnalyticsDevopsAdoptionEnabledNamespaceID']>;
};

/** Autogenerated return type of DisableDevopsAdoptionNamespace */
export type DisableDevopsAdoptionNamespacePayload = {
  __typename?: 'DisableDevopsAdoptionNamespacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type Discussion = ResolvableInterface & {
  __typename?: 'Discussion';
  /** Timestamp of the discussion's creation. */
  createdAt: Scalars['Time'];
  /** ID of this discussion. */
  id: Scalars['DiscussionID'];
  /** Object which the discussion belongs to. */
  noteable?: Maybe<NoteableType>;
  /** All notes in the discussion. */
  notes: NoteConnection;
  /** ID used to reply to this discussion. */
  replyId: Scalars['DiscussionID'];
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
};


export type DiscussionNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Discussion. */
export type DiscussionConnection = {
  __typename?: 'DiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DiscussionEdge = {
  __typename?: 'DiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Discussion>;
};

/** Autogenerated input type of DiscussionToggleResolve */
export type DiscussionToggleResolveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the discussion. */
  id: Scalars['DiscussionID'];
  /** Will resolve the discussion when true, and unresolve the discussion when false. */
  resolve: Scalars['Boolean'];
};

/** Autogenerated return type of DiscussionToggleResolve */
export type DiscussionToggleResolvePayload = {
  __typename?: 'DiscussionToggleResolvePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Discussion after mutation. */
  discussion?: Maybe<Discussion>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** All information related to DORA metrics. */
export type Dora = {
  __typename?: 'Dora';
  /** DORA metrics for the current group or project. */
  metrics?: Maybe<Array<DoraMetric>>;
};


/** All information related to DORA metrics. */
export type DoraMetricsArgs = {
  endDate?: InputMaybe<Scalars['Date']>;
  environmentTiers?: InputMaybe<Array<DeploymentTier>>;
  interval?: InputMaybe<DoraMetricBucketingInterval>;
  metric?: InputMaybe<DoraMetricType>;
  startDate?: InputMaybe<Scalars['Date']>;
};

export type DoraMetric = {
  __typename?: 'DoraMetric';
  /** Percentage of deployments that caused incidents in production. */
  changeFailureRate?: Maybe<Scalars['Float']>;
  /** Date of the data point. */
  date?: Maybe<Scalars['String']>;
  /** Number of deployments per day. */
  deploymentFrequency?: Maybe<Scalars['Float']>;
  /** Median time to deploy a merged merge request. */
  leadTimeForChanges?: Maybe<Scalars['Float']>;
  /** Median time to close an incident. */
  timeToRestoreService?: Maybe<Scalars['Float']>;
  /**
   * Value of the data point. Deprecated in 15.10: Moved to corresponding metric field.
   * @deprecated Moved to corresponding metric field. Deprecated in 15.10.
   */
  value?: Maybe<Scalars['Float']>;
};

/** All possible ways that DORA metrics can be aggregated. */
export type DoraMetricBucketingInterval =
  /** All data points are combined into a single value. */
  | 'ALL'
  /** Data points are combined into chunks by day. */
  | 'DAILY'
  /** Data points are combined into chunks by month. */
  | 'MONTHLY';

/** All supported DORA metric types. */
export type DoraMetricType =
  /** Change failure rate. */
  | 'CHANGE_FAILURE_RATE'
  /** Deployment frequency. */
  | 'DEPLOYMENT_FREQUENCY'
  /** Lead time for changes. */
  | 'LEAD_TIME_FOR_CHANGES'
  /** Time to restore service. */
  | 'TIME_TO_RESTORE_SERVICE';

/** Aggregated DORA score counts for projects for the last complete month. */
export type DoraPerformanceScoreCount = {
  __typename?: 'DoraPerformanceScoreCount';
  /** Number of projects that score "high" on the metric. */
  highProjectsCount?: Maybe<Scalars['Int']>;
  /** Number of projects that score "low" on the metric. */
  lowProjectsCount?: Maybe<Scalars['Int']>;
  /** Number of projects that score "medium" on the metric. */
  mediumProjectsCount?: Maybe<Scalars['Int']>;
  /** Name of the DORA metric. */
  metricName: Scalars['String'];
  /** Number of projects with no data. */
  noDataProjectsCount?: Maybe<Scalars['Int']>;
};

/** The connection type for DoraPerformanceScoreCount. */
export type DoraPerformanceScoreCountConnection = {
  __typename?: 'DoraPerformanceScoreCountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DoraPerformanceScoreCountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DoraPerformanceScoreCount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DoraPerformanceScoreCountEdge = {
  __typename?: 'DoraPerformanceScoreCountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DoraPerformanceScoreCount>;
};

/** Autogenerated input type of EchoCreate */
export type EchoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Errors to return to the user. */
  errors?: InputMaybe<Array<Scalars['String']>>;
  /** Messages to return to the user. */
  messages?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of EchoCreate */
export type EchoCreatePayload = {
  __typename?: 'EchoCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Messages returned to the user. */
  echoes?: Maybe<Array<Scalars['String']>>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type EgressNode = {
  __typename?: 'EgressNode';
  /** Artifacts egress for that project in that period of time. */
  artifactsEgress: Scalars['BigInt'];
  /** First day of the node range. There is one node per month. */
  date: Scalars['String'];
  /** Packages egress for that project in that period of time. */
  packagesEgress: Scalars['BigInt'];
  /** Registry egress for that project in that period of time. */
  registryEgress: Scalars['BigInt'];
  /** Repository egress for that project in that period of time. */
  repositoryEgress: Scalars['BigInt'];
  /** Total egress for that project in that period of time. */
  totalEgress: Scalars['BigInt'];
};

/** The connection type for EgressNode. */
export type EgressNodeConnection = {
  __typename?: 'EgressNodeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EgressNodeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EgressNode>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EgressNodeEdge = {
  __typename?: 'EgressNodeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EgressNode>;
};

export type Email = {
  __typename?: 'Email';
  /** Timestamp the email was confirmed. */
  confirmedAt?: Maybe<Scalars['Time']>;
  /** Timestamp the email was created. */
  createdAt: Scalars['Time'];
  /** Email address. */
  email: Scalars['String'];
  /** Internal ID of the email. */
  id: Scalars['ID'];
  /** Timestamp the email was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for Email. */
export type EmailConnection = {
  __typename?: 'EmailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Email>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EmailEdge = {
  __typename?: 'EmailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Email>;
};

/** Autogenerated input type of EnableDevopsAdoptionNamespace */
export type EnableDevopsAdoptionNamespaceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Display namespace ID. */
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']>;
  /** Namespace ID. */
  namespaceId: Scalars['NamespaceID'];
};

/** Autogenerated return type of EnableDevopsAdoptionNamespace */
export type EnableDevopsAdoptionNamespacePayload = {
  __typename?: 'EnableDevopsAdoptionNamespacePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Enabled namespace after mutation. */
  enabledNamespace?: Maybe<DevopsAdoptionEnabledNamespace>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type Entry = {
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Type of tree entry. */
  type: EntryType;
};

/** Type of a tree entry */
export type EntryType =
  /** File tree type. */
  | 'blob'
  /** Commit tree type. */
  | 'commit'
  /** Directory tree type. */
  | 'tree';

/** Describes where code is deployed for a project */
export type Environment = {
  __typename?: 'Environment';
  /** When the environment is going to be deleted automatically. */
  autoDeleteAt?: Maybe<Scalars['Time']>;
  /** When the environment is going to be stopped automatically. */
  autoStopAt?: Maybe<Scalars['Time']>;
  /** Cluster agent of the environment. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** When the environment was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Deployment freeze periods of the environment. */
  deployFreezes?: Maybe<Array<CiFreezePeriod>>;
  /** Deployments of the environment. This field can only be resolved for one environment in any single request. */
  deployments?: Maybe<DeploymentConnection>;
  /** Folder name of the environment. */
  environmentType?: Maybe<Scalars['String']>;
  /** External URL of the environment. */
  externalUrl?: Maybe<Scalars['String']>;
  /** ID of the environment. */
  id: Scalars['ID'];
  /** Last deployment of the environment. */
  lastDeployment?: Maybe<Deployment>;
  /** Most severe open alert for the environment. If multiple alerts have equal severity, the most recent is returned. */
  latestOpenedMostSevereAlert?: Maybe<AlertManagementAlert>;
  /**
   * Metrics dashboard schema for the environment. Deprecated in 16.0: Returns no data. Underlying feature was removed in 16.0.
   * @deprecated Returns no data. Underlying feature was removed in 16.0. Deprecated in 16.0.
   */
  metricsDashboard?: Maybe<MetricsDashboard>;
  /** Human-readable name of the environment. */
  name: Scalars['String'];
  /** Path to the environment. */
  path: Scalars['String'];
  /** Protected Environments for the environment. */
  protectedEnvironments?: Maybe<ProtectedEnvironmentConnection>;
  /** Slug of the environment. */
  slug?: Maybe<Scalars['String']>;
  /** State of the environment, for example: available/stopped. */
  state: Scalars['String'];
  /** Deployment tier of the environment. */
  tier?: Maybe<DeploymentTier>;
  /** When the environment was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /**
   * Permissions for the current user on the resource. This field can only be
   * resolved for one environment in any single request.
   */
  userPermissions: EnvironmentPermissions;
};


/** Describes where code is deployed for a project */
export type EnvironmentDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<DeploymentsOrderByInput>;
  statuses?: InputMaybe<Array<DeploymentStatus>>;
};


/** Describes where code is deployed for a project */
export type EnvironmentLastDeploymentArgs = {
  status: DeploymentStatus;
};


/** Describes where code is deployed for a project */
export type EnvironmentMetricsDashboardArgs = {
  path: Scalars['String'];
};


/** Describes where code is deployed for a project */
export type EnvironmentProtectedEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Environment. */
export type EnvironmentConnection = {
  __typename?: 'EnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EnvironmentCreate */
export type EnvironmentCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Cluster agent of the environment. */
  clusterAgentId?: InputMaybe<Scalars['ClustersAgentID']>;
  /** External URL of the environment. */
  externalUrl?: InputMaybe<Scalars['String']>;
  /** Name of the environment. */
  name: Scalars['String'];
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** Tier of the environment. */
  tier?: InputMaybe<DeploymentTier>;
};

/** Autogenerated return type of EnvironmentCreate */
export type EnvironmentCreatePayload = {
  __typename?: 'EnvironmentCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created environment. */
  environment?: Maybe<Environment>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of EnvironmentDelete */
export type EnvironmentDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the environment to Delete. */
  id: Scalars['EnvironmentID'];
};

/** Autogenerated return type of EnvironmentDelete */
export type EnvironmentDeletePayload = {
  __typename?: 'EnvironmentDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type EnvironmentEdge = {
  __typename?: 'EnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Environment>;
};

export type EnvironmentPermissions = {
  __typename?: 'EnvironmentPermissions';
  /** Indicates the user can perform `destroy_environment` on this resource */
  destroyEnvironment: Scalars['Boolean'];
  /** Indicates the user can perform `stop_environment` on this resource */
  stopEnvironment: Scalars['Boolean'];
  /** Indicates the user can perform `update_environment` on this resource */
  updateEnvironment: Scalars['Boolean'];
};

/** Autogenerated input type of EnvironmentStop */
export type EnvironmentStopInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Force environment to stop without executing on_stop actions. */
  force?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the environment to stop. */
  id: Scalars['EnvironmentID'];
};

/** Autogenerated return type of EnvironmentStop */
export type EnvironmentStopPayload = {
  __typename?: 'EnvironmentStopPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Environment after attempt to stop. */
  environment?: Maybe<Environment>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of EnvironmentUpdate */
export type EnvironmentUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Cluster agent of the environment. */
  clusterAgentId?: InputMaybe<Scalars['ClustersAgentID']>;
  /** External URL of the environment. */
  externalUrl?: InputMaybe<Scalars['String']>;
  /** Global ID of the environment to update. */
  id: Scalars['EnvironmentID'];
  /** Tier of the environment. */
  tier?: InputMaybe<DeploymentTier>;
};

/** Autogenerated return type of EnvironmentUpdate */
export type EnvironmentUpdatePayload = {
  __typename?: 'EnvironmentUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Environment after attempt to update. */
  environment?: Maybe<Environment>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of EnvironmentsCanaryIngressUpdate */
export type EnvironmentsCanaryIngressUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the environment to update. */
  id: Scalars['EnvironmentID'];
  /** Weight of the Canary Ingress. */
  weight: Scalars['Int'];
};

/** Autogenerated return type of EnvironmentsCanaryIngressUpdate */
export type EnvironmentsCanaryIngressUpdatePayload = {
  __typename?: 'EnvironmentsCanaryIngressUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents an epic */
export type Epic = CurrentUserTodos & Eventable & NoteableInterface & Todoable & {
  __typename?: 'Epic';
  /** Ancestors (parents) of the epic. */
  ancestors?: Maybe<EpicConnection>;
  /** Author of the epic. */
  author: UserCore;
  /** List of award emojis associated with the epic. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Indicates the epic is blocked. */
  blocked?: Maybe<Scalars['Boolean']>;
  /** Count of epics blocking this epic. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Epics blocking this epic. */
  blockedByEpics?: Maybe<EpicConnection>;
  /** Count of epics that this epic is blocking. */
  blockingCount?: Maybe<Scalars['Int']>;
  /** Children (sub-epics) of the epic. */
  children?: Maybe<EpicConnection>;
  /** Timestamp of when the epic was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Color of the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  color?: Maybe<Scalars['String']>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Indicates if the epic is confidential. */
  confidential?: Maybe<Scalars['Boolean']>;
  /** Timestamp of when the epic was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default Project for issue creation. Based on the project the user created the last issue in. */
  defaultProjectForIssueCreation?: Maybe<Project>;
  /** Number of open and closed descendant epics and issues. */
  descendantCounts?: Maybe<EpicDescendantCount>;
  /** Total weight of open and closed issues in the epic and its descendants. */
  descendantWeightSum?: Maybe<EpicDescendantWeights>;
  /** Description of the epic. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the epic has received. */
  downvotes: Scalars['Int'];
  /** Due date of the epic. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Fixed due date of the epic. */
  dueDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from child epics or milestones. */
  dueDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited due date of the epic from milestones. */
  dueDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the due date has been manually set. */
  dueDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
  /** Group to which the epic belongs. */
  group: Group;
  /** Indicates if the epic has children. */
  hasChildren: Scalars['Boolean'];
  /** Indicates if the epic has direct issues. */
  hasIssues: Scalars['Boolean'];
  /** Indicates if the epic has a parent epic. */
  hasParent: Scalars['Boolean'];
  /** Current health status of the epic. */
  healthStatus?: Maybe<EpicHealthStatus>;
  /** ID of the epic. */
  id: Scalars['ID'];
  /** Internal ID of the epic. */
  iid: Scalars['ID'];
  /** A list of issues associated with the epic. */
  issues?: Maybe<EpicIssueConnection>;
  /** Labels assigned to the epic. */
  labels?: Maybe<LabelConnection>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Parent epic of the epic. */
  parent?: Maybe<Epic>;
  /** List of participants for the epic. */
  participants?: Maybe<UserCoreConnection>;
  /** Internal reference of the epic. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** URI path of the epic-issue relationship. */
  relationPath?: Maybe<Scalars['String']>;
  /** Relative position of the epic in the epic tree. */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Start date of the epic. */
  startDate?: Maybe<Scalars['Time']>;
  /** Fixed start date of the epic. */
  startDateFixed?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from child epics or milestones. */
  startDateFromInheritedSource?: Maybe<Scalars['Time']>;
  /** Inherited start date of the epic from milestones. */
  startDateFromMilestones?: Maybe<Scalars['Time']>;
  /** Indicates if the start date has been manually set. */
  startDateIsFixed?: Maybe<Scalars['Boolean']>;
  /** State of the epic. */
  state: EpicState;
  /** Indicates the currently logged in user is subscribed to the epic. */
  subscribed: Scalars['Boolean'];
  /** Text color generated for the epic. Returns `null` if `epic_color_highlight` feature flag is disabled. */
  textColor?: Maybe<Scalars['String']>;
  /** Title of the epic. */
  title?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the epic was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Number of upvotes the epic has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the epic. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the epic. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: EpicPermissions;
  /** Web path of the epic. */
  webPath: Scalars['String'];
  /** Web URL of the epic. */
  webUrl: Scalars['String'];
};


/** Represents an epic */
export type EpicAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['ID']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Represents an epic */
export type EpicAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicBlockedByEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['ID']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Represents an epic */
export type EpicCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Represents an epic */
export type EpicDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic */
export type EpicReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of EpicAddIssue */
export type EpicAddIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the epic to mutate belongs to. */
  groupPath: Scalars['ID'];
  /** IID of the epic to mutate. */
  iid: Scalars['ID'];
  /** IID of the issue to be added. */
  issueIid: Scalars['String'];
  /** Full path of the project the issue belongs to. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of EpicAddIssue */
export type EpicAddIssuePayload = {
  __typename?: 'EpicAddIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Epic-issue relationship. */
  epicIssue?: Maybe<EpicIssue>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents an epic board */
export type EpicBoard = {
  __typename?: 'EpicBoard';
  /** Whether or not display epic colors. */
  displayColors?: Maybe<Scalars['Boolean']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: Maybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: Maybe<Scalars['Boolean']>;
  /** Global ID of the epic board. */
  id: Scalars['BoardsEpicBoardID'];
  /** Labels of the board. */
  labels?: Maybe<LabelConnection>;
  /** Epic board lists. */
  lists?: Maybe<EpicListConnection>;
  /** Name of the epic board. */
  name?: Maybe<Scalars['String']>;
  /** Web path of the epic board. */
  webPath: Scalars['String'];
  /** Web URL of the epic board. */
  webUrl: Scalars['String'];
};


/** Represents an epic board */
export type EpicBoardLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents an epic board */
export type EpicBoardListsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  epicFilters?: InputMaybe<EpicFilters>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['BoardsEpicListID']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for EpicBoard. */
export type EpicBoardConnection = {
  __typename?: 'EpicBoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicBoardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicBoard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of EpicBoardCreate */
export type EpicBoardCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not display epic colors. Ignored unless `epic_color_highlight` flag is enabled. */
  displayColors?: InputMaybe<Scalars['Boolean']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of EpicBoardCreate */
export type EpicBoardCreatePayload = {
  __typename?: 'EpicBoardCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Created epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type EpicBoardEdge = {
  __typename?: 'EpicBoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicBoard>;
};

/** Autogenerated input type of EpicBoardListCreate */
export type EpicBoardListCreateInput = {
  /** Create the backlog list. */
  backlog?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the issue board to mutate. */
  boardId: Scalars['BoardsEpicBoardID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of an existing label. */
  labelId?: InputMaybe<Scalars['LabelID']>;
};

/** Autogenerated return type of EpicBoardListCreate */
export type EpicBoardListCreatePayload = {
  __typename?: 'EpicBoardListCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Epic list in the epic board. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of EpicBoardListDestroy */
export type EpicBoardListDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the epic board list to destroy. */
  listId: Scalars['BoardsEpicListID'];
};

/** Autogenerated return type of EpicBoardListDestroy */
export type EpicBoardListDestroyPayload = {
  __typename?: 'EpicBoardListDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Epic board list. `null` if the board was destroyed successfully. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of EpicBoardUpdate */
export type EpicBoardUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not display epic colors. Ignored unless `epic_color_highlight` flag is enabled. */
  displayColors?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** Epic board global ID. */
  id: Scalars['BoardsEpicBoardID'];
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of EpicBoardUpdate */
export type EpicBoardUpdatePayload = {
  __typename?: 'EpicBoardUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for Epic. */
export type EpicConnection = {
  __typename?: 'EpicConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Epic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Counts of descendent epics */
export type EpicDescendantCount = {
  __typename?: 'EpicDescendantCount';
  /** Number of closed child epics. */
  closedEpics?: Maybe<Scalars['Int']>;
  /** Number of closed epic issues. */
  closedIssues?: Maybe<Scalars['Int']>;
  /** Number of opened child epics. */
  openedEpics?: Maybe<Scalars['Int']>;
  /** Number of opened epic issues. */
  openedIssues?: Maybe<Scalars['Int']>;
};

/** Total weight of open and closed descendant issues */
export type EpicDescendantWeights = {
  __typename?: 'EpicDescendantWeights';
  /** Total weight of completed (closed) issues in this epic, including epic descendants. */
  closedIssues?: Maybe<Scalars['Int']>;
  /** Total weight of opened issues in this epic, including epic descendants. */
  openedIssues?: Maybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type EpicEdge = {
  __typename?: 'EpicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Epic>;
};

export type EpicFilters = {
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** Negated epic arguments. */
  not?: InputMaybe<NegatedEpicBoardIssueInput>;
  /** List of arguments with inclusive OR. Ignored unless `or_issuable_queries` flag is enabled. */
  or?: InputMaybe<UnionedEpicFilterInput>;
  /** Search query for epic title or description. */
  search?: InputMaybe<Scalars['String']>;
};

/** Health status of child issues */
export type EpicHealthStatus = {
  __typename?: 'EpicHealthStatus';
  /** Number of issues at risk. */
  issuesAtRisk?: Maybe<Scalars['Int']>;
  /** Number of issues that need attention. */
  issuesNeedingAttention?: Maybe<Scalars['Int']>;
  /** Number of issues on track. */
  issuesOnTrack?: Maybe<Scalars['Int']>;
};

/** Relationship between an epic and an issue */
export type EpicIssue = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'EpicIssue';
  /**
   * Alert associated to this issue. Deprecated in 15.6: Use `alert_management_alerts`.
   * @deprecated Use `alert_management_alerts`. Deprecated in 15.6.
   */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Alert Management alerts associated to this issue. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** Assignees of the issue. */
  assignees?: Maybe<UserCoreConnection>;
  /** User that created the issue. */
  author: UserCore;
  /** Indicates the issue is blocked. */
  blocked: Scalars['Boolean'];
  /** Count of issues blocking this issue. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Issues blocking this issue. */
  blockedByIssues?: Maybe<IssueConnection>;
  /** Count of issues this issue is blocking. */
  blockingCount: Scalars['Int'];
  /** Issue this issue was closed as a duplicate of. */
  closedAsDuplicateOf?: Maybe<Issue>;
  /** Timestamp of when the issue was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Indicates the issue is confidential. */
  confidential: Scalars['Boolean'];
  /** User specific email address for the issue. */
  createNoteEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the issue was created. */
  createdAt: Scalars['Time'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Customer relations contacts of the issue. */
  customerRelationsContacts?: Maybe<CustomerRelationsContactConnection>;
  /** Description of the issue. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Collection of design images associated with this issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Indicates discussion is locked on the issue. */
  discussionLocked: Scalars['Boolean'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the issue has received. */
  downvotes: Scalars['Int'];
  /** Due date of the issue. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Indicates if a project has email notifications disabled: `true` if email notifications are disabled. */
  emailsDisabled: Scalars['Boolean'];
  /** Epic to which this issue belongs. */
  epic?: Maybe<Epic>;
  /** ID of the epic-issue relation. */
  epicIssueId: Scalars['ID'];
  /** Escalation policy associated with the issue. Available for issues which support escalation. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
  /** Escalation status of the issue. */
  escalationStatus?: Maybe<IssueEscalationStatus>;
  /**
   * Indicates if the issue belongs to an epic.
   *             Can return true and not show an associated epic when the user has no access to the epic.
   */
  hasEpic: Scalars['Boolean'];
  /** Current health status. */
  healthStatus?: Maybe<HealthStatus>;
  /** Indicates the issue is hidden because the author has been banned. */
  hidden?: Maybe<Scalars['Boolean']>;
  /** Human-readable time estimate of the issue. */
  humanTimeEstimate?: Maybe<Scalars['String']>;
  /** Human-readable total time reported as spent on the issue. */
  humanTotalTimeSpent?: Maybe<Scalars['String']>;
  /** Global ID of the epic-issue relation. */
  id?: Maybe<Scalars['ID']>;
  /** Internal ID of the issue. */
  iid: Scalars['ID'];
  /** Issuable resource links of the incident issue. */
  issuableResourceLinks?: Maybe<IssuableResourceLinkConnection>;
  /** Iteration of the issue. */
  iteration?: Maybe<Iteration>;
  /** Labels of the issue. */
  labels?: Maybe<LabelConnection>;
  /** Number of merge requests that close the issue on merge. */
  mergeRequestsCount: Scalars['Int'];
  /** Metric images associated to the issue. */
  metricImages?: Maybe<Array<MetricImage>>;
  /** Milestone of the issue. */
  milestone?: Maybe<Milestone>;
  /** Indicates if issue got moved from other project. */
  moved?: Maybe<Scalars['Boolean']>;
  /** Updated Issue after it got moved to another project. */
  movedTo?: Maybe<Issue>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** List of participants in the issue. */
  participants?: Maybe<UserCoreConnection>;
  /** ID of the issue project. */
  projectId: Scalars['Int'];
  /** Internal reference of the issue. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** Merge requests related to the issue. This field can only be resolved for one issue in any single request. */
  relatedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Related vulnerabilities of the issue. */
  relatedVulnerabilities?: Maybe<VulnerabilityConnection>;
  /** URI path of the epic-issue relation. */
  relationPath?: Maybe<Scalars['String']>;
  /** Relative position of the issue (used for positioning in epic tree and issue boards). */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Severity level of the incident. */
  severity?: Maybe<IssuableSeverity>;
  /** Timestamp of when the issue SLA expires. */
  slaDueAt?: Maybe<Scalars['Time']>;
  /** State of the issue. */
  state: IssueState;
  /** Indicates whether an issue is published to the status page. */
  statusPagePublishedIncident?: Maybe<Scalars['Boolean']>;
  /** Indicates the currently logged in user is subscribed to the issue. */
  subscribed: Scalars['Boolean'];
  /** Task completion status of the issue. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the issue. */
  timeEstimate: Scalars['Int'];
  /** Timelogs on the issue. */
  timelogs: TimelogConnection;
  /** Title of the issue. */
  title: Scalars['String'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Total time reported as spent on the issue. */
  totalTimeSpent: Scalars['Int'];
  /** Type of the issue. */
  type?: Maybe<IssueType>;
  /** Timestamp of when the issue was last updated. */
  updatedAt: Scalars['Time'];
  /** User that last updated the issue. */
  updatedBy?: Maybe<UserCore>;
  /** Number of upvotes the issue has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the issue. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the issue. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: IssuePermissions;
  /** Web path of the issue. */
  webPath: Scalars['String'];
  /** Web URL of the issue. */
  webUrl: Scalars['String'];
  /** Weight of the issue. */
  weight?: Maybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueAlertManagementAlertsArgs = {
  after?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  domain?: AlertManagementDomainFilter;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


/** Relationship between an epic and an issue */
export type EpicIssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueBlockedByIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


/** Relationship between an epic and an issue */
export type EpicIssueCustomerRelationsContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueIssuableResourceLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  incidentId: Scalars['IssueID'];
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueRelatedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueRelatedVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Relationship between an epic and an issue */
export type EpicIssueTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for EpicIssue. */
export type EpicIssueConnection = {
  __typename?: 'EpicIssueConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total weight of issues collection. */
  weight: Scalars['Int'];
};

/** An edge in a connection. */
export type EpicIssueEdge = {
  __typename?: 'EpicIssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicIssue>;
};

/** Represents an epic board list */
export type EpicList = {
  __typename?: 'EpicList';
  /** Indicates if this list is collapsed for this user. */
  collapsed?: Maybe<Scalars['Boolean']>;
  /** List epics. */
  epics?: Maybe<EpicConnection>;
  /**
   * Count of epics in the list. Deprecated in 14.9: This was renamed.
   * @deprecated This was renamed. Please use `metadata`. Deprecated in 14.9.
   */
  epicsCount?: Maybe<Scalars['Int']>;
  /** Global ID of the board list. */
  id: Scalars['BoardsEpicListID'];
  /** Label of the list. */
  label?: Maybe<Label>;
  /** Type of the list. */
  listType: Scalars['String'];
  /** Epic list metatada. */
  metadata?: Maybe<EpicListMetadata>;
  /** Position of the list within the board. */
  position?: Maybe<Scalars['Int']>;
  /** Title of the list. */
  title: Scalars['String'];
};


/** Represents an epic board list */
export type EpicListEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<EpicFilters>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for EpicList. */
export type EpicListConnection = {
  __typename?: 'EpicListConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EpicListEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EpicList>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EpicListEdge = {
  __typename?: 'EpicListEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EpicList>;
};

/** Represents epic board list metadata */
export type EpicListMetadata = {
  __typename?: 'EpicListMetadata';
  /** Count of epics in the list. */
  epicsCount?: Maybe<Scalars['Int']>;
  /**
   * Total weight of all issues in the list. Introduced in 14.7: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 14.7.
   */
  totalWeight?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of EpicMoveList */
export type EpicMoveListInput = {
  /** Global ID of the board that the epic is in. */
  boardId: Scalars['BoardsEpicBoardID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the epic to mutate. */
  epicId: Scalars['EpicID'];
  /** ID of the board list that the epic will be moved from. Required if moving between lists. */
  fromListId?: InputMaybe<Scalars['BoardsEpicListID']>;
  /** ID of epic that should be placed after the current epic. */
  moveAfterId?: InputMaybe<Scalars['EpicID']>;
  /** ID of epic that should be placed before the current epic. */
  moveBeforeId?: InputMaybe<Scalars['EpicID']>;
  /** Position of epics within the board list. Positions start at 0. Use -1 to move to the end of the list. */
  positionInList?: InputMaybe<Scalars['Int']>;
  /** ID of the list the epic will be in after mutation. */
  toListId: Scalars['BoardsEpicListID'];
};

/** Autogenerated return type of EpicMoveList */
export type EpicMoveListPayload = {
  __typename?: 'EpicMoveListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Check permissions for the current user on an epic */
export type EpicPermissions = {
  __typename?: 'EpicPermissions';
  /** Indicates the user can perform `admin_epic` on this resource */
  adminEpic: Scalars['Boolean'];
  /** Indicates the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean'];
  /** Indicates the user can perform `create_epic` on this resource */
  createEpic: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_epic` on this resource */
  destroyEpic: Scalars['Boolean'];
  /** Indicates the user can perform `read_epic` on this resource */
  readEpic: Scalars['Boolean'];
  /** Indicates the user can perform `read_epic_iid` on this resource */
  readEpicIid: Scalars['Boolean'];
  /** Indicates the user can perform `update_epic` on this resource */
  updateEpic: Scalars['Boolean'];
};

/** Autogenerated input type of EpicSetSubscription */
export type EpicSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the epic to mutate belongs to. */
  groupPath: Scalars['ID'];
  /** IID of the epic to mutate. */
  iid: Scalars['ID'];
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean'];
};

/** Autogenerated return type of EpicSetSubscription */
export type EpicSetSubscriptionPayload = {
  __typename?: 'EpicSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Roadmap sort values */
export type EpicSort =
  /** Sort by created_at by ascending order. */
  | 'CREATED_AT_ASC'
  /** Sort by created_at by descending order. */
  | 'CREATED_AT_DESC'
  /** Sort by end date in ascending order. */
  | 'END_DATE_ASC'
  /** Sort by end date in descending order. */
  | 'END_DATE_DESC'
  /** Sort by start date in ascending order. */
  | 'START_DATE_ASC'
  /** Sort by start date in descending order. */
  | 'START_DATE_DESC'
  /** Sort by title in ascending order. */
  | 'TITLE_ASC'
  /** Sort by title in descending order. */
  | 'TITLE_DESC'
  /** Sort by updated_at by ascending order. */
  | 'UPDATED_AT_ASC'
  /** Sort by updated_at by descending order. */
  | 'UPDATED_AT_DESC'
  /** End date at ascending order. */
  | 'end_date_asc'
  /** End date at descending order. */
  | 'end_date_desc'
  /** Start date at ascending order. */
  | 'start_date_asc'
  /** Start date at descending order. */
  | 'start_date_desc';

/** State of an epic */
export type EpicState =
  /** All epics. */
  | 'all'
  /** Closed epics. */
  | 'closed'
  /** Open epics. */
  | 'opened';

/** State event of an epic */
export type EpicStateEvent =
  /** Close the epic. */
  | 'CLOSE'
  /** Reopen the epic. */
  | 'REOPEN';

/** A node of an epic tree. */
export type EpicTreeNodeFieldsInputType = {
  /** ID of the epic issue or issue the epic or issue is switched with. */
  adjacentReferenceId?: InputMaybe<Scalars['EpicTreeSortingID']>;
  /** ID of the epic issue or epic that is being moved. */
  id: Scalars['EpicTreeSortingID'];
  /** ID of the new parent epic. */
  newParentId?: InputMaybe<Scalars['EpicID']>;
  /** Type of switch. Valid values are `after` or `before`. */
  relativePosition?: InputMaybe<MoveType>;
};

/** Autogenerated input type of EpicTreeReorder */
export type EpicTreeReorderInput = {
  /** ID of the base epic of the tree. */
  baseEpicId: Scalars['EpicID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Parameters for updating the tree positions. */
  moved: EpicTreeNodeFieldsInputType;
};

/** Autogenerated return type of EpicTreeReorder */
export type EpicTreeReorderPayload = {
  __typename?: 'EpicTreeReorderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Epic ID wildcard values */
export type EpicWildcardId =
  /** Any epic is assigned. */
  | 'ANY'
  /** No epic is assigned. */
  | 'NONE';

/** Autogenerated input type of EscalationPolicyCreate */
export type EscalationPolicyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the escalation policy. */
  description?: InputMaybe<Scalars['String']>;
  /** Name of the escalation policy. */
  name: Scalars['String'];
  /** Project to create the escalation policy for. */
  projectPath: Scalars['ID'];
  /** Steps of the escalation policy. */
  rules: Array<EscalationRuleInput>;
};

/** Autogenerated return type of EscalationPolicyCreate */
export type EscalationPolicyCreatePayload = {
  __typename?: 'EscalationPolicyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Autogenerated input type of EscalationPolicyDestroy */
export type EscalationPolicyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Escalation policy internal ID to remove. */
  id: Scalars['IncidentManagementEscalationPolicyID'];
};

/** Autogenerated return type of EscalationPolicyDestroy */
export type EscalationPolicyDestroyPayload = {
  __typename?: 'EscalationPolicyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Represents an escalation policy */
export type EscalationPolicyType = {
  __typename?: 'EscalationPolicyType';
  /** Description of the escalation policy. */
  description?: Maybe<Scalars['String']>;
  /** ID of the escalation policy. */
  id?: Maybe<Scalars['IncidentManagementEscalationPolicyID']>;
  /** Name of the escalation policy. */
  name?: Maybe<Scalars['String']>;
  /** Steps of the escalation policy. */
  rules?: Maybe<Array<EscalationRuleType>>;
};

/** The connection type for EscalationPolicyType. */
export type EscalationPolicyTypeConnection = {
  __typename?: 'EscalationPolicyTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EscalationPolicyTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EscalationPolicyType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EscalationPolicyTypeEdge = {
  __typename?: 'EscalationPolicyTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EscalationPolicyType>;
};

/** Autogenerated input type of EscalationPolicyUpdate */
export type EscalationPolicyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the escalation policy. */
  description?: InputMaybe<Scalars['String']>;
  /** ID of the on-call schedule to create the on-call rotation in. */
  id: Scalars['IncidentManagementEscalationPolicyID'];
  /** Name of the escalation policy. */
  name?: InputMaybe<Scalars['String']>;
  /** Steps of the escalation policy. */
  rules?: InputMaybe<Array<EscalationRuleInput>>;
};

/** Autogenerated return type of EscalationPolicyUpdate */
export type EscalationPolicyUpdatePayload = {
  __typename?: 'EscalationPolicyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Escalation policy. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
};

/** Represents an escalation rule */
export type EscalationRuleInput = {
  /** Time in seconds before the rule is activated. */
  elapsedTimeSeconds: Scalars['Int'];
  /** On-call schedule to notify. */
  oncallScheduleIid?: InputMaybe<Scalars['ID']>;
  /** Status required to prevent the rule from activating. */
  status: EscalationRuleStatus;
  /** Username of the user to notify. */
  username?: InputMaybe<Scalars['String']>;
};

/** Escalation rule statuses */
export type EscalationRuleStatus =
  /** . */
  | 'ACKNOWLEDGED'
  /** . */
  | 'RESOLVED';

/** Represents an escalation rule for an escalation policy */
export type EscalationRuleType = {
  __typename?: 'EscalationRuleType';
  /** Time in seconds before the rule is activated. */
  elapsedTimeSeconds?: Maybe<Scalars['Int']>;
  /** ID of the escalation policy. */
  id?: Maybe<Scalars['IncidentManagementEscalationRuleID']>;
  /** On-call schedule to notify. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
  /** Status required to prevent the rule from activating. */
  status?: Maybe<EscalationRuleStatus>;
  /** User to notify. */
  user?: Maybe<UserCore>;
};

/** Representing an event */
export type Event = {
  __typename?: 'Event';
  /** Action of the event. */
  action: EventAction;
  /** Author of this event. */
  author: UserCore;
  /** When this event was created. */
  createdAt: Scalars['Time'];
  /** ID of the event. */
  id: Scalars['ID'];
  /** When this event was updated. */
  updatedAt: Scalars['Time'];
};

/** Event action */
export type EventAction =
  /** Approved action */
  | 'APPROVED'
  /** Closed action */
  | 'CLOSED'
  /** Commented action */
  | 'COMMENTED'
  /** Created action */
  | 'CREATED'
  /** Destroyed action */
  | 'DESTROYED'
  /** Expired action */
  | 'EXPIRED'
  /** Joined action */
  | 'JOINED'
  /** Left action */
  | 'LEFT'
  /** Merged action */
  | 'MERGED'
  /** Pushed action */
  | 'PUSHED'
  /** Reopened action */
  | 'REOPENED'
  /** Updated action */
  | 'UPDATED';

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Event>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

export type Eventable = {
  /** List of events associated with the object. */
  events?: Maybe<EventConnection>;
};


export type EventableEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ExplainVulnerabilityPrompt = {
  __typename?: 'ExplainVulnerabilityPrompt';
  /** AI text prompt generated using the vulnerability's information, including the vulnerable code. */
  promptWithCode?: Maybe<Scalars['String']>;
  /** AI text prompt generated using the vulnerability's information, excluding the vulnerable code. */
  promptWithoutCode?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ExportRequirements */
export type ExportRequirementsInput = {
  /** Filter requirements by author username. */
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full project path the requirements are associated with. */
  projectPath: Scalars['ID'];
  /** Search query for requirement title. */
  search?: InputMaybe<Scalars['String']>;
  /** List of selected requirements fields to be exported. */
  selectedFields?: InputMaybe<Array<Scalars['String']>>;
  /** List requirements by sort order. */
  sort?: InputMaybe<Sort>;
  /** Filter requirements by state. */
  state?: InputMaybe<RequirementState>;
};

/** Autogenerated return type of ExportRequirements */
export type ExportRequirementsPayload = {
  __typename?: 'ExportRequirementsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Represents an external resource to send audit events to */
export type ExternalAuditEventDestination = ExternalAuditEventDestinationInterface & {
  __typename?: 'ExternalAuditEventDestination';
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String'];
  /** List of event type filters added for streaming. */
  eventTypeFilters: Array<Scalars['String']>;
  /** Group the destination belongs to. */
  group: Group;
  /** List of additional HTTP headers sent with each event. */
  headers: AuditEventStreamingHeaderConnection;
  /** ID of the destination. */
  id: Scalars['ID'];
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String'];
};


/** Represents an external resource to send audit events to */
export type ExternalAuditEventDestinationHeadersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ExternalAuditEventDestination. */
export type ExternalAuditEventDestinationConnection = {
  __typename?: 'ExternalAuditEventDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalAuditEventDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalAuditEventDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ExternalAuditEventDestinationCreate */
export type ExternalAuditEventDestinationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination URL. */
  destinationUrl: Scalars['String'];
  /** Group path. */
  groupPath: Scalars['ID'];
  /** Verification token. */
  verificationToken?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ExternalAuditEventDestinationCreate */
export type ExternalAuditEventDestinationCreatePayload = {
  __typename?: 'ExternalAuditEventDestinationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Destination created. */
  externalAuditEventDestination?: Maybe<ExternalAuditEventDestination>;
};

/** Autogenerated input type of ExternalAuditEventDestinationDestroy */
export type ExternalAuditEventDestinationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of external audit event destination to destroy. */
  id: Scalars['AuditEventsExternalAuditEventDestinationID'];
};

/** Autogenerated return type of ExternalAuditEventDestinationDestroy */
export type ExternalAuditEventDestinationDestroyPayload = {
  __typename?: 'ExternalAuditEventDestinationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type ExternalAuditEventDestinationEdge = {
  __typename?: 'ExternalAuditEventDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalAuditEventDestination>;
};

export type ExternalAuditEventDestinationInterface = {
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String'];
  /** ID of the destination. */
  id: Scalars['ID'];
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String'];
};

/** Autogenerated input type of ExternalAuditEventDestinationUpdate */
export type ExternalAuditEventDestinationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination URL to change. */
  destinationUrl?: InputMaybe<Scalars['String']>;
  /** ID of external audit event destination to update. */
  id: Scalars['AuditEventsExternalAuditEventDestinationID'];
};

/** Autogenerated return type of ExternalAuditEventDestinationUpdate */
export type ExternalAuditEventDestinationUpdatePayload = {
  __typename?: 'ExternalAuditEventDestinationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated destination. */
  externalAuditEventDestination?: Maybe<ExternalAuditEventDestination>;
};

/** Represents an external issue */
export type ExternalIssue = {
  __typename?: 'ExternalIssue';
  /** Timestamp of when the issue was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Type of external tracker. */
  externalTracker?: Maybe<Scalars['String']>;
  /** Relative reference of the issue in the external tracker. */
  relativeReference?: Maybe<Scalars['String']>;
  /** Status of the issue in the external tracker. */
  status?: Maybe<Scalars['String']>;
  /** Title of the issue in the external tracker. */
  title?: Maybe<Scalars['String']>;
  /** Timestamp of when the issue was updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** URL to the issue in the external tracker. */
  webUrl?: Maybe<Scalars['String']>;
};

/** Describes an external status check. */
export type ExternalStatusCheck = {
  __typename?: 'ExternalStatusCheck';
  /** External URL for the status check. */
  externalUrl: Scalars['String'];
  /** ID of the rule. */
  id: Scalars['GlobalID'];
  /** Name of the rule. */
  name: Scalars['String'];
};

/** The connection type for ExternalStatusCheck. */
export type ExternalStatusCheckConnection = {
  __typename?: 'ExternalStatusCheckConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalStatusCheckEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalStatusCheck>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ExternalStatusCheckEdge = {
  __typename?: 'ExternalStatusCheckEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalStatusCheck>;
};

export type FileUpload = {
  __typename?: 'FileUpload';
  /** Global ID of the upload. */
  id: Scalars['UploadID'];
  /** Path of the upload. */
  path: Scalars['String'];
  /** Size of the upload in bytes. */
  size: Scalars['Int'];
};

/** Represents security reports comparison for vulnerability findings. */
export type FindingReportsComparer = {
  __typename?: 'FindingReportsComparer';
  /**
   * Compared security report. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  report?: Maybe<ComparedSecurityReport>;
  /** Comparison status. */
  status?: Maybe<FindingReportsComparerStatus>;
  /** Text explaining the status. */
  statusReason?: Maybe<Scalars['String']>;
};

/** Report comparison status */
export type FindingReportsComparerStatus =
  /** An error happened while generating the report. */
  | 'ERROR'
  /** Report was generated. */
  | 'PARSED'
  /** Report is being generated. */
  | 'PARSING';

/** Information about specific forecast created */
export type Forecast = {
  __typename?: 'Forecast';
  /** Status of the forecast. */
  status: ForecastStatus;
  /** Actual forecast values. */
  values?: Maybe<ForecastDatapointConnection>;
};


/** Information about specific forecast created */
export type ForecastValuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Information about specific forecast datapoint */
export type ForecastDatapoint = {
  __typename?: 'ForecastDatapoint';
  /** Datapoint of the forecast. Usually a date. */
  datapoint: Scalars['String'];
  /** Value of the given datapoint. */
  value?: Maybe<Scalars['Float']>;
};

/** The connection type for ForecastDatapoint. */
export type ForecastDatapointConnection = {
  __typename?: 'ForecastDatapointConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ForecastDatapointEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ForecastDatapoint>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ForecastDatapointEdge = {
  __typename?: 'ForecastDatapointEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ForecastDatapoint>;
};

/** List of statuses for forecasting model. */
export type ForecastStatus =
  /** Forecast is ready. */
  | 'READY'
  /** Forecast is unavailable. */
  | 'UNAVAILABLE';

/** Details of the fork project compared to its upstream project. */
export type ForkDetails = {
  __typename?: 'ForkDetails';
  /** Number of commits ahead of upstream. */
  ahead?: Maybe<Scalars['Int']>;
  /** Number of commits behind upstream. */
  behind?: Maybe<Scalars['Int']>;
  /** Indicates if the fork conflicts with its upstream project. */
  hasConflicts?: Maybe<Scalars['Boolean']>;
  /** Indicates if there is a synchronization in progress. */
  isSyncing?: Maybe<Scalars['Boolean']>;
};

export type GenerateTestFileInput = {
  /** File path to generate test files for. */
  filePath: Scalars['String'];
  /** Global ID of the resource to mutate. */
  resourceId: Scalars['AiModelID'];
};

export type GeoNode = {
  __typename?: 'GeoNode';
  /** Find Ci Secure File registries on this Geo node */
  ciSecureFileRegistries?: Maybe<CiSecureFileRegistryConnection>;
  /** Maximum concurrency of container repository sync for this secondary node. */
  containerRepositoriesMaxCapacity?: Maybe<Scalars['Int']>;
  /** Find Container Repository registries on this Geo node. */
  containerRepositoryRegistries?: Maybe<ContainerRepositoryRegistryConnection>;
  /**
   * Find Dependency Proxy Blob registries on this Geo node. Introduced in 15.6:
   * This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.
   */
  dependencyProxyBlobRegistries?: Maybe<DependencyProxyBlobRegistryConnection>;
  /** Find Dependency Proxy Manifest registries on this Geo node. */
  dependencyProxyManifestRegistries?: Maybe<DependencyProxyManifestRegistryConnection>;
  /**
   * Find Design Repository registries on this Geo node. Ignored if
   * `geo_design_management_repository_replication` feature flag is disabled.
   * Introduced in 16.1: This feature is an Experiment. It can be changed or
   * removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  designManagementRepositoryRegistries?: Maybe<DesignManagementRepositoryRegistryConnection>;
  /** Indicates whether this Geo node is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Maximum concurrency of LFS/attachment backfill for this secondary node. */
  filesMaxCapacity?: Maybe<Scalars['Int']>;
  /** Find group wiki repository registries on this Geo node. */
  groupWikiRepositoryRegistries?: Maybe<GroupWikiRepositoryRegistryConnection>;
  /** ID of this GeoNode. */
  id: Scalars['ID'];
  /** URL defined on the primary node secondary nodes should use to contact it. */
  internalUrl?: Maybe<Scalars['String']>;
  /** Find Job Artifact registries on this Geo node. */
  jobArtifactRegistries?: Maybe<JobArtifactRegistryConnection>;
  /** Find LFS object registries on this Geo node. */
  lfsObjectRegistries?: Maybe<LfsObjectRegistryConnection>;
  /** Find merge request diff registries on this Geo node. */
  mergeRequestDiffRegistries?: Maybe<MergeRequestDiffRegistryConnection>;
  /** Interval (in days) in which the repository verification is valid. After expiry, it is reverted. */
  minimumReverificationInterval?: Maybe<Scalars['Int']>;
  /** Unique identifier for this Geo node. */
  name?: Maybe<Scalars['String']>;
  /** Package file registries of the GeoNode. */
  packageFileRegistries?: Maybe<PackageFileRegistryConnection>;
  /** Find Pages Deployment registries on this Geo node */
  pagesDeploymentRegistries?: Maybe<PagesDeploymentRegistryConnection>;
  /** Find pipeline artifact registries on this Geo node. */
  pipelineArtifactRegistries?: Maybe<PipelineArtifactRegistryConnection>;
  /** Indicates whether this Geo node is the primary. */
  primary?: Maybe<Scalars['Boolean']>;
  /**
   * Find Project Wiki Repository registries on this Geo node. Ignored if
   * `geo_project_wiki_repository_replication` feature flag is disabled.
   */
  projectWikiRepositoryRegistries?: Maybe<ProjectWikiRepositoryRegistryConnection>;
  /** Maximum concurrency of repository backfill for this secondary node. */
  reposMaxCapacity?: Maybe<Scalars['Int']>;
  /** Namespaces that should be synced, if `selective_sync_type` == `namespaces`. */
  selectiveSyncNamespaces?: Maybe<NamespaceConnection>;
  /** Repository storages whose projects should be synced, if `selective_sync_type` == `shards`. */
  selectiveSyncShards?: Maybe<Array<Scalars['String']>>;
  /** Indicates if syncing is limited to only specific groups, or shards. */
  selectiveSyncType?: Maybe<Scalars['String']>;
  /** Find snippet repository registries on this Geo node. */
  snippetRepositoryRegistries?: Maybe<SnippetRepositoryRegistryConnection>;
  /** Indicates if this secondary node will replicate blobs in Object Storage. */
  syncObjectStorage?: Maybe<Scalars['Boolean']>;
  /** Find terraform state version registries on this Geo node. */
  terraformStateVersionRegistries?: Maybe<TerraformStateVersionRegistryConnection>;
  /** Find Upload registries on this Geo node */
  uploadRegistries?: Maybe<UploadRegistryConnection>;
  /** User-facing URL for this Geo node. */
  url?: Maybe<Scalars['String']>;
  /** Maximum concurrency of repository verification for this secondary node. */
  verificationMaxCapacity?: Maybe<Scalars['Int']>;
};


export type GeoNodeCiSecureFileRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeContainerRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeDependencyProxyBlobRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeDependencyProxyManifestRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeDesignManagementRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeGroupWikiRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeJobArtifactRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeLfsObjectRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeMergeRequestDiffRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePackageFileRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePagesDeploymentRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodePipelineArtifactRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeProjectWikiRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeSelectiveSyncNamespacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GeoNodeSnippetRepositoryRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeTerraformStateVersionRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};


export type GeoNodeUploadRegistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  keyword?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  replicationState?: InputMaybe<ReplicationStateEnum>;
  verificationState?: InputMaybe<VerificationStateEnum>;
};

/** Autogenerated input type of GeoRegistriesUpdate */
export type GeoRegistriesUpdateInput = {
  /** Action to be executed on a Geo registry. */
  action: GeoRegistryAction;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Class of the Geo registry to be updated. */
  registryClass: GeoRegistryClass;
  /** ID of the Geo registry entry to be updated. */
  registryId: Scalars['GeoBaseRegistryID'];
};

/** Autogenerated return type of GeoRegistriesUpdate */
export type GeoRegistriesUpdatePayload = {
  __typename?: 'GeoRegistriesUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated Geo registry entry. */
  registry?: Maybe<Registrable>;
};

/** Action to trigger on one or more Geo registries */
export type GeoRegistryAction =
  /** Resync a registry. */
  | 'RESYNC'
  /** Reverify a registry. */
  | 'REVERIFY';

/** Geo registry class */
export type GeoRegistryClass =
  /** Geo::CiSecureFileRegistry registry class */
  | 'CI_SECURE_FILE_REGISTRY'
  /** Geo::ContainerRepositoryRegistry registry class */
  | 'CONTAINER_REPOSITORY_REGISTRY'
  /** Geo::DependencyProxyBlobRegistry registry class */
  | 'DEPENDENCY_PROXY_BLOB_REGISTRY'
  /** Geo::DependencyProxyManifestRegistry registry class */
  | 'DEPENDENCY_PROXY_MANIFEST_REGISTRY'
  /** Geo::DesignManagementRepositoryRegistry registry class */
  | 'DESIGN_MANAGEMENT_REPOSITORY_REGISTRY'
  /** Geo::JobArtifactRegistry registry class */
  | 'JOB_ARTIFACT_REGISTRY'
  /** Geo::LfsObjectRegistry registry class */
  | 'LFS_OBJECT_REGISTRY'
  /** Geo::MergeRequestDiffRegistry registry class */
  | 'MERGE_REQUEST_DIFF_REGISTRY'
  /** Geo::PackageFileRegistry registry class */
  | 'PACKAGE_FILE_REGISTRY'
  /** Geo::PagesDeploymentRegistry registry class */
  | 'PAGES_DEPLOYMENT_REGISTRY'
  /** Geo::PipelineArtifactRegistry registry class */
  | 'PIPELINE_ARTIFACT_REGISTRY'
  /** Geo::ProjectWikiRepositoryRegistry registry class */
  | 'PROJECT_WIKI_REPOSITORY_REGISTRY'
  /** Geo::SnippetRepositoryRegistry registry class */
  | 'SNIPPET_REPOSITORY_REGISTRY'
  /** Geo::TerraformStateVersionRegistry registry class */
  | 'TERRAFORM_STATE_VERSION_REGISTRY'
  /** Geo::UploadRegistry registry class */
  | 'UPLOAD_REGISTRY';

/** Autogenerated input type of GitlabSubscriptionActivate */
export type GitlabSubscriptionActivateInput = {
  /** Activation code received after purchasing a GitLab subscription. */
  activationCode: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of GitlabSubscriptionActivate */
export type GitlabSubscriptionActivatePayload = {
  __typename?: 'GitlabSubscriptionActivatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Array of future subscriptions. */
  futureSubscriptions?: Maybe<Array<SubscriptionFutureEntry>>;
  /** Current license. */
  license?: Maybe<CurrentLicense>;
};

/** Role of User */
export type GitlabSubscriptionsUserRole =
  /** Developer. */
  | 'DEVELOPER'
  /** Guest. */
  | 'GUEST'
  /** Maintainer. */
  | 'MAINTAINER'
  /** Owner. */
  | 'OWNER'
  /** Reporter. */
  | 'REPORTER';

/** Autogenerated input type of GoogleCloudLoggingConfigurationCreate */
export type GoogleCloudLoggingConfigurationCreateInput = {
  /**
   * Email address associated with the service account that will be used to
   * authenticate and interact with the Google Cloud Logging service. This is part
   * of the IAM credentials.
   */
  clientEmail: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Unique identifier of the Google Cloud project to which the logging configuration belongs. */
  googleProjectIdName: Scalars['String'];
  /** Group path. */
  groupPath: Scalars['ID'];
  /**
   * Unique identifier used to distinguish and manage different logs within the
   * same Google Cloud project.(defaults to `audit_events`).
   */
  logIdName?: InputMaybe<Scalars['String']>;
  /**
   * Private Key associated with the service account. This key is used to
   * authenticate the service account and authorize it to interact with the Google
   * Cloud Logging service.
   */
  privateKey: Scalars['String'];
};

/** Autogenerated return type of GoogleCloudLoggingConfigurationCreate */
export type GoogleCloudLoggingConfigurationCreatePayload = {
  __typename?: 'GoogleCloudLoggingConfigurationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** configuration created. */
  googleCloudLoggingConfiguration?: Maybe<GoogleCloudLoggingConfigurationType>;
};

/** Autogenerated input type of GoogleCloudLoggingConfigurationDestroy */
export type GoogleCloudLoggingConfigurationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the Google Cloud logging configuration to destroy. */
  id: Scalars['AuditEventsGoogleCloudLoggingConfigurationID'];
};

/** Autogenerated return type of GoogleCloudLoggingConfigurationDestroy */
export type GoogleCloudLoggingConfigurationDestroyPayload = {
  __typename?: 'GoogleCloudLoggingConfigurationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Stores Google Cloud Logging configurations associated with IAM service accounts,used for generating access tokens. */
export type GoogleCloudLoggingConfigurationType = {
  __typename?: 'GoogleCloudLoggingConfigurationType';
  /** Client email. */
  clientEmail: Scalars['String'];
  /** Google project ID. */
  googleProjectIdName: Scalars['String'];
  /** Group the configuration belongs to. */
  group: Group;
  /** ID of the configuration. */
  id: Scalars['ID'];
  /** Log ID. */
  logIdName: Scalars['String'];
  /** Private key. */
  privateKey: Scalars['String'];
};

/** The connection type for GoogleCloudLoggingConfigurationType. */
export type GoogleCloudLoggingConfigurationTypeConnection = {
  __typename?: 'GoogleCloudLoggingConfigurationTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GoogleCloudLoggingConfigurationTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GoogleCloudLoggingConfigurationType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GoogleCloudLoggingConfigurationTypeEdge = {
  __typename?: 'GoogleCloudLoggingConfigurationTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GoogleCloudLoggingConfigurationType>;
};

/** Autogenerated input type of GoogleCloudLoggingConfigurationUpdate */
export type GoogleCloudLoggingConfigurationUpdateInput = {
  /**
   * Email address associated with the service account that will be used to
   * authenticate and interact with the Google Cloud Logging service. This is part
   * of the IAM credentials.
   */
  clientEmail?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Unique identifier of the Google Cloud project to which the logging configuration belongs. */
  googleProjectIdName?: InputMaybe<Scalars['String']>;
  /** ID of the google Cloud configuration to update. */
  id: Scalars['AuditEventsGoogleCloudLoggingConfigurationID'];
  /** Unique identifier used to distinguish and manage different logs within the same Google Cloud project. */
  logIdName?: InputMaybe<Scalars['String']>;
  /**
   * Private Key associated with the service account. This key is used to
   * authenticate the service account and authorize it to interact with the Google
   * Cloud Logging service.
   */
  privateKey?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of GoogleCloudLoggingConfigurationUpdate */
export type GoogleCloudLoggingConfigurationUpdatePayload = {
  __typename?: 'GoogleCloudLoggingConfigurationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** configuration updated. */
  googleCloudLoggingConfiguration?: Maybe<GoogleCloudLoggingConfigurationType>;
};

/** GPG signature for a signed commit */
export type GpgSignature = CommitSignature & {
  __typename?: 'GpgSignature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** ID of the GPG key. */
  gpgKeyPrimaryKeyid?: Maybe<Scalars['String']>;
  /** User email associated with the GPG key. */
  gpgKeyUserEmail?: Maybe<Scalars['String']>;
  /** User name associated with the GPG key. */
  gpgKeyUserName?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

export type GrafanaIntegration = {
  __typename?: 'GrafanaIntegration';
  /** Timestamp of the issue's creation. */
  createdAt: Scalars['Time'];
  /** Indicates whether Grafana integration is enabled. */
  enabled: Scalars['Boolean'];
  /** URL for the Grafana host for the Grafana integration. */
  grafanaUrl: Scalars['String'];
  /** Internal ID of the Grafana integration. */
  id: Scalars['ID'];
  /** Timestamp of the issue's last activity. */
  updatedAt: Scalars['Time'];
};

export type Group = {
  __typename?: 'Group';
  /**
   * Achievements for the namespace. Returns `null` if the `achievements` feature
   * flag is disabled. Introduced in 15.8: This feature is an Experiment. It can be
   * changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  achievements?: Maybe<AchievementConnection>;
  /**
   * Size limit for repositories in the namespace in bytes. This limit only applies
   * to namespaces under Project limit enforcement.
   */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']>;
  /** Actual storage size limit for the namespace in bytes. This limit is agnostic of enforcement type. */
  actualSizeLimit?: Maybe<Scalars['Float']>;
  /** Additional storage purchased for the root namespace in bytes. */
  additionalPurchasedStorageSize?: Maybe<Scalars['Float']>;
  /** Indicates whether to regularly prune stale group runners. Defaults to false. */
  allowStaleRunnerPruning: Scalars['Boolean'];
  /** Indicates whether Auto DevOps is enabled for all projects within this group. */
  autoDevopsEnabled?: Maybe<Scalars['Boolean']>;
  /** Avatar URL of the group. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Number of billable users in the group. */
  billableMembersCount?: Maybe<Scalars['Int']>;
  /** A single board of the group. */
  board?: Maybe<Board>;
  /** Boards of the group. */
  boards?: Maybe<BoardConnection>;
  /** List of the group's CI/CD variables. */
  ciVariables?: Maybe<CiGroupVariableConnection>;
  /** Cluster agents associated with projects in the group and its subgroups. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Represents the code coverage activity for this group. */
  codeCoverageActivities?: Maybe<CodeCoverageActivityConnection>;
  /** Compliance frameworks available to projects in this namespace. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /** Counts of contacts by state for the group. */
  contactStateCounts?: Maybe<ContactStateCounts>;
  /** Find contacts of this group. */
  contacts?: Maybe<CustomerRelationsContactConnection>;
  /** Container repositories of the group. */
  containerRepositories?: Maybe<ContainerRepositoryConnection>;
  /** Number of container repositories in the group. */
  containerRepositoriesCount: Scalars['Int'];
  /**
   * Includes at least one project where the repository size exceeds the limit.
   * This only applies to namespaces under Project limit enforcement.
   */
  containsLockedProjects: Scalars['Boolean'];
  /** Provides the aggregated contributions by users within the group and its subgroups */
  contributions?: Maybe<ContributionAnalyticsContributionConnection>;
  /** Indicates if the cross_project_pipeline feature is available for the namespace. */
  crossProjectPipelineAvailable: Scalars['Boolean'];
  /**
   * Custom emoji within this namespace. Introduced in 13.6: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 13.6.
   */
  customEmoji?: Maybe<CustomEmojiConnection>;
  /** Data transfer data point for a specific period. This is mocked data under a development feature flag. */
  dataTransfer?: Maybe<GroupDataTransfer>;
  /** Number of dependency proxy blobs cached in the group. */
  dependencyProxyBlobCount: Scalars['Int'];
  /** Dependency Proxy blobs. */
  dependencyProxyBlobs?: Maybe<DependencyProxyBlobConnection>;
  /** Number of dependency proxy images cached in the group. */
  dependencyProxyImageCount: Scalars['Int'];
  /** Prefix for pulling images when using the dependency proxy. */
  dependencyProxyImagePrefix: Scalars['String'];
  /** Dependency proxy TTL policy for the group. */
  dependencyProxyImageTtlPolicy?: Maybe<DependencyProxyImageTtlGroupPolicy>;
  /** Dependency Proxy manifests. */
  dependencyProxyManifests?: Maybe<DependencyProxyManifestConnection>;
  /** Dependency Proxy settings for the group. */
  dependencyProxySetting?: Maybe<DependencyProxySetting>;
  /** Total size of the dependency proxy cached images. */
  dependencyProxyTotalSize: Scalars['String'];
  /** Total size of the dependency proxy cached images in bytes, encoded as a string. */
  dependencyProxyTotalSizeBytes: Scalars['BigInt'];
  /**
   * Total size of the dependency proxy cached images in bytes. Deprecated in 16.1: Use `dependencyProxyTotalSizeBytes`.
   * @deprecated Use `dependencyProxyTotalSizeBytes`. Deprecated in 16.1.
   */
  dependencyProxyTotalSizeInBytes: Scalars['Int'];
  /** List of descendant groups of this group. */
  descendantGroups?: Maybe<GroupConnection>;
  /** Description of the namespace. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Group's DORA metrics. */
  dora?: Maybe<Dora>;
  /** Group's DORA scores for all projects by DORA key metric for the last complete month. */
  doraPerformanceScoreCounts?: Maybe<DoraPerformanceScoreCountConnection>;
  /** Indicates if a group has email notifications disabled. */
  emailsDisabled?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the group has limited users for a free plan. */
  enforceFreeUserCap?: Maybe<Scalars['Boolean']>;
  /** Environment scopes of the group. */
  environmentScopes?: Maybe<CiGroupEnvironmentScopeConnection>;
  /** Find a single epic. */
  epic?: Maybe<Epic>;
  /** Find a single epic board. */
  epicBoard?: Maybe<EpicBoard>;
  /** Find epic boards. */
  epicBoards?: Maybe<EpicBoardConnection>;
  /** Find epics. */
  epics?: Maybe<EpicConnection>;
  /** Indicates if Epics are enabled for namespace */
  epicsEnabled?: Maybe<Scalars['Boolean']>;
  /** External locations that receive audit events belonging to the group. */
  externalAuditEventDestinations?: Maybe<ExternalAuditEventDestinationConnection>;
  /**
   * Flow metrics for value stream analytics. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  flowMetrics?: Maybe<GroupValueStreamAnalyticsFlowMetrics>;
  /** Full name of the namespace. */
  fullName: Scalars['String'];
  /** Full path of the namespace. */
  fullPath: Scalars['ID'];
  /** Preview Billable User Changes */
  gitlabSubscriptionsPreviewBillableUserChange?: Maybe<PreviewBillableUserChange>;
  /** Google Cloud logging configurations that receive audit events belonging to the group. */
  googleCloudLoggingConfigurations?: Maybe<GoogleCloudLoggingConfigurationTypeConnection>;
  /** A membership of a user within this group. */
  groupMembers?: Maybe<GroupMemberConnection>;
  /** ID of the namespace. */
  id: Scalars['ID'];
  /** Status of the temporary storage increase. */
  isTemporaryStorageIncreaseEnabled: Scalars['Boolean'];
  /** Issues for projects in this group. */
  issues?: Maybe<IssueConnection>;
  /** Find iteration cadences. */
  iterationCadences?: Maybe<IterationCadenceConnection>;
  /** Find iterations. */
  iterations?: Maybe<IterationConnection>;
  /** Label available on this group. */
  label?: Maybe<Label>;
  /** Labels available on this group. */
  labels?: Maybe<LabelConnection>;
  /** Indicates if Large File Storage (LFS) is enabled for namespace. */
  lfsEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if a group is disabled from getting mentioned. */
  mentionsDisabled?: Maybe<Scalars['Boolean']>;
  /** Compliance violations reported on merge requests merged within the group. */
  mergeRequestViolations?: Maybe<ComplianceViolationConnection>;
  /** Merge requests for projects in this group. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Milestones of the group. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the namespace. */
  name: Scalars['String'];
  /** Counts of organizations by status for the group. */
  organizationStateCounts?: Maybe<OrganizationStateCounts>;
  /** Find organizations of this group. */
  organizations?: Maybe<CustomerRelationsOrganizationConnection>;
  /** Package settings for the namespace. */
  packageSettings?: Maybe<PackageSettings>;
  /** Packages of the group. This field can only be resolved for one group in any single request. */
  packages?: Maybe<PackageConnection>;
  /** Parent group. */
  parent?: Maybe<Group>;
  /** Path of the namespace. */
  path: Scalars['String'];
  /** Permission level required to create projects in the group. */
  projectCreationLevel?: Maybe<Scalars['String']>;
  /** Projects within this namespace. */
  projects: ProjectConnection;
  /** List of recently visited boards of the group. Maximum size is 4. */
  recentIssueBoards?: Maybe<BoardConnection>;
  /** Releases belonging to projects in the group. */
  releases?: Maybe<ReleaseConnection>;
  /**
   * Number of projects in the root namespace where the repository size exceeds the
   * limit. This only applies to namespaces under Project limit enforcement.
   */
  repositorySizeExcessProjectCount: Scalars['Int'];
  /** Indicates if users can request access to namespace. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates if all users in this group are required to set up two-factor authentication. */
  requireTwoFactorAuthentication?: Maybe<Scalars['Boolean']>;
  /** Aggregated storage statistics of the namespace. Only available for root namespaces. */
  rootStorageStatistics?: Maybe<RootStorageStatistics>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** Scan Execution Policies of the namespace. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the project */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Indicates if sharing a project with another group within this group is prevented. */
  shareWithGroupLock?: Maybe<Scalars['Boolean']>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: Maybe<SharedRunnersSetting>;
  /** Group statistics. */
  stats?: Maybe<GroupStats>;
  /**
   * Storage limit included in the root namespace plan in bytes. This limit only
   * applies to namespaces under Namespace limit enforcement.
   */
  storageSizeLimit?: Maybe<Scalars['Float']>;
  /** Permission level required to create subgroups within the group. */
  subgroupCreationLevel?: Maybe<Scalars['String']>;
  /** Date until the temporary storage increase is active. */
  temporaryStorageIncreaseEndsOn?: Maybe<Scalars['Time']>;
  /**
   * Timelog categories for the namespace. Introduced in 15.3: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Time logged on issues and merge requests in the group and its subgroups. */
  timelogs: TimelogConnection;
  /** Total repository size of all projects in the root namespace in bytes. */
  totalRepositorySize?: Maybe<Scalars['Float']>;
  /**
   * Total excess repository size of all projects in the root namespace in bytes.
   * This only applies to namespaces under Project limit enforcement.
   */
  totalRepositorySizeExcess?: Maybe<Scalars['Float']>;
  /** Time before two-factor authentication is enforced. */
  twoFactorGracePeriod?: Maybe<Scalars['Int']>;
  /** Permissions for the current user on the resource */
  userPermissions: GroupPermissions;
  /** Visibility of the namespace. */
  visibility?: Maybe<Scalars['String']>;
  /** Vulnerabilities reported on the projects in the group and its subgroups. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the projects in the group and its subgroups. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Represents vulnerable project counts for each grade. */
  vulnerabilityGrades?: Maybe<Array<VulnerableProjectsByGrade>>;
  /** Vulnerability scanners reported on the project vulnerabilities of the group and its subgroups. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity in the group and its subgroups. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
  /** Web URL of the group. */
  webUrl: Scalars['String'];
  /** Work item types available to the group. */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
};


export type GroupAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['AchievementsAchievementID']>>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupBillableMembersCountArgs = {
  requestedHostedPlan?: InputMaybe<Scalars['String']>;
};


export type GroupBoardArgs = {
  id: Scalars['BoardID'];
};


export type GroupBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['BoardID']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<CiVariableSort>;
};


export type GroupClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  hasRemoteDevelopmentAgentConfig?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupCodeCoverageActivitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startDate: Scalars['Date'];
};


export type GroupComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupContactStateCountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<CustomerRelationsContactState>;
};


export type GroupContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['CustomerRelationsContactID']>>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<ContactSort>;
  state?: InputMaybe<CustomerRelationsContactState>;
};


export type GroupContainerRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<ContainerRepositorySort>;
};


export type GroupContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  from: Scalars['ISO8601Date'];
  last?: InputMaybe<Scalars['Int']>;
  to: Scalars['ISO8601Date'];
};


export type GroupCustomEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupDataTransferArgs = {
  from?: InputMaybe<Scalars['Date']>;
  to?: InputMaybe<Scalars['Date']>;
};


export type GroupDependencyProxyBlobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupDependencyProxyManifestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupDescendantGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeParentDescendants?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  owned?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
};


export type GroupDoraPerformanceScoreCountsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupEnvironmentScopesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
};


export type GroupEpicArgs = {
  authorUsername?: InputMaybe<Scalars['String']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  iid?: InputMaybe<Scalars['ID']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


export type GroupEpicBoardArgs = {
  id: Scalars['BoardsEpicBoardID'];
};


export type GroupEpicBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupEpicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['ID']>;
  iidStartsWith?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  labelName?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedEpicFilterInput>;
  or?: InputMaybe<UnionedEpicFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<EpicSort>;
  state?: InputMaybe<EpicState>;
  timeframe?: InputMaybe<Timeframe>;
  topLevelHierarchyOnly?: InputMaybe<Scalars['Boolean']>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


export type GroupExternalAuditEventDestinationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupGitlabSubscriptionsPreviewBillableUserChangeArgs = {
  addGroupId?: InputMaybe<Scalars['Int']>;
  addUserEmails?: InputMaybe<Array<Scalars['String']>>;
  addUserIds?: InputMaybe<Array<Scalars['Int']>>;
  role: GitlabSubscriptionsUserRole;
};


export type GroupGoogleCloudLoggingConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupGroupMembersArgs = {
  accessLevels?: InputMaybe<Array<AccessLevelEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relations?: InputMaybe<Array<GroupMemberRelation>>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MemberSort>;
};


export type GroupIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  epicId?: InputMaybe<Scalars['String']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  first?: InputMaybe<Scalars['Int']>;
  healthStatus?: InputMaybe<HealthStatus>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationTitle?: InputMaybe<Scalars['String']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  weight?: InputMaybe<Scalars['String']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type GroupIterationCadencesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  automatic?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['IterationsCadenceID']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
};


export type GroupIterationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['ID']>;
  iid?: InputMaybe<Scalars['ID']>;
  in?: InputMaybe<Array<IterationSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceIds?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<IterationSort>;
  state?: InputMaybe<IterationState>;
  timeframe?: InputMaybe<Timeframe>;
  title?: InputMaybe<Scalars['String']>;
};


export type GroupLabelArgs = {
  title: Scalars['String'];
};


export type GroupLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  includeDescendantGroups?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyGroupLabels?: InputMaybe<Scalars['Boolean']>;
  searchTerm?: InputMaybe<Scalars['String']>;
};


export type GroupMergeRequestViolationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filters?: InputMaybe<ComplianceViolationInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ComplianceViolationSort>;
};


export type GroupMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


export type GroupMilestonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  containingDate?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  includeDescendants?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  searchTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MilestoneSort>;
  state?: InputMaybe<MilestoneStateEnum>;
  timeframe?: InputMaybe<Timeframe>;
  title?: InputMaybe<Scalars['String']>;
};


export type GroupOrganizationStateCountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<CustomerRelationsOrganizationState>;
};


export type GroupOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['CustomerRelationsOrganizationID']>>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<OrganizationSort>;
  state?: InputMaybe<CustomerRelationsOrganizationState>;
};


export type GroupPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeVersionless?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  packageName?: InputMaybe<Scalars['String']>;
  packageType?: InputMaybe<PackageTypeEnum>;
  sort?: InputMaybe<PackageGroupSort>;
  status?: InputMaybe<PackageStatus>;
};


export type GroupProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  complianceFrameworkFilters?: InputMaybe<ComplianceFrameworkFilters>;
  first?: InputMaybe<Scalars['Int']>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']>;
};


export type GroupRecentIssueBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<GroupReleaseSort>;
};


export type GroupRunnersArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membership?: InputMaybe<CiRunnerMembershipFilter>;
  paused?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
};


export type GroupScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type GroupTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


export type GroupVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']>>;
  first?: InputMaybe<Scalars['Int']>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  sort?: InputMaybe<VulnerabilitySort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type GroupVulnerabilitiesCountByDayArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate: Scalars['ISO8601Date'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startDate: Scalars['ISO8601Date'];
};


export type GroupVulnerabilityGradesArgs = {
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  letterGrade?: InputMaybe<VulnerabilityGrade>;
};


export type GroupVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupVulnerabilitySeveritiesCountArgs = {
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type GroupWorkItemTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  taskable?: InputMaybe<Scalars['Boolean']>;
};

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Group>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type GroupDataTransfer = {
  __typename?: 'GroupDataTransfer';
  /** Data nodes. */
  egressNodes?: Maybe<EgressNodeConnection>;
};


export type GroupDataTransferEgressNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

/** Represents a Group Membership */
export type GroupMember = MemberInterface & {
  __typename?: 'GroupMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** Group that a User is a member of. */
  group?: Maybe<Group>;
  /** ID of the member. */
  id: Scalars['ID'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Group notification email for User. Only available for admins. */
  notificationEmail?: Maybe<Scalars['String']>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: GroupPermissions;
};


/** Represents a Group Membership */
export type GroupMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID'];
};

/** Autogenerated input type of GroupMemberBulkUpdate */
export type GroupMemberBulkUpdateInput = {
  /** Access level to update the members to. */
  accessLevel: MemberAccessLevel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Date and time the membership expires. */
  expiresAt?: InputMaybe<Scalars['Time']>;
  /** Global ID of the group. */
  groupId: Scalars['GroupID'];
  /** Global IDs of the members. */
  userIds: Array<Scalars['UserID']>;
};

/** Autogenerated return type of GroupMemberBulkUpdate */
export type GroupMemberBulkUpdatePayload = {
  __typename?: 'GroupMemberBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group members after mutation. */
  groupMembers?: Maybe<Array<GroupMember>>;
};

/** The connection type for GroupMember. */
export type GroupMemberConnection = {
  __typename?: 'GroupMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupMemberEdge = {
  __typename?: 'GroupMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupMember>;
};

/** Group member relation */
export type GroupMemberRelation =
  /** Members in the group's subgroups. */
  | 'DESCENDANTS'
  /** Members in the group itself. */
  | 'DIRECT'
  /** Members in the group's ancestor groups. */
  | 'INHERITED'
  /** Invited group's members. */
  | 'SHARED_FROM_GROUPS';

/** User permission on groups */
export type GroupPermission =
  /** Groups where the user can create projects. */
  | 'CREATE_PROJECTS'
  /** Groups where the user can import projects to. */
  | 'IMPORT_PROJECTS'
  /** Groups where the user can transfer projects to. */
  | 'TRANSFER_PROJECTS';

export type GroupPermissions = {
  __typename?: 'GroupPermissions';
  /** Indicates the user can perform `create_projects` on this resource */
  createProjects: Scalars['Boolean'];
  /** Indicates the user can perform `read_group` on this resource */
  readGroup: Scalars['Boolean'];
};

/** Values for sorting releases belonging to a group */
export type GroupReleaseSort =
  /** Released at by ascending order. */
  | 'RELEASED_AT_ASC'
  /** Released at by descending order. */
  | 'RELEASED_AT_DESC';

/** Contains release-related statistics about a group */
export type GroupReleaseStats = {
  __typename?: 'GroupReleaseStats';
  /** Total number of releases in all descendant projects of the group. */
  releasesCount?: Maybe<Scalars['Int']>;
  /** Percentage of the group's descendant projects that have at least one release. */
  releasesPercentage?: Maybe<Scalars['Int']>;
};

/** Represents the source of a security policy belonging to a group */
export type GroupSecurityPolicySource = {
  __typename?: 'GroupSecurityPolicySource';
  /** Indicates whether this policy is inherited from parent group. */
  inherited: Scalars['Boolean'];
  /** Project the policy is associated with. */
  namespace?: Maybe<Namespace>;
};

/** Contains statistics about a group */
export type GroupStats = {
  __typename?: 'GroupStats';
  /** Statistics related to releases within the group. */
  releaseStats?: Maybe<GroupReleaseStats>;
};

/** Autogenerated input type of GroupUpdate */
export type GroupUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the group that will be updated. */
  fullPath: Scalars['ID'];
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting: SharedRunnersSetting;
};

/** Autogenerated return type of GroupUpdate */
export type GroupUpdatePayload = {
  __typename?: 'GroupUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group after update. */
  group?: Maybe<Group>;
};

/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetrics = {
  __typename?: 'GroupValueStreamAnalyticsFlowMetrics';
  /** Median time from first commit to issue closed */
  cycleTime?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of production deployments in the given period. */
  deploymentCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of issues opened in the given period. */
  issueCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of open issues closed (completed) in the given period. Maximum value is 10,001. */
  issuesCompletedCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Median time from when the issue was created to when it was closed. */
  leadTime?: Maybe<ValueStreamAnalyticsMetric>;
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsCycleTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsDeploymentCountArgs = {
  from: Scalars['Time'];
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsIssueCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsIssuesCompletedCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type GroupValueStreamAnalyticsFlowMetricsLeadTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  to: Scalars['Time'];
};

/** Represents the Geo sync and verification state of a group wiki repository */
export type GroupWikiRepositoryRegistry = {
  __typename?: 'GroupWikiRepositoryRegistry';
  /** Timestamp when the GroupWikiRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Group Wiki Repository. */
  groupWikiRepositoryId: Scalars['ID'];
  /** ID of the GroupWikiRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the GroupWikiRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the GroupWikiRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the GroupWikiRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the GroupWikiRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the GroupWikiRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the GroupWikiRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the GroupWikiRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for GroupWikiRepositoryRegistry. */
export type GroupWikiRepositoryRegistryConnection = {
  __typename?: 'GroupWikiRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupWikiRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupWikiRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupWikiRepositoryRegistryEdge = {
  __typename?: 'GroupWikiRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupWikiRepositoryRegistry>;
};

/** Health status of an issue or epic */
export type HealthStatus =
  /** At risk */
  | 'atRisk'
  /** Needs attention */
  | 'needsAttention'
  /** On track */
  | 'onTrack';

/** Health status of an issue or epic for filtering */
export type HealthStatusFilter =
  /** Any health status is assigned. */
  | 'ANY'
  /** No health status is assigned. */
  | 'NONE'
  /** At risk */
  | 'atRisk'
  /** Needs attention */
  | 'needsAttention'
  /** On track */
  | 'onTrack';

/** Helm file metadata */
export type HelmFileMetadata = PackageFileMetadata & {
  __typename?: 'HelmFileMetadata';
  /** Channel of the Helm chart. */
  channel: Scalars['String'];
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Metadata of the Helm chart. */
  metadata: PackageHelmMetadataType;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Autogenerated input type of HttpIntegrationCreate */
export type HttpIntegrationCreateInput = {
  /** Whether the integration is receiving alerts. */
  active: Scalars['Boolean'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the integration. */
  name: Scalars['String'];
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']>;
  /** Project to create the integration in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of HttpIntegrationCreate */
export type HttpIntegrationCreatePayload = {
  __typename?: 'HttpIntegrationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationDestroy */
export type HttpIntegrationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to remove. */
  id: Scalars['AlertManagementHttpIntegrationID'];
};

/** Autogenerated return type of HttpIntegrationDestroy */
export type HttpIntegrationDestroyPayload = {
  __typename?: 'HttpIntegrationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationResetToken */
export type HttpIntegrationResetTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['AlertManagementHttpIntegrationID'];
};

/** Autogenerated return type of HttpIntegrationResetToken */
export type HttpIntegrationResetTokenPayload = {
  __typename?: 'HttpIntegrationResetTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Autogenerated input type of HttpIntegrationUpdate */
export type HttpIntegrationUpdateInput = {
  /** Whether the integration is receiving alerts. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['AlertManagementHttpIntegrationID'];
  /** Name of the integration. */
  name?: InputMaybe<Scalars['String']>;
  /** Custom mapping of GitLab alert attributes to fields from the payload example. */
  payloadAttributeMappings?: InputMaybe<Array<AlertManagementPayloadAlertFieldInput>>;
  /** Example of an alert payload. */
  payloadExample?: InputMaybe<Scalars['JsonString']>;
};

/** Autogenerated return type of HttpIntegrationUpdate */
export type HttpIntegrationUpdatePayload = {
  __typename?: 'HttpIntegrationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** HTTP integration. */
  integration?: Maybe<AlertManagementHttpIntegration>;
};

/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotation = {
  __typename?: 'IncidentManagementOncallRotation';
  /** Active period for the on-call rotation. */
  activePeriod?: Maybe<OncallRotationActivePeriodType>;
  /** End date and time of the on-call rotation. */
  endsAt?: Maybe<Scalars['Time']>;
  /** ID of the on-call rotation. */
  id: Scalars['IncidentManagementOncallRotationID'];
  /** Length of the on-call schedule, in the units specified by lengthUnit. */
  length?: Maybe<Scalars['Int']>;
  /** Unit of the on-call rotation length. */
  lengthUnit?: Maybe<OncallRotationUnitEnum>;
  /** Name of the on-call rotation. */
  name: Scalars['String'];
  /** Participants of the on-call rotation. */
  participants?: Maybe<OncallParticipantTypeConnection>;
  /** Blocks of time for which a participant is on-call within a given time frame. Time frame cannot exceed one month. */
  shifts?: Maybe<IncidentManagementOncallShiftConnection>;
  /** Start date of the on-call rotation. */
  startsAt?: Maybe<Scalars['Time']>;
};


/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotationParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Describes an incident management on-call rotation */
export type IncidentManagementOncallRotationShiftsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endTime: Scalars['Time'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startTime: Scalars['Time'];
};

/** The connection type for IncidentManagementOncallRotation. */
export type IncidentManagementOncallRotationConnection = {
  __typename?: 'IncidentManagementOncallRotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallRotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallRotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallRotationEdge = {
  __typename?: 'IncidentManagementOncallRotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallRotation>;
};

/** Describes an incident management on-call schedule */
export type IncidentManagementOncallSchedule = {
  __typename?: 'IncidentManagementOncallSchedule';
  /** Description of the on-call schedule. */
  description?: Maybe<Scalars['String']>;
  /** Internal ID of the on-call schedule. */
  iid: Scalars['ID'];
  /** Name of the on-call schedule. */
  name: Scalars['String'];
  oncallUsers?: Maybe<Array<UserCore>>;
  /** On-call rotation for the on-call schedule. */
  rotation?: Maybe<IncidentManagementOncallRotation>;
  /** On-call rotations for the on-call schedule. */
  rotations: IncidentManagementOncallRotationConnection;
  /** Time zone of the on-call schedule. */
  timezone: Scalars['String'];
};


/** Describes an incident management on-call schedule */
export type IncidentManagementOncallScheduleRotationArgs = {
  id: Scalars['IncidentManagementOncallRotationID'];
};


/** Describes an incident management on-call schedule */
export type IncidentManagementOncallScheduleRotationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for IncidentManagementOncallSchedule. */
export type IncidentManagementOncallScheduleConnection = {
  __typename?: 'IncidentManagementOncallScheduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallScheduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallSchedule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallScheduleEdge = {
  __typename?: 'IncidentManagementOncallScheduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallSchedule>;
};

/** A block of time for which a participant is on-call. */
export type IncidentManagementOncallShift = {
  __typename?: 'IncidentManagementOncallShift';
  /** End time of the on-call shift. */
  endsAt?: Maybe<Scalars['Time']>;
  /** Participant assigned to the on-call shift. */
  participant?: Maybe<OncallParticipantType>;
  /** Start time of the on-call shift. */
  startsAt?: Maybe<Scalars['Time']>;
};

/** The connection type for IncidentManagementOncallShift. */
export type IncidentManagementOncallShiftConnection = {
  __typename?: 'IncidentManagementOncallShiftConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IncidentManagementOncallShiftEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IncidentManagementOncallShift>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type IncidentManagementOncallShiftEdge = {
  __typename?: 'IncidentManagementOncallShiftEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IncidentManagementOncallShift>;
};

/** CI/CD variables a project inherites from its parent group and ancestors. */
export type InheritedCiVariable = {
  __typename?: 'InheritedCiVariable';
  /** Scope defining the environments that can use the variable. */
  environmentScope?: Maybe<Scalars['String']>;
  /** Indicates the path to the CI/CD settings of the group the variable belongs to. */
  groupCiCdSettingsPath?: Maybe<Scalars['String']>;
  /** Indicates group the variable belongs to. */
  groupName?: Maybe<Scalars['String']>;
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is masked. */
  masked?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is protected. */
  protected?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for InheritedCiVariable. */
export type InheritedCiVariableConnection = {
  __typename?: 'InheritedCiVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InheritedCiVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InheritedCiVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InheritedCiVariableEdge = {
  __typename?: 'InheritedCiVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<InheritedCiVariable>;
};

/** Represents an external resource to send instance audit events to */
export type InstanceExternalAuditEventDestination = ExternalAuditEventDestinationInterface & {
  __typename?: 'InstanceExternalAuditEventDestination';
  /** External destination to send audit events to. */
  destinationUrl: Scalars['String'];
  /** List of additional HTTP headers sent with each event. */
  headers: AuditEventsStreamingInstanceHeaderConnection;
  /** ID of the destination. */
  id: Scalars['ID'];
  /** Verification token to validate source of event. */
  verificationToken: Scalars['String'];
};


/** Represents an external resource to send instance audit events to */
export type InstanceExternalAuditEventDestinationHeadersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for InstanceExternalAuditEventDestination. */
export type InstanceExternalAuditEventDestinationConnection = {
  __typename?: 'InstanceExternalAuditEventDestinationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InstanceExternalAuditEventDestinationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<InstanceExternalAuditEventDestination>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of InstanceExternalAuditEventDestinationCreate */
export type InstanceExternalAuditEventDestinationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination URL. */
  destinationUrl: Scalars['String'];
};

/** Autogenerated return type of InstanceExternalAuditEventDestinationCreate */
export type InstanceExternalAuditEventDestinationCreatePayload = {
  __typename?: 'InstanceExternalAuditEventDestinationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Destination created. */
  instanceExternalAuditEventDestination?: Maybe<InstanceExternalAuditEventDestination>;
};

/** Autogenerated input type of InstanceExternalAuditEventDestinationDestroy */
export type InstanceExternalAuditEventDestinationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the external instance audit event destination to destroy. */
  id: Scalars['AuditEventsInstanceExternalAuditEventDestinationID'];
};

/** Autogenerated return type of InstanceExternalAuditEventDestinationDestroy */
export type InstanceExternalAuditEventDestinationDestroyPayload = {
  __typename?: 'InstanceExternalAuditEventDestinationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type InstanceExternalAuditEventDestinationEdge = {
  __typename?: 'InstanceExternalAuditEventDestinationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<InstanceExternalAuditEventDestination>;
};

/** Autogenerated input type of InstanceExternalAuditEventDestinationUpdate */
export type InstanceExternalAuditEventDestinationUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Destination URL to change. */
  destinationUrl?: InputMaybe<Scalars['String']>;
  /** ID of the external instance audit event destination to update. */
  id: Scalars['AuditEventsInstanceExternalAuditEventDestinationID'];
};

/** Autogenerated return type of InstanceExternalAuditEventDestinationUpdate */
export type InstanceExternalAuditEventDestinationUpdatePayload = {
  __typename?: 'InstanceExternalAuditEventDestinationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated destination. */
  instanceExternalAuditEventDestination?: Maybe<InstanceExternalAuditEventDestination>;
};

export type InstanceSecurityDashboard = {
  __typename?: 'InstanceSecurityDashboard';
  /** Cluster agents associated with projects selected in the Instance Security Dashboard. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Projects selected in Instance Security Dashboard. */
  projects: ProjectConnection;
  /** Represents vulnerable project counts for each grade. */
  vulnerabilityGrades: Array<VulnerableProjectsByGrade>;
  /** Vulnerability scanners reported on the vulnerabilities from projects selected in Instance Security Dashboard. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity from projects selected in Instance Security Dashboard. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
};


export type InstanceSecurityDashboardClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  hasRemoteDevelopmentAgentConfig?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type InstanceSecurityDashboardProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type InstanceSecurityDashboardVulnerabilityGradesArgs = {
  letterGrade?: InputMaybe<VulnerabilityGrade>;
};


export type InstanceSecurityDashboardVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type InstanceSecurityDashboardVulnerabilitySeveritiesCountArgs = {
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};

/** Represents an issuable. */
export type Issuable = Epic | Issue | MergeRequest | WorkItem;

/** Describes an issuable resource link for incident issues */
export type IssuableResourceLink = {
  __typename?: 'IssuableResourceLink';
  /** ID of the Issuable resource link. */
  id: Scalars['IncidentManagementIssuableResourceLinkID'];
  /** Incident of the resource link. */
  issue: Issue;
  /** Web Link to the resource. */
  link: Scalars['String'];
  /** Optional text for the link. */
  linkText?: Maybe<Scalars['String']>;
  /** Type of the resource link. */
  linkType: IssuableResourceLinkType;
};

/** The connection type for IssuableResourceLink. */
export type IssuableResourceLinkConnection = {
  __typename?: 'IssuableResourceLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssuableResourceLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IssuableResourceLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IssuableResourceLinkCreate */
export type IssuableResourceLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Incident id to associate the resource link with. */
  id: Scalars['IssueID'];
  /** Link of the resource. */
  link: Scalars['String'];
  /** Link text of the resource. */
  linkText?: InputMaybe<Scalars['String']>;
  /** Link type of the resource. */
  linkType?: InputMaybe<IssuableResourceLinkType>;
};

/** Autogenerated return type of IssuableResourceLinkCreate */
export type IssuableResourceLinkCreatePayload = {
  __typename?: 'IssuableResourceLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issuable resource link. */
  issuableResourceLink?: Maybe<IssuableResourceLink>;
};

/** Autogenerated input type of IssuableResourceLinkDestroy */
export type IssuableResourceLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Issuable resource link ID to remove. */
  id: Scalars['IncidentManagementIssuableResourceLinkID'];
};

/** Autogenerated return type of IssuableResourceLinkDestroy */
export type IssuableResourceLinkDestroyPayload = {
  __typename?: 'IssuableResourceLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issuable resource link. */
  issuableResourceLink?: Maybe<IssuableResourceLink>;
};

/** An edge in a connection. */
export type IssuableResourceLinkEdge = {
  __typename?: 'IssuableResourceLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IssuableResourceLink>;
};

/** Issuable resource link type enum */
export type IssuableResourceLinkType =
  /** General link type */
  | 'general'
  /** Pagerduty link type */
  | 'pagerduty'
  /** Slack link type */
  | 'slack'
  /** Zoom link type */
  | 'zoom';

/** Fields to perform the search in */
export type IssuableSearchableField =
  /** Search in description field. */
  | 'DESCRIPTION'
  /** Search in title field. */
  | 'TITLE';

/** Incident severity */
export type IssuableSeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM'
  /** Unknown severity */
  | 'UNKNOWN';

/** State of a GitLab issue or merge request */
export type IssuableState =
  /** All available. */
  | 'all'
  /** In closed state. */
  | 'closed'
  /** Discussion has been locked. */
  | 'locked'
  /** In open state. */
  | 'opened';

/** Values for subscribing and unsubscribing from issuables */
export type IssuableSubscriptionEvent =
  /** Subscribe to an issuable. */
  | 'SUBSCRIBE'
  /** Unsubscribe from an issuable. */
  | 'UNSUBSCRIBE';

export type Issue = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'Issue';
  /**
   * Alert associated to this issue. Deprecated in 15.6: Use `alert_management_alerts`.
   * @deprecated Use `alert_management_alerts`. Deprecated in 15.6.
   */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Alert Management alerts associated to this issue. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** Assignees of the issue. */
  assignees?: Maybe<UserCoreConnection>;
  /** User that created the issue. */
  author: UserCore;
  /** Indicates the issue is blocked. */
  blocked: Scalars['Boolean'];
  /** Count of issues blocking this issue. */
  blockedByCount?: Maybe<Scalars['Int']>;
  /** Issues blocking this issue. */
  blockedByIssues?: Maybe<IssueConnection>;
  /** Count of issues this issue is blocking. */
  blockingCount: Scalars['Int'];
  /** Issue this issue was closed as a duplicate of. */
  closedAsDuplicateOf?: Maybe<Issue>;
  /** Timestamp of when the issue was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Indicates the issue is confidential. */
  confidential: Scalars['Boolean'];
  /** User specific email address for the issue. */
  createNoteEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the issue was created. */
  createdAt: Scalars['Time'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Customer relations contacts of the issue. */
  customerRelationsContacts?: Maybe<CustomerRelationsContactConnection>;
  /** Description of the issue. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Collection of design images associated with this issue. */
  designCollection?: Maybe<DesignCollection>;
  /** Indicates discussion is locked on the issue. */
  discussionLocked: Scalars['Boolean'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Number of downvotes the issue has received. */
  downvotes: Scalars['Int'];
  /** Due date of the issue. */
  dueDate?: Maybe<Scalars['Time']>;
  /** Indicates if a project has email notifications disabled: `true` if email notifications are disabled. */
  emailsDisabled: Scalars['Boolean'];
  /** Epic to which this issue belongs. */
  epic?: Maybe<Epic>;
  /** Escalation policy associated with the issue. Available for issues which support escalation. */
  escalationPolicy?: Maybe<EscalationPolicyType>;
  /** Escalation status of the issue. */
  escalationStatus?: Maybe<IssueEscalationStatus>;
  /**
   * Indicates if the issue belongs to an epic.
   *             Can return true and not show an associated epic when the user has no access to the epic.
   */
  hasEpic: Scalars['Boolean'];
  /** Current health status. */
  healthStatus?: Maybe<HealthStatus>;
  /** Indicates the issue is hidden because the author has been banned. */
  hidden?: Maybe<Scalars['Boolean']>;
  /** Human-readable time estimate of the issue. */
  humanTimeEstimate?: Maybe<Scalars['String']>;
  /** Human-readable total time reported as spent on the issue. */
  humanTotalTimeSpent?: Maybe<Scalars['String']>;
  /** ID of the issue. */
  id: Scalars['ID'];
  /** Internal ID of the issue. */
  iid: Scalars['ID'];
  /** Issuable resource links of the incident issue. */
  issuableResourceLinks?: Maybe<IssuableResourceLinkConnection>;
  /** Iteration of the issue. */
  iteration?: Maybe<Iteration>;
  /** Labels of the issue. */
  labels?: Maybe<LabelConnection>;
  /** Number of merge requests that close the issue on merge. */
  mergeRequestsCount: Scalars['Int'];
  /** Metric images associated to the issue. */
  metricImages?: Maybe<Array<MetricImage>>;
  /** Milestone of the issue. */
  milestone?: Maybe<Milestone>;
  /** Indicates if issue got moved from other project. */
  moved?: Maybe<Scalars['Boolean']>;
  /** Updated Issue after it got moved to another project. */
  movedTo?: Maybe<Issue>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** List of participants in the issue. */
  participants?: Maybe<UserCoreConnection>;
  /** ID of the issue project. */
  projectId: Scalars['Int'];
  /** Internal reference of the issue. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** Merge requests related to the issue. This field can only be resolved for one issue in any single request. */
  relatedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Related vulnerabilities of the issue. */
  relatedVulnerabilities?: Maybe<VulnerabilityConnection>;
  /** Relative position of the issue (used for positioning in epic tree and issue boards). */
  relativePosition?: Maybe<Scalars['Int']>;
  /** Severity level of the incident. */
  severity?: Maybe<IssuableSeverity>;
  /** Timestamp of when the issue SLA expires. */
  slaDueAt?: Maybe<Scalars['Time']>;
  /** State of the issue. */
  state: IssueState;
  /** Indicates whether an issue is published to the status page. */
  statusPagePublishedIncident?: Maybe<Scalars['Boolean']>;
  /** Indicates the currently logged in user is subscribed to the issue. */
  subscribed: Scalars['Boolean'];
  /** Task completion status of the issue. */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the issue. */
  timeEstimate: Scalars['Int'];
  /** Timelogs on the issue. */
  timelogs: TimelogConnection;
  /** Title of the issue. */
  title: Scalars['String'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Total time reported as spent on the issue. */
  totalTimeSpent: Scalars['Int'];
  /** Type of the issue. */
  type?: Maybe<IssueType>;
  /** Timestamp of when the issue was last updated. */
  updatedAt: Scalars['Time'];
  /** User that last updated the issue. */
  updatedBy?: Maybe<UserCore>;
  /** Number of upvotes the issue has received. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the issue. */
  userDiscussionsCount: Scalars['Int'];
  /** Number of user notes of the issue. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: IssuePermissions;
  /** Web path of the issue. */
  webPath: Scalars['String'];
  /** Web URL of the issue. */
  webUrl: Scalars['String'];
  /** Weight of the issue. */
  weight?: Maybe<Scalars['Int']>;
};


export type IssueAlertManagementAlertsArgs = {
  after?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  domain?: AlertManagementDomainFilter;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


export type IssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueBlockedByIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


export type IssueCustomerRelationsContactsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueIssuableResourceLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  incidentId: Scalars['IssueID'];
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};


export type IssueRelatedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueRelatedVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type IssueTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Issue. */
export type IssueConnection = {
  __typename?: 'IssueConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total weight of issues collection. */
  weight: Scalars['Int'];
};

/** Iteration ID wildcard values for issue creation */
export type IssueCreationIterationWildcardId =
  /** Current iteration. */
  | 'CURRENT';

/** An edge in a connection. */
export type IssueEdge = {
  __typename?: 'IssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Issue>;
};

/** Issue escalation status values */
export type IssueEscalationStatus =
  /** Someone is actively investigating the problem. */
  | 'ACKNOWLEDGED'
  /** No action will be taken. */
  | 'IGNORED'
  /** The problem has been addressed. */
  | 'RESOLVED'
  /** Investigation has not started. */
  | 'TRIGGERED';

/** Autogenerated input type of IssueLinkAlerts */
export type IssueLinkAlertsInput = {
  /** Alerts references to be linked to the incident. */
  alertReferences: Array<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueLinkAlerts */
export type IssueLinkAlertsPayload = {
  __typename?: 'IssueLinkAlertsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueMove */
export type IssueMoveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** Project to move the issue to. */
  targetProjectPath: Scalars['ID'];
};

/** Autogenerated input type of IssueMoveList */
export type IssueMoveListInput = {
  /** Global ID of the board that the issue is in. */
  boardId: Scalars['BoardID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the parent epic. NULL when removing the association. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** ID of the board list that the issue will be moved from. */
  fromListId?: InputMaybe<Scalars['ID']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** ID of issue that should be placed after the current issue. */
  moveAfterId?: InputMaybe<Scalars['ID']>;
  /** ID of issue that should be placed before the current issue. */
  moveBeforeId?: InputMaybe<Scalars['ID']>;
  /** Position of issue within the board list. Positions start at 0. Use -1 to move to the end of the list. */
  positionInList?: InputMaybe<Scalars['Int']>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** ID of the board list that the issue will be moved to. */
  toListId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of IssueMoveList */
export type IssueMoveListPayload = {
  __typename?: 'IssueMoveListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated return type of IssueMove */
export type IssueMovePayload = {
  __typename?: 'IssueMovePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Check permissions for the current user on a issue */
export type IssuePermissions = {
  __typename?: 'IssuePermissions';
  /** Indicates the user can perform `admin_issue` on this resource */
  adminIssue: Scalars['Boolean'];
  /** Indicates the user can perform `create_design` on this resource */
  createDesign: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_design` on this resource */
  destroyDesign: Scalars['Boolean'];
  /** Indicates the user can perform `read_design` on this resource */
  readDesign: Scalars['Boolean'];
  /** Indicates the user can perform `read_issue` on this resource */
  readIssue: Scalars['Boolean'];
  /** Indicates the user can perform `reopen_issue` on this resource */
  reopenIssue: Scalars['Boolean'];
  /** Indicates the user can perform `update_design` on this resource */
  updateDesign: Scalars['Boolean'];
  /** Indicates the user can perform `update_issue` on this resource */
  updateIssue: Scalars['Boolean'];
};

/** Autogenerated input type of IssueSetAssignees */
export type IssueSetAssigneesInput = {
  /** Usernames to assign to the resource. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetAssignees */
export type IssueSetAssigneesPayload = {
  __typename?: 'IssueSetAssigneesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetConfidential */
export type IssueSetConfidentialInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to set the issue as a confidential. */
  confidential: Scalars['Boolean'];
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetConfidential */
export type IssueSetConfidentialPayload = {
  __typename?: 'IssueSetConfidentialPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetCrmContacts */
export type IssueSetCrmContactsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Customer relations contact IDs to set. Replaces existing contacts by default. */
  contactIds: Array<Scalars['CustomerRelationsContactID']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Changes the operation mode. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetCrmContacts */
export type IssueSetCrmContactsPayload = {
  __typename?: 'IssueSetCrmContactsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetDueDate */
export type IssueSetDueDateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired due date for the issue. Due date is removed if null. */
  dueDate?: InputMaybe<Scalars['Time']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetDueDate */
export type IssueSetDueDatePayload = {
  __typename?: 'IssueSetDueDatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEpic */
export type IssueSetEpicInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the epic to be assigned to the issue, epic will be removed if absent or set to null */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetEpic */
export type IssueSetEpicPayload = {
  __typename?: 'IssueSetEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEscalationPolicy */
export type IssueSetEscalationPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the escalation policy to assign to the issue. Policy will be removed if absent or set to null. */
  escalationPolicyId?: InputMaybe<Scalars['IncidentManagementEscalationPolicyID']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetEscalationPolicy */
export type IssueSetEscalationPolicyPayload = {
  __typename?: 'IssueSetEscalationPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetEscalationStatus */
export type IssueSetEscalationStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** Set the escalation status. */
  status: IssueEscalationStatus;
};

/** Autogenerated return type of IssueSetEscalationStatus */
export type IssueSetEscalationStatusPayload = {
  __typename?: 'IssueSetEscalationStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetIteration */
export type IssueSetIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Iteration to assign to the issue. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetIteration */
export type IssueSetIterationPayload = {
  __typename?: 'IssueSetIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetLocked */
export type IssueSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Whether or not to lock discussion on the issue. */
  locked: Scalars['Boolean'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueSetLocked */
export type IssueSetLockedPayload = {
  __typename?: 'IssueSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetSeverity */
export type IssueSetSeverityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** Set the incident severity level. */
  severity: IssuableSeverity;
};

/** Autogenerated return type of IssueSetSeverity */
export type IssueSetSeverityPayload = {
  __typename?: 'IssueSetSeverityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetSubscription */
export type IssueSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean'];
};

/** Autogenerated return type of IssueSetSubscription */
export type IssueSetSubscriptionPayload = {
  __typename?: 'IssueSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssueSetWeight */
export type IssueSetWeightInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** The desired weight for the issue. If set to null, weight is removed. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of IssueSetWeight */
export type IssueSetWeightPayload = {
  __typename?: 'IssueSetWeightPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Values for sorting issues */
export type IssueSort =
  /** Blocking issues count by ascending order. */
  | 'BLOCKING_ISSUES_ASC'
  /** Blocking issues count by descending order. */
  | 'BLOCKING_ISSUES_DESC'
  /** Closed time by ascending order. */
  | 'CLOSED_AT_ASC'
  /** Closed time by descending order. */
  | 'CLOSED_AT_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Due date by ascending order. */
  | 'DUE_DATE_ASC'
  /** Due date by descending order. */
  | 'DUE_DATE_DESC'
  /** Status from triggered to resolved. */
  | 'ESCALATION_STATUS_ASC'
  /** Status from resolved to triggered. */
  | 'ESCALATION_STATUS_DESC'
  /** Issues with healthy issues first. */
  | 'HEALTH_STATUS_ASC'
  /** Issues with unhealthy issues first. */
  | 'HEALTH_STATUS_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** Number of upvotes (awarded "thumbs up" emoji) by ascending order. */
  | 'POPULARITY_ASC'
  /** Number of upvotes (awarded "thumbs up" emoji) by descending order. */
  | 'POPULARITY_DESC'
  /** Priority by ascending order. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. */
  | 'PRIORITY_DESC'
  /** Published issues shown last. */
  | 'PUBLISHED_ASC'
  /** Published issues shown first. */
  | 'PUBLISHED_DESC'
  /** Relative position by ascending order. */
  | 'RELATIVE_POSITION_ASC'
  /** Severity from less critical to more critical. */
  | 'SEVERITY_ASC'
  /** Severity from more critical to less critical. */
  | 'SEVERITY_DESC'
  /** Issues with earliest SLA due time shown first. */
  | 'SLA_DUE_AT_ASC'
  /** Issues with latest SLA due time shown first. */
  | 'SLA_DUE_AT_DESC'
  /** Title by ascending order. */
  | 'TITLE_ASC'
  /** Title by descending order. */
  | 'TITLE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Weight by ascending order. */
  | 'WEIGHT_ASC'
  /** Weight by descending order. */
  | 'WEIGHT_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** State of a GitLab issue */
export type IssueState =
  /** All available. */
  | 'all'
  /** In closed state. */
  | 'closed'
  /** Discussion has been locked. */
  | 'locked'
  /** In open state. */
  | 'opened';

/** Values for issue state events */
export type IssueStateEvent =
  /** Closes the issue. */
  | 'CLOSE'
  /** Reopens the issue. */
  | 'REOPEN';

/** Represents total number of issues for the represented statuses */
export type IssueStatusCountsType = {
  __typename?: 'IssueStatusCountsType';
  /** Number of issues with status ALL for the project */
  all?: Maybe<Scalars['Int']>;
  /** Number of issues with status CLOSED for the project */
  closed?: Maybe<Scalars['Int']>;
  /** Number of issues with status OPENED for the project */
  opened?: Maybe<Scalars['Int']>;
};

/** Issue type */
export type IssueType =
  /** Incident issue type */
  | 'INCIDENT'
  /** Issue issue type */
  | 'ISSUE'
  /**
   * Key Result issue type. Available only when feature flag `okrs_mvc` is enabled.
   * Introduced in 15.7: This feature is an Experiment. It can be changed or
   * removed at any time.
   */
  | 'KEY_RESULT'
  /**
   * Objective issue type. Available only when feature flag `okrs_mvc` is enabled.
   * Introduced in 15.6: This feature is an Experiment. It can be changed or
   * removed at any time.
   */
  | 'OBJECTIVE'
  /** Requirement issue type */
  | 'REQUIREMENT'
  /** Task issue type. Introduced in 15.2: This feature is an Experiment. It can be changed or removed at any time. */
  | 'TASK'
  /** Test Case issue type */
  | 'TEST_CASE';

/** Autogenerated input type of IssueUnlinkAlert */
export type IssueUnlinkAlertInput = {
  /** Global ID of the alert to unlink from the incident. */
  alertId: Scalars['AlertManagementAlertID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of IssueUnlinkAlert */
export type IssueUnlinkAlertPayload = {
  __typename?: 'IssueUnlinkAlertPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of IssuesBulkUpdate */
export type IssuesBulkUpdateInput = {
  /** Global ID array of the labels that will be added to the issues. */
  addLabelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /**
   * Global ID array of the users that will be assigned to the given issues.
   * Existing assignees will be replaced with the ones on this list.
   */
  assigneeIds?: InputMaybe<Array<Scalars['UserID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the epic that will be assigned to the issues. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Health status that will be assigned to the issues. */
  healthStatus?: InputMaybe<HealthStatus>;
  /**
   * Global ID array of the issues that will be updated. IDs that the user can't
   * update will be ignored. A max of 100 can be provided.
   */
  ids: Array<Scalars['IssueID']>;
  /** Global ID of the iteration that will be assigned to the issues. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** Global ID of the milestone that will be assigned to the issues. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /**
   * Global ID of the parent to which the bulk update will be scoped. The parent
   * can be a project **(FREE)** or a group **(PREMIUM)**. Example `IssueParentID`
   * are `"gid://gitlab/Project/1"` and `"gid://gitlab/Group/1"`.
   */
  parentId: Scalars['IssueParentID'];
  /** Global ID array of the labels that will be removed from the issues. */
  removeLabelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Close or reopen an issue. */
  stateEvent?: InputMaybe<IssueStateEvent>;
  /** Subscribe to or unsubscribe from issue notifications. */
  subscriptionEvent?: InputMaybe<IssuableSubscriptionEvent>;
};

/** Autogenerated return type of IssuesBulkUpdate */
export type IssuesBulkUpdatePayload = {
  __typename?: 'IssuesBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Number of issues that were successfully updated. */
  updatedIssueCount?: Maybe<Scalars['Int']>;
};

/** Represents an iteration object */
export type Iteration = TimeboxReportInterface & {
  __typename?: 'Iteration';
  /** Timestamp of iteration creation. */
  createdAt: Scalars['Time'];
  /** Description of the iteration. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Timestamp of the iteration due date. */
  dueDate?: Maybe<Scalars['Time']>;
  /** ID of the iteration. */
  id: Scalars['ID'];
  /** Internal ID of the iteration. */
  iid: Scalars['ID'];
  /** Cadence of the iteration. */
  iterationCadence: IterationCadence;
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
  /** Web path of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts. */
  scopedPath?: Maybe<Scalars['String']>;
  /** Web URL of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts. */
  scopedUrl?: Maybe<Scalars['String']>;
  /**
   * Sequence number for the iteration when you sort the containing cadence's
   * iterations by the start and end date. The earliest starting and ending
   * iteration is assigned 1.
   */
  sequence: Scalars['Int'];
  /** Timestamp of the iteration start date. */
  startDate?: Maybe<Scalars['Time']>;
  /** State of the iteration. */
  state: IterationState;
  /** Title of the iteration. */
  title?: Maybe<Scalars['String']>;
  /** Timestamp of last iteration update. */
  updatedAt: Scalars['Time'];
  /** Web path of the iteration. */
  webPath: Scalars['String'];
  /** Web URL of the iteration. */
  webUrl: Scalars['String'];
};


/** Represents an iteration object */
export type IterationReportArgs = {
  fullPath?: InputMaybe<Scalars['String']>;
};

/** Represents an iteration cadence */
export type IterationCadence = {
  __typename?: 'IterationCadence';
  /** Whether the iteration cadence is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic?: Maybe<Scalars['Boolean']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: Maybe<Scalars['String']>;
  /** Duration in weeks of the iterations within this cadence. */
  durationInWeeks?: Maybe<Scalars['Int']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: Maybe<Scalars['Int']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver: Scalars['Boolean'];
  /** Timestamp of the automation start date. */
  startDate?: Maybe<Scalars['Time']>;
  /** Title of the iteration cadence. */
  title: Scalars['String'];
};

/** The connection type for IterationCadence. */
export type IterationCadenceConnection = {
  __typename?: 'IterationCadenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IterationCadenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IterationCadence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IterationCadenceCreate */
export type IterationCadenceCreateInput = {
  /** Whether the iteration cadence is active. */
  active: Scalars['Boolean'];
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic: Scalars['Boolean'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: InputMaybe<Scalars['String']>;
  /** Duration in weeks of the iterations within this cadence. */
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  /** Group where the iteration cadence is created. */
  groupPath: Scalars['ID'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: InputMaybe<Scalars['Int']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver?: InputMaybe<Scalars['Boolean']>;
  /** Timestamp of the automation start date. */
  startDate?: InputMaybe<Scalars['Time']>;
  /** Title of the iteration cadence. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of IterationCadenceCreate */
export type IterationCadenceCreatePayload = {
  __typename?: 'IterationCadenceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
};

/** Autogenerated input type of IterationCadenceDestroy */
export type IterationCadenceDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID'];
};

/** Autogenerated return type of IterationCadenceDestroy */
export type IterationCadenceDestroyPayload = {
  __typename?: 'IterationCadenceDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group the iteration cadence belongs to. */
  group: Group;
};

/** An edge in a connection. */
export type IterationCadenceEdge = {
  __typename?: 'IterationCadenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<IterationCadence>;
};

/** Autogenerated input type of IterationCadenceUpdate */
export type IterationCadenceUpdateInput = {
  /** Whether the iteration cadence is active. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Whether the iteration cadence should automatically generate upcoming iterations. */
  automatic?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the iteration cadence. Maximum length is 5000 characters. */
  description?: InputMaybe<Scalars['String']>;
  /** Duration in weeks of the iterations within this cadence. */
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  /** Global ID of the iteration cadence. */
  id: Scalars['IterationsCadenceID'];
  /** Upcoming iterations to be created when iteration cadence is set to automatic. */
  iterationsInAdvance?: InputMaybe<Scalars['Int']>;
  /** Whether the iteration cadence should roll over issues to the next iteration or not. */
  rollOver?: InputMaybe<Scalars['Boolean']>;
  /** Timestamp of the automation start date. */
  startDate?: InputMaybe<Scalars['Time']>;
  /** Title of the iteration cadence. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of IterationCadenceUpdate */
export type IterationCadenceUpdatePayload = {
  __typename?: 'IterationCadenceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated iteration cadence. */
  iterationCadence?: Maybe<IterationCadence>;
};

/** The connection type for Iteration. */
export type IterationConnection = {
  __typename?: 'IterationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IterationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Iteration>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of IterationDelete */
export type IterationDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the iteration. */
  id: Scalars['IterationID'];
};

/** Autogenerated return type of IterationDelete */
export type IterationDeletePayload = {
  __typename?: 'IterationDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Group the iteration belongs to. */
  group: Group;
};

/** An edge in a connection. */
export type IterationEdge = {
  __typename?: 'IterationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Iteration>;
};

/** Fields to perform the search in */
export type IterationSearchableField =
  /** Search in cadence_title field. */
  | 'CADENCE_TITLE'
  /** Search in title field. */
  | 'TITLE';

/** Iteration sort values */
export type IterationSort =
  /** Sort by cadence id in ascending and due date in ascending order. */
  | 'CADENCE_AND_DUE_DATE_ASC'
  /** Sort by cadence id in ascending and due date in descending order. */
  | 'CADENCE_AND_DUE_DATE_DESC';

/** State of a GitLab iteration */
export type IterationState =
  /** Any iteration. */
  | 'all'
  /** Closed iteration. */
  | 'closed'
  /** Current iteration. */
  | 'current'
  /** Open iteration. */
  | 'opened'
  /** Upcoming iteration. */
  | 'upcoming';

/** Iteration ID wildcard values */
export type IterationWildcardId =
  /** An iteration is assigned. */
  | 'ANY'
  /** Current iteration. */
  | 'CURRENT'
  /** No iteration is assigned. */
  | 'NONE';

export type JiraImport = {
  __typename?: 'JiraImport';
  /** Timestamp of when the Jira import was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Count of issues that failed to import. */
  failedToImportCount: Scalars['Int'];
  /** Count of issues that were successfully imported. */
  importedIssuesCount: Scalars['Int'];
  /** Project key for the imported Jira project. */
  jiraProjectKey: Scalars['String'];
  /** Timestamp of when the Jira import was scheduled. */
  scheduledAt?: Maybe<Scalars['Time']>;
  /** User that started the Jira import. */
  scheduledBy?: Maybe<UserCore>;
  /** Total count of issues that were attempted to import. */
  totalIssueCount: Scalars['Int'];
};

/** The connection type for JiraImport. */
export type JiraImportConnection = {
  __typename?: 'JiraImportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraImportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JiraImport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraImportEdge = {
  __typename?: 'JiraImportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JiraImport>;
};

/** Autogenerated input type of JiraImportStart */
export type JiraImportStartInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project key of the importer Jira project. */
  jiraProjectKey: Scalars['String'];
  /** Project name of the importer Jira project. */
  jiraProjectName?: InputMaybe<Scalars['String']>;
  /** Project to import the Jira project into. */
  projectPath: Scalars['ID'];
  /** Mapping of Jira to GitLab users. */
  usersMapping?: InputMaybe<Array<JiraUsersMappingInputType>>;
};

/** Autogenerated return type of JiraImportStart */
export type JiraImportStartPayload = {
  __typename?: 'JiraImportStartPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Jira import data after mutation. */
  jiraImport?: Maybe<JiraImport>;
};

/** Autogenerated input type of JiraImportUsers */
export type JiraImportUsersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to import the Jira users into. */
  projectPath: Scalars['ID'];
  /** Index of the record the import should started at, default 0 (50 records returned). */
  startAt?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of JiraImportUsers */
export type JiraImportUsersPayload = {
  __typename?: 'JiraImportUsersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Users returned from Jira, matched by email and name if possible. */
  jiraUsers?: Maybe<Array<JiraUser>>;
};

export type JiraProject = {
  __typename?: 'JiraProject';
  /** Key of the Jira project. */
  key: Scalars['String'];
  /** Name of the Jira project. */
  name?: Maybe<Scalars['String']>;
  /** ID of the Jira project. */
  projectId: Scalars['Int'];
};

/** The connection type for JiraProject. */
export type JiraProjectConnection = {
  __typename?: 'JiraProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JiraProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JiraProject>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JiraProjectEdge = {
  __typename?: 'JiraProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JiraProject>;
};

export type JiraService = Service & {
  __typename?: 'JiraService';
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** List of all Jira projects fetched through Jira REST API. */
  projects?: Maybe<JiraProjectConnection>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']>;
};


export type JiraServiceProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};

export type JiraUser = {
  __typename?: 'JiraUser';
  /** ID of the matched GitLab user. */
  gitlabId?: Maybe<Scalars['Int']>;
  /** Name of the matched GitLab user. */
  gitlabName?: Maybe<Scalars['String']>;
  /** Username of the matched GitLab user. */
  gitlabUsername?: Maybe<Scalars['String']>;
  /** Account ID of the Jira user. */
  jiraAccountId: Scalars['String'];
  /** Display name of the Jira user. */
  jiraDisplayName: Scalars['String'];
  /** Email of the Jira user, returned only for users with public emails. */
  jiraEmail?: Maybe<Scalars['String']>;
};

export type JiraUsersMappingInputType = {
  /** ID of the GitLab user. */
  gitlabId?: InputMaybe<Scalars['Int']>;
  /** Jira account ID of the user. */
  jiraAccountId: Scalars['String'];
};

export type JobArtifactFileType =
  /** ACCESSIBILITY job artifact file type. */
  | 'ACCESSIBILITY'
  /** API FUZZING job artifact file type. */
  | 'API_FUZZING'
  /** ARCHIVE job artifact file type. */
  | 'ARCHIVE'
  /** BROWSER PERFORMANCE job artifact file type. */
  | 'BROWSER_PERFORMANCE'
  /** CLUSTER APPLICATIONS job artifact file type. */
  | 'CLUSTER_APPLICATIONS'
  /** CLUSTER IMAGE SCANNING job artifact file type. */
  | 'CLUSTER_IMAGE_SCANNING'
  /** COBERTURA job artifact file type. */
  | 'COBERTURA'
  /** CODE QUALITY job artifact file type. */
  | 'CODEQUALITY'
  /** CONTAINER SCANNING job artifact file type. */
  | 'CONTAINER_SCANNING'
  /** COVERAGE FUZZING job artifact file type. */
  | 'COVERAGE_FUZZING'
  /** CYCLONEDX job artifact file type. */
  | 'CYCLONEDX'
  /** DAST job artifact file type. */
  | 'DAST'
  /** DEPENDENCY SCANNING job artifact file type. */
  | 'DEPENDENCY_SCANNING'
  /** DOTENV job artifact file type. */
  | 'DOTENV'
  /** JUNIT job artifact file type. */
  | 'JUNIT'
  /** LICENSE SCANNING job artifact file type. */
  | 'LICENSE_SCANNING'
  /** LOAD PERFORMANCE job artifact file type. */
  | 'LOAD_PERFORMANCE'
  /** LSIF job artifact file type. */
  | 'LSIF'
  /** METADATA job artifact file type. */
  | 'METADATA'
  /** METRICS job artifact file type. */
  | 'METRICS'
  /** METRICS REFEREE job artifact file type. */
  | 'METRICS_REFEREE'
  /** NETWORK REFEREE job artifact file type. */
  | 'NETWORK_REFEREE'
  /** PERFORMANCE job artifact file type. */
  | 'PERFORMANCE'
  /** REQUIREMENTS job artifact file type. */
  | 'REQUIREMENTS'
  /** REQUIREMENTS V2 job artifact file type. */
  | 'REQUIREMENTS_V2'
  /** SAST job artifact file type. */
  | 'SAST'
  /** SECRET DETECTION job artifact file type. */
  | 'SECRET_DETECTION'
  /** TERRAFORM job artifact file type. */
  | 'TERRAFORM'
  /** TRACE job artifact file type. */
  | 'TRACE';

/** Represents the Geo replication and verification state of a job_artifact. */
export type JobArtifactRegistry = {
  __typename?: 'JobArtifactRegistry';
  /** ID of the Job Artifact. */
  artifactId: Scalars['ID'];
  /** Timestamp when the JobArtifactRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the JobArtifactRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the JobArtifactRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the JobArtifactRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the JobArtifactRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the JobArtifactRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the JobArtifactRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the JobArtifactRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the JobArtifactRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for JobArtifactRegistry. */
export type JobArtifactRegistryConnection = {
  __typename?: 'JobArtifactRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobArtifactRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobArtifactRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JobArtifactRegistryEdge = {
  __typename?: 'JobArtifactRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JobArtifactRegistry>;
};

/** Autogenerated input type of JobArtifactsDestroy */
export type JobArtifactsDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
};

/** Autogenerated return type of JobArtifactsDestroy */
export type JobArtifactsDestroyPayload = {
  __typename?: 'JobArtifactsDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Number of artifacts deleted. */
  destroyedArtifactsCount: Scalars['Int'];
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job with artifacts to be deleted. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobCancel */
export type JobCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
};

/** Autogenerated return type of JobCancel */
export type JobCancelPayload = {
  __typename?: 'JobCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

export type JobNeedUnion = CiBuildNeed | CiJob;

/** The connection type for JobNeedUnion. */
export type JobNeedUnionConnection = {
  __typename?: 'JobNeedUnionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobNeedUnionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<JobNeedUnion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type JobNeedUnionEdge = {
  __typename?: 'JobNeedUnionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<JobNeedUnion>;
};

export type JobPermissions = {
  __typename?: 'JobPermissions';
  /** Indicates the user can perform `read_build` on this resource */
  readBuild: Scalars['Boolean'];
  /** Indicates the user can perform `read_job_artifacts` on this resource */
  readJobArtifacts: Scalars['Boolean'];
  /** Indicates the user can perform `update_build` on this resource */
  updateBuild: Scalars['Boolean'];
};

/** Autogenerated input type of JobPlay */
export type JobPlayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** Variables to use when playing a manual job. */
  variables?: InputMaybe<Array<CiVariableInput>>;
};

/** Autogenerated return type of JobPlay */
export type JobPlayPayload = {
  __typename?: 'JobPlayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobRetry */
export type JobRetryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
  /** Variables to use when retrying a manual job. */
  variables?: InputMaybe<Array<CiVariableInput>>;
};

/** Autogenerated return type of JobRetry */
export type JobRetryPayload = {
  __typename?: 'JobRetryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

/** Autogenerated input type of JobUnschedule */
export type JobUnscheduleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the job to mutate. */
  id: Scalars['CiBuildID'];
};

/** Autogenerated return type of JobUnschedule */
export type JobUnschedulePayload = {
  __typename?: 'JobUnschedulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Job after the mutation. */
  job?: Maybe<CiJob>;
};

export type Kas = {
  __typename?: 'Kas';
  /** Indicates whether the Kubernetes Agent Server is enabled. */
  enabled: Scalars['Boolean'];
  /** URL used by the Agents to communicate with KAS. */
  externalUrl?: Maybe<Scalars['String']>;
  /** KAS version. */
  version?: Maybe<Scalars['String']>;
};

/** Represents an SSH key. */
export type Key = {
  __typename?: 'Key';
  /** Timestamp of when the key was created. */
  createdAt: Scalars['Time'];
  /** Timestamp of when the key expires. It's null if it never expires. */
  expiresAt: Scalars['Time'];
  /** ID of the key. */
  id: Scalars['ID'];
  /** Public key of the key pair. */
  key: Scalars['String'];
  /** Title of the key. */
  title: Scalars['String'];
};

export type Label = {
  __typename?: 'Label';
  /** Background color of the label. */
  color: Scalars['String'];
  /** When this label was created. */
  createdAt: Scalars['Time'];
  /** Description of the label (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Label ID. */
  id: Scalars['ID'];
  /** Text color of the label. */
  textColor: Scalars['String'];
  /** Content of the label. */
  title: Scalars['String'];
  /** When this label was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for Label. */
export type LabelConnection = {
  __typename?: 'LabelConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Label>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of LabelCreate */
export type LabelCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * The color of the label given in 6-digit hex notation with leading '#' sign
   * (for example, `#FFAABB`) or one of the CSS color names.
   */
  color?: InputMaybe<Scalars['String']>;
  /** Description of the label. */
  description?: InputMaybe<Scalars['String']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Title of the label. */
  title: Scalars['String'];
};

/** Autogenerated return type of LabelCreate */
export type LabelCreatePayload = {
  __typename?: 'LabelCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Label after mutation. */
  label?: Maybe<Label>;
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename?: 'LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

/** Represents the Geo sync and verification state of an LFS object */
export type LfsObjectRegistry = {
  __typename?: 'LfsObjectRegistry';
  /** Timestamp when the LfsObjectRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the LfsObjectRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the LfsObjectRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the LfsObjectRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the LFS object. */
  lfsObjectId: Scalars['ID'];
  /** Timestamp after which the LfsObjectRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the LfsObjectRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the LfsObjectRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the LfsObjectRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the LfsObjectRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for LfsObjectRegistry. */
export type LfsObjectRegistryConnection = {
  __typename?: 'LfsObjectRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LfsObjectRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LfsObjectRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LfsObjectRegistryEdge = {
  __typename?: 'LfsObjectRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<LfsObjectRegistry>;
};

/** Represents an entry from the Cloud License history */
export type LicenseHistoryEntry = {
  __typename?: 'LicenseHistoryEntry';
  /** Date when the license was activated. */
  activatedAt?: Maybe<Scalars['Date']>;
  /** Date, including grace period, when licensed features will be blocked. */
  blockChangesAt?: Maybe<Scalars['Date']>;
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']>;
  /** Date when the license was added. */
  createdAt?: Maybe<Scalars['Date']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']>;
  /** ID of the license extracted from the license data. */
  id: Scalars['ID'];
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']>;
  /** Name of the subscription plan. */
  plan: Scalars['String'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']>;
  /** Type of the license. */
  type: Scalars['String'];
  /** Number of paid users in the license. */
  usersInLicenseCount?: Maybe<Scalars['Int']>;
};

/** The connection type for LicenseHistoryEntry. */
export type LicenseHistoryEntryConnection = {
  __typename?: 'LicenseHistoryEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LicenseHistoryEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LicenseHistoryEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LicenseHistoryEntryEdge = {
  __typename?: 'LicenseHistoryEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<LicenseHistoryEntry>;
};

/** List limit metric setting */
export type ListLimitMetric =
  /** Limit list by number and total weight of issues. */
  | 'all_metrics'
  /** Limit list by number of issues. */
  | 'issue_count'
  /** Limit list by total weight of issues. */
  | 'issue_weights';

export type Location = {
  __typename?: 'Location';
  /** HTTP URI path to view the input file in GitLab. */
  blobPath?: Maybe<Scalars['String']>;
  /** Path, relative to the root of the repository, of the filewhich was analyzed to detect the dependency. */
  path?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MarkAsSpamSnippet */
export type MarkAsSpamSnippetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the snippet to update. */
  id: Scalars['SnippetID'];
};

/** Autogenerated return type of MarkAsSpamSnippet */
export type MarkAsSpamSnippetPayload = {
  __typename?: 'MarkAsSpamSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** List markup formats */
export type MarkupFormat =
  /** HTML format. */
  | 'HTML'
  /** Markdown format. */
  | 'MARKDOWN'
  /** Raw format. */
  | 'RAW';

/** Maven metadata */
export type MavenMetadata = {
  __typename?: 'MavenMetadata';
  /** App group of the Maven package. */
  appGroup: Scalars['String'];
  /** App name of the Maven package. */
  appName: Scalars['String'];
  /** App version of the Maven package. */
  appVersion?: Maybe<Scalars['String']>;
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the metadatum. */
  id: Scalars['PackagesMavenMetadatumID'];
  /** Path of the Maven package. */
  path: Scalars['String'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Possible identifier types for a measurement */
export type MeasurementIdentifier =
  /** Group count. */
  | 'GROUPS'
  /** Issue count. */
  | 'ISSUES'
  /** Merge request count. */
  | 'MERGE_REQUESTS'
  /** Pipeline count. */
  | 'PIPELINES'
  /** Pipeline count with canceled status. */
  | 'PIPELINES_CANCELED'
  /** Pipeline count with failed status. */
  | 'PIPELINES_FAILED'
  /** Pipeline count with skipped status. */
  | 'PIPELINES_SKIPPED'
  /** Pipeline count with success status. */
  | 'PIPELINES_SUCCEEDED'
  /** Project count. */
  | 'PROJECTS'
  /** User count. */
  | 'USERS';

/** Access level of a group or project member */
export type MemberAccessLevel =
  /** Developer access. */
  | 'DEVELOPER'
  /** Guest access. */
  | 'GUEST'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Minimal access. */
  | 'MINIMAL_ACCESS'
  /** Owner access. */
  | 'OWNER'
  /** Reporter access. */
  | 'REPORTER';

/** Name of access levels of a group or project member */
export type MemberAccessLevelName =
  /** Developer access. */
  | 'DEVELOPER'
  /** Guest access. */
  | 'GUEST'
  /** Maintainer access. */
  | 'MAINTAINER'
  /** Owner access. */
  | 'OWNER'
  /** Reporter access. */
  | 'REPORTER';

export type MemberInterface = {
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** ID of the member. */
  id: Scalars['ID'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
};


export type MemberInterfaceMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID'];
};

/** The connection type for MemberInterface. */
export type MemberInterfaceConnection = {
  __typename?: 'MemberInterfaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MemberInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MemberInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MemberInterfaceEdge = {
  __typename?: 'MemberInterfaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MemberInterface>;
};

/** Values for sorting members */
export type MemberSort =
  /** Access level ascending order. */
  | 'ACCESS_LEVEL_ASC'
  /** Access level descending order. */
  | 'ACCESS_LEVEL_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** User's full name ascending order. */
  | 'USER_FULL_NAME_ASC'
  /** User's full name descending order. */
  | 'USER_FULL_NAME_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Defines which user roles, users, or groups can merge into a protected branch. */
export type MergeAccessLevel = {
  __typename?: 'MergeAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int'];
  /** Human readable representation for this access level. */
  accessLevelDescription: Scalars['String'];
  /** Group associated with this access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with this access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for MergeAccessLevel. */
export type MergeAccessLevelConnection = {
  __typename?: 'MergeAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeAccessLevelEdge = {
  __typename?: 'MergeAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeAccessLevel>;
};

export type MergeRequest = CurrentUserTodos & NoteableInterface & Todoable & {
  __typename?: 'MergeRequest';
  /** Indicates if members of the target project can push to the fork. */
  allowCollaboration?: Maybe<Scalars['Boolean']>;
  /** Information relating to rules that must be satisfied to merge this merge request. */
  approvalState: MergeRequestApprovalState;
  /** Number of approvals left. */
  approvalsLeft?: Maybe<Scalars['Int']>;
  /** Number of approvals required. */
  approvalsRequired?: Maybe<Scalars['Int']>;
  /** Indicates if the merge request has all the required approvals. Returns true if no required approvals are configured. */
  approved: Scalars['Boolean'];
  /** Users who approved the merge request. */
  approvedBy?: Maybe<UserCoreConnection>;
  /** Assignees of the merge request. */
  assignees?: Maybe<MergeRequestAssigneeConnection>;
  /** User who created this merge request. */
  author?: Maybe<MergeRequestAuthor>;
  /** Indicates if auto merge is enabled for the merge request. */
  autoMergeEnabled: Scalars['Boolean'];
  /** Selected auto merge strategy. */
  autoMergeStrategy?: Maybe<Scalars['String']>;
  /** Array of available auto merge strategies. */
  availableAutoMergeStrategies?: Maybe<Array<Scalars['String']>>;
  /** List of award emojis associated with the merge request. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Number of commits in the merge request. */
  commitCount?: Maybe<Scalars['Int']>;
  /** Merge request commits. */
  commits?: Maybe<CommitConnection>;
  /** Merge request commits excluding merge commits. */
  commitsWithoutMergeCommits?: Maybe<CommitConnection>;
  /** Users who have added commits to the merge request. */
  committers?: Maybe<UserCoreConnection>;
  /** Indicates if the merge request has conflicts. */
  conflicts: Scalars['Boolean'];
  /** Timestamp of when the merge request was created. */
  createdAt: Scalars['Time'];
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Default merge commit message of the merge request. */
  defaultMergeCommitMessage?: Maybe<Scalars['String']>;
  /** Default squash commit message of the merge request. */
  defaultSquashCommitMessage?: Maybe<Scalars['String']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Detailed merge status of the merge request. */
  detailedMergeStatus?: Maybe<DetailedMergeStatus>;
  /** Diff head SHA of the merge request. */
  diffHeadSha?: Maybe<Scalars['String']>;
  /**
   * Diff summaries generated by AI Introduced in 16.1: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  diffLlmSummaries?: Maybe<MergeRequestDiffLlmSummaryConnection>;
  /** References of the base SHA, the head SHA, and the start SHA for this merge request. */
  diffRefs?: Maybe<DiffRefs>;
  /** Details about which files were changed in this merge request. */
  diffStats?: Maybe<Array<DiffStats>>;
  /** Summary of which files were changed in this merge request. */
  diffStatsSummary?: Maybe<DiffStatsSummary>;
  /** Indicates if comments on the merge request are locked to members only. */
  discussionLocked: Scalars['Boolean'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Indicates if the source branch is behind the target branch. */
  divergedFromTargetBranch: Scalars['Boolean'];
  /** Number of downvotes for the merge request. */
  downvotes: Scalars['Int'];
  /** Indicates if the merge request is a draft. */
  draft: Scalars['Boolean'];
  /**
   * Vulnerability finding reports comparison reported on the merge request.
   * Introduced in 16.1: This feature is an Experiment. It can be changed or
   * removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  findingReportsComparer?: Maybe<FindingReportsComparer>;
  /** Indicates if the project settings will lead to source branch deletion after merge. */
  forceRemoveSourceBranch?: Maybe<Scalars['Boolean']>;
  /** Indicates if the merge request has CI. */
  hasCi: Scalars['Boolean'];
  /** Indicates if the source branch has any security reports. */
  hasSecurityReports: Scalars['Boolean'];
  /** Pipeline running on the branch HEAD of the merge request. */
  headPipeline?: Maybe<Pipeline>;
  /** Human-readable time estimate of the merge request. */
  humanTimeEstimate?: Maybe<Scalars['String']>;
  /** Human-readable total time reported as spent on the merge request. */
  humanTotalTimeSpent?: Maybe<Scalars['String']>;
  /** ID of the merge request. */
  id: Scalars['ID'];
  /** Internal ID of the merge request. */
  iid: Scalars['String'];
  /** Commit SHA of the merge request if merge is in progress. */
  inProgressMergeCommitSha?: Maybe<Scalars['String']>;
  /** Labels of the merge request. */
  labels?: Maybe<LabelConnection>;
  /** SHA of the merge request commit (set once merged). */
  mergeCommitSha?: Maybe<Scalars['String']>;
  /** Error message due to a merge error. */
  mergeError?: Maybe<Scalars['String']>;
  /** Indicates if a merge is currently occurring. */
  mergeOngoing: Scalars['Boolean'];
  /**
   * Status of the merge request. Deprecated in 14.0: This was renamed.
   * @deprecated This was renamed. Please use `MergeRequest.mergeStatusEnum`. Deprecated in 14.0.
   */
  mergeStatus?: Maybe<Scalars['String']>;
  /** Merge status of the merge request. */
  mergeStatusEnum?: Maybe<MergeStatus>;
  /** Number of merge requests in the merge train. */
  mergeTrainsCount?: Maybe<Scalars['Int']>;
  /** User who merged this merge request or set it to auto-merge. */
  mergeUser?: Maybe<UserCore>;
  /** Indicates if the merge has been set to auto-merge. */
  mergeWhenPipelineSucceeds?: Maybe<Scalars['Boolean']>;
  /** Indicates if the merge request is mergeable. */
  mergeable: Scalars['Boolean'];
  /** Indicates if all discussions in the merge request have been resolved, allowing the merge request to be merged. */
  mergeableDiscussionsState?: Maybe<Scalars['Boolean']>;
  /** Timestamp of when the merge request was merged, null if not merged. */
  mergedAt?: Maybe<Scalars['Time']>;
  /** Milestone of the merge request. */
  milestone?: Maybe<Milestone>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Participants in the merge request. This includes the author, assignees, reviewers, and users mentioned in notes. */
  participants?: Maybe<MergeRequestParticipantConnection>;
  /**
   * Pipelines for the merge request. Note: for performance reasons, no more than
   * the most recent 500 pipelines will be returned.
   */
  pipelines?: Maybe<PipelineConnection>;
  /** Timestamp of when the merge request was prepared. */
  preparedAt?: Maybe<Scalars['Time']>;
  /** Alias for target_project. */
  project: Project;
  /** ID of the merge request project. */
  projectId: Scalars['Int'];
  /** Rebase commit SHA of the merge request. */
  rebaseCommitSha?: Maybe<Scalars['String']>;
  /** Indicates if there is a rebase currently in progress for the merge request. */
  rebaseInProgress: Scalars['Boolean'];
  /** Internal reference of the merge request. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** Users from whom a review has been requested. */
  reviewers?: Maybe<MergeRequestReviewerConnection>;
  /** Indicates if the merge request is created by @GitLab-Security-Bot. */
  securityAutoFix?: Maybe<Scalars['Boolean']>;
  /** Indicates if the target branch security reports are out of date. */
  securityReportsUpToDateOnTargetBranch: Scalars['Boolean'];
  /** Indicates if the merge request will be rebased. */
  shouldBeRebased: Scalars['Boolean'];
  /** Indicates if the source branch of the merge request will be deleted after merge. */
  shouldRemoveSourceBranch?: Maybe<Scalars['Boolean']>;
  /** Source branch of the merge request. */
  sourceBranch: Scalars['String'];
  /** Indicates if the source branch of the merge request exists. */
  sourceBranchExists: Scalars['Boolean'];
  /** Indicates if the source branch is protected. */
  sourceBranchProtected: Scalars['Boolean'];
  /** Source project of the merge request. */
  sourceProject?: Maybe<Project>;
  /** ID of the merge request source project. */
  sourceProjectId?: Maybe<Scalars['Int']>;
  /**
   * Indicates if the merge request is set to be squashed when merged. [Project settings](https://docs.gitlab.com/ee/user/project/merge_requests/squash_and_merge.html#configure-squash-options-for-a-project)
   * may override this value. Use `squash_on_merge` instead to take project squash
   * options into account.
   */
  squash: Scalars['Boolean'];
  /** Indicates if the merge request will be squashed when merged. */
  squashOnMerge: Scalars['Boolean'];
  /** State of the merge request. */
  state: MergeRequestState;
  /** Indicates if the currently logged in user is subscribed to this merge request. */
  subscribed: Scalars['Boolean'];
  /**
   * Suggested reviewers for merge request. Returns `null` if `suggested_reviewers`
   * feature flag is disabled. This flag is disabled by default and only available
   * on GitLab.com because the feature is experimental and is subject to change
   * without notice. Introduced in 15.4: This feature is an Experiment. It can be
   * changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.4.
   */
  suggestedReviewers?: Maybe<SuggestedReviewersType>;
  /** Target branch of the merge request. */
  targetBranch: Scalars['String'];
  /** Indicates if the target branch of the merge request exists. */
  targetBranchExists: Scalars['Boolean'];
  /** Target project of the merge request. */
  targetProject: Project;
  /** ID of the merge request target project. */
  targetProjectId: Scalars['Int'];
  /** Completion status of tasks */
  taskCompletionStatus: TaskCompletionStatus;
  /** Time estimate of the merge request. */
  timeEstimate: Scalars['Int'];
  /** Timelogs on the merge request. */
  timelogs: TimelogConnection;
  /** Title of the merge request. */
  title: Scalars['String'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Total time reported as spent on the merge request. */
  totalTimeSpent: Scalars['Int'];
  /** Timestamp of when the merge request was last updated. */
  updatedAt: Scalars['Time'];
  /** Number of upvotes for the merge request. */
  upvotes: Scalars['Int'];
  /** Number of user discussions in the merge request. */
  userDiscussionsCount?: Maybe<Scalars['Int']>;
  /** User notes count of the merge request. */
  userNotesCount?: Maybe<Scalars['Int']>;
  /** Permissions for the current user on the resource */
  userPermissions: MergeRequestPermissions;
  /** Web URL of the merge request. */
  webUrl?: Maybe<Scalars['String']>;
};


export type MergeRequestApprovedByArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommitsWithoutMergeCommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCommittersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};


export type MergeRequestDiffLlmSummariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestDiffStatsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


export type MergeRequestDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestFindingReportsComparerArgs = {
  reportType: ComparableSecurityReportType;
};


export type MergeRequestLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestPipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  ref?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<PipelineScopeEnum>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<PipelineStatusEnum>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


export type MergeRequestReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};


export type MergeRequestReviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MergeRequestTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of MergeRequestAccept */
export type MergeRequestAcceptInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Custom merge commit message. */
  commitMessage?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** HEAD SHA at the time when the merge was requested. */
  sha: Scalars['String'];
  /** Should the source branch be removed. */
  shouldRemoveSourceBranch?: InputMaybe<Scalars['Boolean']>;
  /** Squash commits on the source branch before merge. */
  squash?: InputMaybe<Scalars['Boolean']>;
  /** Custom squash commit message (if squash is true). */
  squashCommitMessage?: InputMaybe<Scalars['String']>;
  /** How to merge the merge request. */
  strategy?: InputMaybe<MergeStrategyEnum>;
};

/** Autogenerated return type of MergeRequestAccept */
export type MergeRequestAcceptPayload = {
  __typename?: 'MergeRequestAcceptPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Information relating to rules that must be satisfied to merge this merge request. */
export type MergeRequestApprovalState = {
  __typename?: 'MergeRequestApprovalState';
  /** Indicates if the merge request approval rules are overwritten for the merge request. */
  approvalRulesOverwritten?: Maybe<Scalars['Boolean']>;
  /** List of approval rules that are associated with the merge request, but invalid. */
  invalidApproversRules?: Maybe<Array<ApprovalRule>>;
  /** List of approval rules associated with the merge request. */
  rules?: Maybe<Array<ApprovalRule>>;
  /** List of suggested approvers. */
  suggestedApprovers?: Maybe<UserCoreConnection>;
};


/** Information relating to rules that must be satisfied to merge this merge request. */
export type MergeRequestApprovalStateSuggestedApproversArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A user assigned to a merge request. */
export type MergeRequestAssignee = User & {
  __typename?: 'MergeRequestAssignee';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. Will not return saved reply if `saved_replies` feature flag is disabled. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Twitter username of the user. */
  twitter?: Maybe<Scalars['String']>;
  /**
   * Achievements for the user. Only returns for namespaces where the
   * `achievements` feature flag is enabled. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID'];
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeStarredProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request. */
export type MergeRequestAssigneeWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

/** The connection type for MergeRequestAssignee. */
export type MergeRequestAssigneeConnection = {
  __typename?: 'MergeRequestAssigneeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestAssigneeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestAssignee>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestAssigneeEdge = {
  __typename?: 'MergeRequestAssigneeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestAssignee>;
};

/** The author of the merge request. */
export type MergeRequestAuthor = User & {
  __typename?: 'MergeRequestAuthor';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. Will not return saved reply if `saved_replies` feature flag is disabled. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Twitter username of the user. */
  twitter?: Maybe<Scalars['String']>;
  /**
   * Achievements for the user. Only returns for namespaces where the
   * `achievements` feature flag is enabled. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** The author of the merge request. */
export type MergeRequestAuthorAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID'];
};


/** The author of the merge request. */
export type MergeRequestAuthorSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** The author of the merge request. */
export type MergeRequestAuthorStarredProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** The author of the merge request. */
export type MergeRequestAuthorUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The author of the merge request. */
export type MergeRequestAuthorWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

/** The connection type for MergeRequest. */
export type MergeRequestConnection = {
  __typename?: 'MergeRequestConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total sum of time to merge, in seconds, for the collection of merge requests. */
  totalTimeToMerge?: Maybe<Scalars['Float']>;
};

/** Autogenerated input type of MergeRequestCreate */
export type MergeRequestCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: InputMaybe<Scalars['String']>;
  /** Labels of the merge request. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** Project full path the merge request is associated with. */
  projectPath: Scalars['ID'];
  /** Source branch of the merge request. */
  sourceBranch: Scalars['String'];
  /** Target branch of the merge request. */
  targetBranch: Scalars['String'];
  /** Title of the merge request. */
  title: Scalars['String'];
};

/** Autogenerated return type of MergeRequestCreate */
export type MergeRequestCreatePayload = {
  __typename?: 'MergeRequestCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** A diff summary generated by AI. */
export type MergeRequestDiffLlmSummary = {
  __typename?: 'MergeRequestDiffLlmSummary';
  /** Content of the diff summary. */
  content: Scalars['String'];
  /** Timestamp of when the diff summary was created. */
  createdAt: Scalars['Time'];
  /** ID of the Merge Request diff associated with the diff summary. */
  mergeRequestDiffId: Scalars['ID'];
  /** AI provider that generated the summary. */
  provider: Scalars['String'];
  /** Timestamp of when the diff summary was updated. */
  updatedAt: Scalars['Time'];
  /** User associated with the diff summary. */
  user?: Maybe<UserCore>;
};

/** The connection type for MergeRequestDiffLlmSummary. */
export type MergeRequestDiffLlmSummaryConnection = {
  __typename?: 'MergeRequestDiffLlmSummaryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestDiffLlmSummaryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestDiffLlmSummary>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestDiffLlmSummaryEdge = {
  __typename?: 'MergeRequestDiffLlmSummaryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestDiffLlmSummary>;
};

/** Represents the Geo sync and verification state of a Merge Request diff */
export type MergeRequestDiffRegistry = {
  __typename?: 'MergeRequestDiffRegistry';
  /** Timestamp when the MergeRequestDiffRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the MergeRequestDiffRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the MergeRequestDiffRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the MergeRequestDiffRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the Merge Request diff. */
  mergeRequestDiffId: Scalars['ID'];
  /** Timestamp after which the MergeRequestDiffRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the MergeRequestDiffRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the MergeRequestDiffRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the MergeRequestDiffRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the MergeRequestDiffRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for MergeRequestDiffRegistry. */
export type MergeRequestDiffRegistryConnection = {
  __typename?: 'MergeRequestDiffRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestDiffRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestDiffRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestDiffRegistryEdge = {
  __typename?: 'MergeRequestDiffRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestDiffRegistry>;
};

/** An edge in a connection. */
export type MergeRequestEdge = {
  __typename?: 'MergeRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequest>;
};

/** New state to apply to a merge request. */
export type MergeRequestNewState =
  /** Close the merge request if it is open. */
  | 'CLOSED'
  /** Open the merge request if it is closed. */
  | 'OPEN';

/** A user participating in a merge request. */
export type MergeRequestParticipant = User & {
  __typename?: 'MergeRequestParticipant';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. Will not return saved reply if `saved_replies` feature flag is disabled. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Twitter username of the user. */
  twitter?: Maybe<Scalars['String']>;
  /**
   * Achievements for the user. Only returns for namespaces where the
   * `achievements` feature flag is enabled. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID'];
};


/** A user participating in a merge request. */
export type MergeRequestParticipantSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantStarredProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user participating in a merge request. */
export type MergeRequestParticipantWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

/** The connection type for MergeRequestParticipant. */
export type MergeRequestParticipantConnection = {
  __typename?: 'MergeRequestParticipantConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestParticipantEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestParticipant>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestParticipantEdge = {
  __typename?: 'MergeRequestParticipantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestParticipant>;
};

/** Check permissions for the current user on a merge request */
export type MergeRequestPermissions = {
  __typename?: 'MergeRequestPermissions';
  /** Indicates the user can perform `admin_merge_request` on this resource */
  adminMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `can_approve` on this resource */
  canApprove: Scalars['Boolean'];
  /** Indicates the user can perform `can_merge` on this resource */
  canMerge: Scalars['Boolean'];
  /** Indicates the user can perform `cherry_pick_on_current_merge_request` on this resource */
  cherryPickOnCurrentMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `push_to_source_branch` on this resource */
  pushToSourceBranch: Scalars['Boolean'];
  /** Indicates the user can perform `read_merge_request` on this resource */
  readMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `remove_source_branch` on this resource */
  removeSourceBranch: Scalars['Boolean'];
  /** Indicates the user can perform `revert_on_current_merge_request` on this resource */
  revertOnCurrentMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `update_merge_request` on this resource */
  updateMergeRequest: Scalars['Boolean'];
};

/** State of a review of a GitLab merge request. */
export type MergeRequestReviewState =
  /** The merge request is reviewed. */
  | 'REVIEWED'
  /** The merge request is unreviewed. */
  | 'UNREVIEWED';

/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewer = User & {
  __typename?: 'MergeRequestReviewer';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /** Details of this user's interactions with the merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. Will not return saved reply if `saved_replies` feature flag is disabled. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Twitter username of the user. */
  twitter?: Maybe<Scalars['String']>;
  /**
   * Achievements for the user. Only returns for namespaces where the
   * `achievements` feature flag is enabled. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID'];
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerStarredProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user assigned to a merge request as a reviewer. */
export type MergeRequestReviewerWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

/** The connection type for MergeRequestReviewer. */
export type MergeRequestReviewerConnection = {
  __typename?: 'MergeRequestReviewerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MergeRequestReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MergeRequestReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MergeRequestReviewerEdge = {
  __typename?: 'MergeRequestReviewerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MergeRequestReviewer>;
};

/** Autogenerated input type of MergeRequestReviewerRereview */
export type MergeRequestReviewerRereviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** User ID for the user that has been requested for a new review. */
  userId: Scalars['UserID'];
};

/** Autogenerated return type of MergeRequestReviewerRereview */
export type MergeRequestReviewerRereviewPayload = {
  __typename?: 'MergeRequestReviewerRereviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetAssignees */
export type MergeRequestSetAssigneesInput = {
  /** Usernames to assign to the resource. Replaces existing assignees by default. */
  assigneeUsernames: Array<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of MergeRequestSetAssignees */
export type MergeRequestSetAssigneesPayload = {
  __typename?: 'MergeRequestSetAssigneesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetDraft */
export type MergeRequestSetDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to set the merge request as a draft. */
  draft: Scalars['Boolean'];
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of MergeRequestSetDraft */
export type MergeRequestSetDraftPayload = {
  __typename?: 'MergeRequestSetDraftPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetLabels */
export type MergeRequestSetLabelsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Label IDs to set. Replaces existing labels by default. */
  labelIds: Array<Scalars['LabelID']>;
  /** Changes the operation mode. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of MergeRequestSetLabels */
export type MergeRequestSetLabelsPayload = {
  __typename?: 'MergeRequestSetLabelsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetLocked */
export type MergeRequestSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Whether or not to lock the merge request. */
  locked: Scalars['Boolean'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of MergeRequestSetLocked */
export type MergeRequestSetLockedPayload = {
  __typename?: 'MergeRequestSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetMilestone */
export type MergeRequestSetMilestoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Milestone to assign to the merge request. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of MergeRequestSetMilestone */
export type MergeRequestSetMilestonePayload = {
  __typename?: 'MergeRequestSetMilestonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetReviewers */
export type MergeRequestSetReviewersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Operation to perform. Defaults to REPLACE. */
  operationMode?: InputMaybe<MutationOperationMode>;
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** Usernames of reviewers to assign. Replaces existing reviewers by default. */
  reviewerUsernames: Array<Scalars['String']>;
};

/** Autogenerated return type of MergeRequestSetReviewers */
export type MergeRequestSetReviewersPayload = {
  __typename?: 'MergeRequestSetReviewersPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestSetSubscription */
export type MergeRequestSetSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** Desired state of the subscription. */
  subscribedState: Scalars['Boolean'];
};

/** Autogenerated return type of MergeRequestSetSubscription */
export type MergeRequestSetSubscriptionPayload = {
  __typename?: 'MergeRequestSetSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Values for sorting merge requests */
export type MergeRequestSort =
  /** Closed time by ascending order. */
  | 'CLOSED_AT_ASC'
  /** Closed time by descending order. */
  | 'CLOSED_AT_DESC'
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Merge time by ascending order. */
  | 'MERGED_AT_ASC'
  /** Merge time by descending order. */
  | 'MERGED_AT_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** Priority by ascending order. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. */
  | 'PRIORITY_DESC'
  /** Title by ascending order. */
  | 'TITLE_ASC'
  /** Title by descending order. */
  | 'TITLE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** State of a GitLab merge request */
export type MergeRequestState =
  /** All available. */
  | 'all'
  /** In closed state. */
  | 'closed'
  /** Discussion has been locked. */
  | 'locked'
  /** Merge request has been merged. */
  | 'merged'
  /** In open state. */
  | 'opened';

/** Autogenerated input type of MergeRequestUpdateApprovalRule */
export type MergeRequestUpdateApprovalRuleInput = {
  /** ID of an approval rule. */
  approvalRuleId: Scalars['Int'];
  /** Number of required approvals for a given rule. */
  approvalsRequired: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IDs of groups as approvers. */
  groupIds?: InputMaybe<Array<Scalars['String']>>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Name of the approval rule. */
  name: Scalars['String'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** Whether hidden groups should be removed. */
  removeHiddenGroups?: InputMaybe<Array<Scalars['Boolean']>>;
  /** IDs of users as approvers. */
  userIds?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of MergeRequestUpdateApprovalRule */
export type MergeRequestUpdateApprovalRulePayload = {
  __typename?: 'MergeRequestUpdateApprovalRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of MergeRequestUpdate */
export type MergeRequestUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the merge request (Markdown rendered as HTML for caching). */
  description?: InputMaybe<Scalars['String']>;
  /** IID of the merge request to mutate. */
  iid: Scalars['String'];
  /** Project the merge request to mutate is in. */
  projectPath: Scalars['ID'];
  /** Action to perform to change the state. */
  state?: InputMaybe<MergeRequestNewState>;
  /** Target branch of the merge request. */
  targetBranch?: InputMaybe<Scalars['String']>;
  /** Estimated time to complete the merge request, or `0` to remove the current estimate. */
  timeEstimate?: InputMaybe<Scalars['String']>;
  /** Title of the merge request. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of MergeRequestUpdate */
export type MergeRequestUpdatePayload = {
  __typename?: 'MergeRequestUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge request after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

export type MergeRequestsResolverNegatedParams = {
  /** Array of label names. All resolved merge requests will not have these labels. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** Title of the milestone. */
  milestoneTitle?: InputMaybe<Scalars['String']>;
};

/** Representation of whether a GitLab merge request can be merged. */
export type MergeStatus =
  /** There are conflicts between the source and target branches. */
  | 'CANNOT_BE_MERGED'
  /** Currently unchecked. The previous state was `CANNOT_BE_MERGED`. */
  | 'CANNOT_BE_MERGED_RECHECK'
  /** There are no conflicts between the source and target branches. */
  | 'CAN_BE_MERGED'
  /** Currently checking for mergeability. */
  | 'CHECKING'
  /** Merge status has not been checked. */
  | 'UNCHECKED';

export type MergeStrategyEnum =
  /** Use the add_to_merge_train_when_pipeline_succeeds merge strategy. */
  | 'ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS'
  /** Use the merge_train merge strategy. */
  | 'MERGE_TRAIN'
  /** Use the merge_when_pipeline_succeeds merge strategy. */
  | 'MERGE_WHEN_PIPELINE_SUCCEEDS';

export type Metadata = {
  __typename?: 'Metadata';
  /** Enterprise edition. */
  enterprise: Scalars['Boolean'];
  /** Metadata about KAS. */
  kas: Kas;
  /** Revision. */
  revision: Scalars['String'];
  /** Version. */
  version: Scalars['String'];
};

/** Represents a metric image upload */
export type MetricImage = {
  __typename?: 'MetricImage';
  /** File name of the metric image. */
  fileName?: Maybe<Scalars['String']>;
  /** File path of the metric image. */
  filePath?: Maybe<Scalars['String']>;
  /** ID of the metric upload. */
  id: Scalars['ID'];
  /** Internal ID of the metric upload. */
  iid: Scalars['ID'];
  /** URL of the metric source. */
  url: Scalars['String'];
};

export type MetricsDashboard = {
  __typename?: 'MetricsDashboard';
  /** Annotations added to the dashboard. */
  annotations?: Maybe<MetricsDashboardAnnotationConnection>;
  /** Path to a file with the dashboard definition. */
  path?: Maybe<Scalars['String']>;
  /** Dashboard schema validation warnings. */
  schemaValidationWarnings?: Maybe<Array<Scalars['String']>>;
};


export type MetricsDashboardAnnotationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  from: Scalars['Time'];
  last?: InputMaybe<Scalars['Int']>;
  to?: InputMaybe<Scalars['Time']>;
};

export type MetricsDashboardAnnotation = {
  __typename?: 'MetricsDashboardAnnotation';
  /** Description of the annotation. */
  description?: Maybe<Scalars['String']>;
  /** Timestamp marking end of annotated time span. */
  endingAt?: Maybe<Scalars['Time']>;
  /** ID of the annotation. */
  id: Scalars['ID'];
  /** ID of a dashboard panel to which the annotation should be scoped. */
  panelId?: Maybe<Scalars['String']>;
  /** Timestamp marking start of annotated time span. */
  startingAt?: Maybe<Scalars['Time']>;
};

/** The connection type for MetricsDashboardAnnotation. */
export type MetricsDashboardAnnotationConnection = {
  __typename?: 'MetricsDashboardAnnotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MetricsDashboardAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MetricsDashboardAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MetricsDashboardAnnotationEdge = {
  __typename?: 'MetricsDashboardAnnotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MetricsDashboardAnnotation>;
};

/** Represents a milestone */
export type Milestone = TimeboxReportInterface & {
  __typename?: 'Milestone';
  /** Timestamp of milestone creation. */
  createdAt: Scalars['Time'];
  /** Description of the milestone. */
  description?: Maybe<Scalars['String']>;
  /** Timestamp of the milestone due date. */
  dueDate?: Maybe<Scalars['Time']>;
  /**
   * Expired state of the milestone (a milestone is expired when the due date is
   * past the current date). Defaults to `false` when due date has not been set.
   */
  expired: Scalars['Boolean'];
  /** Indicates if milestone is at group level. */
  groupMilestone: Scalars['Boolean'];
  /** ID of the milestone. */
  id: Scalars['ID'];
  /** Internal ID of the milestone. */
  iid: Scalars['ID'];
  /** Indicates if milestone is at project level. */
  projectMilestone: Scalars['Boolean'];
  /** Releases associated with this milestone. */
  releases?: Maybe<ReleaseConnection>;
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
  /** Timestamp of the milestone start date. */
  startDate?: Maybe<Scalars['Time']>;
  /** State of the milestone. */
  state: MilestoneStateEnum;
  /** Milestone statistics. */
  stats?: Maybe<MilestoneStats>;
  /** Indicates if milestone is at subgroup level. */
  subgroupMilestone: Scalars['Boolean'];
  /** Title of the milestone. */
  title: Scalars['String'];
  /** Timestamp of last milestone update. */
  updatedAt: Scalars['Time'];
  /** Web path of the milestone. */
  webPath: Scalars['String'];
};


/** Represents a milestone */
export type MilestoneReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a milestone */
export type MilestoneReportArgs = {
  fullPath?: InputMaybe<Scalars['String']>;
};

/** The connection type for Milestone. */
export type MilestoneConnection = {
  __typename?: 'MilestoneConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MilestoneEdge = {
  __typename?: 'MilestoneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Milestone>;
};

/** Values for sorting milestones */
export type MilestoneSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Milestone due date by ascending order. */
  | 'DUE_DATE_ASC'
  /** Milestone due date by descending order. */
  | 'DUE_DATE_DESC'
  /**
   * Group milestones in this order: non-expired milestones with due dates,
   * non-expired milestones without due dates and expired milestones then sort by
   * due date in ascending order.
   */
  | 'EXPIRED_LAST_DUE_DATE_ASC'
  /**
   * Group milestones in this order: non-expired milestones with due dates,
   * non-expired milestones without due dates and expired milestones then sort by
   * due date in descending order.
   */
  | 'EXPIRED_LAST_DUE_DATE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Current state of milestone */
export type MilestoneStateEnum =
  /** Milestone is currently active. */
  | 'active'
  /** Milestone is closed. */
  | 'closed';

/** Contains statistics about a milestone */
export type MilestoneStats = {
  __typename?: 'MilestoneStats';
  /** Number of closed issues associated with the milestone. */
  closedIssuesCount?: Maybe<Scalars['Int']>;
  /** Total number of issues associated with the milestone. */
  totalIssuesCount?: Maybe<Scalars['Int']>;
};

/** Milestone ID wildcard values */
export type MilestoneWildcardId =
  /** Milestone is assigned. */
  | 'ANY'
  /** No milestone is assigned. */
  | 'NONE'
  /** Milestone assigned is open and started (start date <= today). */
  | 'STARTED'
  /** Milestone assigned is due in the future (due date > today). */
  | 'UPCOMING';

/** The position to which the adjacent object should be moved */
export type MoveType =
  /** Adjacent object is moved after the object that is being moved. */
  | 'after'
  /** Adjacent object is moved before the object that is being moved. */
  | 'before';

export type Mutation = {
  __typename?: 'Mutation';
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10. */
  achievementsAward?: Maybe<AchievementsAwardPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8. */
  achievementsCreate?: Maybe<AchievementsCreatePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11. */
  achievementsDelete?: Maybe<AchievementsDeletePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10. */
  achievementsRevoke?: Maybe<AchievementsRevokePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11. */
  achievementsUpdate?: Maybe<AchievementsUpdatePayload>;
  addProjectToSecurityDashboard?: Maybe<AddProjectToSecurityDashboardPayload>;
  adminSidekiqQueuesDeleteJobs?: Maybe<AdminSidekiqQueuesDeleteJobsPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11. */
  aiAction?: Maybe<AiActionPayload>;
  alertSetAssignees?: Maybe<AlertSetAssigneesPayload>;
  alertTodoCreate?: Maybe<AlertTodoCreatePayload>;
  approveDeployment?: Maybe<ApproveDeploymentPayload>;
  artifactDestroy?: Maybe<ArtifactDestroyPayload>;
  auditEventsStreamingDestinationEventsAdd?: Maybe<AuditEventsStreamingDestinationEventsAddPayload>;
  auditEventsStreamingDestinationEventsRemove?: Maybe<AuditEventsStreamingDestinationEventsRemovePayload>;
  auditEventsStreamingHeadersCreate?: Maybe<AuditEventsStreamingHeadersCreatePayload>;
  auditEventsStreamingHeadersDestroy?: Maybe<AuditEventsStreamingHeadersDestroyPayload>;
  auditEventsStreamingHeadersUpdate?: Maybe<AuditEventsStreamingHeadersUpdatePayload>;
  auditEventsStreamingInstanceHeadersCreate?: Maybe<AuditEventsStreamingInstanceHeadersCreatePayload>;
  auditEventsStreamingInstanceHeadersDestroy?: Maybe<AuditEventsStreamingInstanceHeadersDestroyPayload>;
  auditEventsStreamingInstanceHeadersUpdate?: Maybe<AuditEventsStreamingInstanceHeadersUpdatePayload>;
  awardEmojiAdd?: Maybe<AwardEmojiAddPayload>;
  awardEmojiRemove?: Maybe<AwardEmojiRemovePayload>;
  awardEmojiToggle?: Maybe<AwardEmojiTogglePayload>;
  boardEpicCreate?: Maybe<BoardEpicCreatePayload>;
  boardListCreate?: Maybe<BoardListCreatePayload>;
  boardListUpdateLimitMetrics?: Maybe<BoardListUpdateLimitMetricsPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0. */
  buildForecast?: Maybe<BuildForecastPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10. */
  bulkDestroyJobArtifacts?: Maybe<BulkDestroyJobArtifactsPayload>;
  /** **BETA** This endpoint is subject to change without notice. */
  bulkEnableDevopsAdoptionNamespaces?: Maybe<BulkEnableDevopsAdoptionNamespacesPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3. */
  bulkRunnerDelete?: Maybe<BulkRunnerDeletePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11. */
  catalogResourcesCreate?: Maybe<CatalogResourcesCreatePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0. */
  ciAiGenerateConfig?: Maybe<CiAiGenerateConfigPayload>;
  ciJobTokenScopeAddProject?: Maybe<CiJobTokenScopeAddProjectPayload>;
  ciJobTokenScopeRemoveProject?: Maybe<CiJobTokenScopeRemoveProjectPayload>;
  clusterAgentDelete?: Maybe<ClusterAgentDeletePayload>;
  clusterAgentTokenCreate?: Maybe<ClusterAgentTokenCreatePayload>;
  clusterAgentTokenRevoke?: Maybe<ClusterAgentTokenRevokePayload>;
  commitCreate?: Maybe<CommitCreatePayload>;
  /**
   * Configure Container Scanning for a project by enabling Container Scanning in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a merge request are part of the response.
   */
  configureContainerScanning?: Maybe<ConfigureContainerScanningPayload>;
  /**
   * Configure Dependency Scanning for a project by enabling Dependency Scanning in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a Merge Request are a part of the response.
   */
  configureDependencyScanning?: Maybe<ConfigureDependencyScanningPayload>;
  /**
   * Configure SAST for a project by enabling SAST in a new or modified
   * `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
   * create a Merge Request are a part of the response.
   */
  configureSast?: Maybe<ConfigureSastPayload>;
  /**
   * Enable SAST IaC for a project in a new or
   * modified `.gitlab-ci.yml` file in a new branch. The new
   * branch and a URL to create a merge request are a part of the
   * response.
   */
  configureSastIac?: Maybe<ConfigureSastIacPayload>;
  /**
   * Configure Secret Detection for a project by enabling Secret Detection
   * in a new or modified `.gitlab-ci.yml` file in a new branch. The new
   * branch and a URL to create a Merge Request are a part of the
   * response.
   */
  configureSecretDetection?: Maybe<ConfigureSecretDetectionPayload>;
  corpusCreate?: Maybe<CorpusCreatePayload>;
  createAlertIssue?: Maybe<CreateAlertIssuePayload>;
  /** @deprecated Underlying feature was removed in 16.0. Deprecated in 16.0. */
  createAnnotation?: Maybe<CreateAnnotationPayload>;
  createBoard?: Maybe<CreateBoardPayload>;
  createBranch?: Maybe<CreateBranchPayload>;
  createClusterAgent?: Maybe<CreateClusterAgentPayload>;
  createComplianceFramework?: Maybe<CreateComplianceFrameworkPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 13.6. */
  createCustomEmoji?: Maybe<CreateCustomEmojiPayload>;
  createDiffNote?: Maybe<CreateDiffNotePayload>;
  createEpic?: Maybe<CreateEpicPayload>;
  createImageDiffNote?: Maybe<CreateImageDiffNotePayload>;
  createIssue?: Maybe<CreateIssuePayload>;
  /** @deprecated Use iterationCreate. Deprecated in 14.0. */
  createIteration?: Maybe<CreateIterationPayload>;
  /**
   * Creates a Note.
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   */
  createNote?: Maybe<CreateNotePayload>;
  createRequirement?: Maybe<CreateRequirementPayload>;
  createSnippet?: Maybe<CreateSnippetPayload>;
  createTestCase?: Maybe<CreateTestCasePayload>;
  customerRelationsContactCreate?: Maybe<CustomerRelationsContactCreatePayload>;
  customerRelationsContactUpdate?: Maybe<CustomerRelationsContactUpdatePayload>;
  customerRelationsOrganizationCreate?: Maybe<CustomerRelationsOrganizationCreatePayload>;
  customerRelationsOrganizationUpdate?: Maybe<CustomerRelationsOrganizationUpdatePayload>;
  dastOnDemandScanCreate?: Maybe<DastOnDemandScanCreatePayload>;
  dastProfileCreate?: Maybe<DastProfileCreatePayload>;
  dastProfileDelete?: Maybe<DastProfileDeletePayload>;
  dastProfileRun?: Maybe<DastProfileRunPayload>;
  dastProfileUpdate?: Maybe<DastProfileUpdatePayload>;
  dastScannerProfileCreate?: Maybe<DastScannerProfileCreatePayload>;
  dastScannerProfileDelete?: Maybe<DastScannerProfileDeletePayload>;
  dastScannerProfileUpdate?: Maybe<DastScannerProfileUpdatePayload>;
  dastSiteProfileCreate?: Maybe<DastSiteProfileCreatePayload>;
  dastSiteProfileDelete?: Maybe<DastSiteProfileDeletePayload>;
  dastSiteProfileUpdate?: Maybe<DastSiteProfileUpdatePayload>;
  dastSiteTokenCreate?: Maybe<DastSiteTokenCreatePayload>;
  dastSiteValidationCreate?: Maybe<DastSiteValidationCreatePayload>;
  dastSiteValidationRevoke?: Maybe<DastSiteValidationRevokePayload>;
  /** @deprecated Underlying feature was removed in 16.0. Deprecated in 16.0. */
  deleteAnnotation?: Maybe<DeleteAnnotationPayload>;
  designManagementDelete?: Maybe<DesignManagementDeletePayload>;
  designManagementMove?: Maybe<DesignManagementMovePayload>;
  designManagementUpdate?: Maybe<DesignManagementUpdatePayload>;
  designManagementUpload?: Maybe<DesignManagementUploadPayload>;
  destroyBoard?: Maybe<DestroyBoardPayload>;
  destroyBoardList?: Maybe<DestroyBoardListPayload>;
  destroyComplianceFramework?: Maybe<DestroyComplianceFrameworkPayload>;
  destroyContainerRepository?: Maybe<DestroyContainerRepositoryPayload>;
  destroyContainerRepositoryTags?: Maybe<DestroyContainerRepositoryTagsPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 13.6. */
  destroyCustomEmoji?: Maybe<DestroyCustomEmojiPayload>;
  destroyEpicBoard?: Maybe<DestroyEpicBoardPayload>;
  destroyNote?: Maybe<DestroyNotePayload>;
  destroyPackage?: Maybe<DestroyPackagePayload>;
  destroyPackageFile?: Maybe<DestroyPackageFilePayload>;
  destroyPackageFiles?: Maybe<DestroyPackageFilesPayload>;
  destroyPackages?: Maybe<DestroyPackagesPayload>;
  destroySnippet?: Maybe<DestroySnippetPayload>;
  /** **BETA** This endpoint is subject to change without notice. */
  disableDevopsAdoptionNamespace?: Maybe<DisableDevopsAdoptionNamespacePayload>;
  /** Toggles the resolved state of a discussion */
  discussionToggleResolve?: Maybe<DiscussionToggleResolvePayload>;
  /**
   * A mutation that does not perform any changes.
   *
   * This is expected to be used for testing of endpoints, to verify
   * that a user has mutation access.
   */
  echoCreate?: Maybe<EchoCreatePayload>;
  /** **BETA** This endpoint is subject to change without notice. */
  enableDevopsAdoptionNamespace?: Maybe<EnableDevopsAdoptionNamespacePayload>;
  /** Create an environment. */
  environmentCreate?: Maybe<EnvironmentCreatePayload>;
  /** Delete an environment. */
  environmentDelete?: Maybe<EnvironmentDeletePayload>;
  /** Stop an environment. */
  environmentStop?: Maybe<EnvironmentStopPayload>;
  /** Update an environment. */
  environmentUpdate?: Maybe<EnvironmentUpdatePayload>;
  /**
   * **Deprecated** This endpoint is planned to be removed along with
   * certificate-based clusters. [See this
   * epic](https://gitlab.com/groups/gitlab-org/configure/-/epics/8) for more information.
   */
  environmentsCanaryIngressUpdate?: Maybe<EnvironmentsCanaryIngressUpdatePayload>;
  epicAddIssue?: Maybe<EpicAddIssuePayload>;
  epicBoardCreate?: Maybe<EpicBoardCreatePayload>;
  epicBoardListCreate?: Maybe<EpicBoardListCreatePayload>;
  /** Destroys an epic board list. */
  epicBoardListDestroy?: Maybe<EpicBoardListDestroyPayload>;
  epicBoardUpdate?: Maybe<EpicBoardUpdatePayload>;
  epicMoveList?: Maybe<EpicMoveListPayload>;
  epicSetSubscription?: Maybe<EpicSetSubscriptionPayload>;
  epicTreeReorder?: Maybe<EpicTreeReorderPayload>;
  escalationPolicyCreate?: Maybe<EscalationPolicyCreatePayload>;
  escalationPolicyDestroy?: Maybe<EscalationPolicyDestroyPayload>;
  escalationPolicyUpdate?: Maybe<EscalationPolicyUpdatePayload>;
  exportRequirements?: Maybe<ExportRequirementsPayload>;
  externalAuditEventDestinationCreate?: Maybe<ExternalAuditEventDestinationCreatePayload>;
  externalAuditEventDestinationDestroy?: Maybe<ExternalAuditEventDestinationDestroyPayload>;
  externalAuditEventDestinationUpdate?: Maybe<ExternalAuditEventDestinationUpdatePayload>;
  /**
   * Mutates a Geo registry. Does not mutate the registry entry if
   * `geo_registries_update_mutation` feature flag is disabled. Introduced in 16.1:
   * This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  geoRegistriesUpdate?: Maybe<GeoRegistriesUpdatePayload>;
  gitlabSubscriptionActivate?: Maybe<GitlabSubscriptionActivatePayload>;
  googleCloudLoggingConfigurationCreate?: Maybe<GoogleCloudLoggingConfigurationCreatePayload>;
  googleCloudLoggingConfigurationDestroy?: Maybe<GoogleCloudLoggingConfigurationDestroyPayload>;
  googleCloudLoggingConfigurationUpdate?: Maybe<GoogleCloudLoggingConfigurationUpdatePayload>;
  groupMemberBulkUpdate?: Maybe<GroupMemberBulkUpdatePayload>;
  groupUpdate?: Maybe<GroupUpdatePayload>;
  httpIntegrationCreate?: Maybe<HttpIntegrationCreatePayload>;
  httpIntegrationDestroy?: Maybe<HttpIntegrationDestroyPayload>;
  httpIntegrationResetToken?: Maybe<HttpIntegrationResetTokenPayload>;
  httpIntegrationUpdate?: Maybe<HttpIntegrationUpdatePayload>;
  instanceExternalAuditEventDestinationCreate?: Maybe<InstanceExternalAuditEventDestinationCreatePayload>;
  instanceExternalAuditEventDestinationDestroy?: Maybe<InstanceExternalAuditEventDestinationDestroyPayload>;
  instanceExternalAuditEventDestinationUpdate?: Maybe<InstanceExternalAuditEventDestinationUpdatePayload>;
  issuableResourceLinkCreate?: Maybe<IssuableResourceLinkCreatePayload>;
  issuableResourceLinkDestroy?: Maybe<IssuableResourceLinkDestroyPayload>;
  issueLinkAlerts?: Maybe<IssueLinkAlertsPayload>;
  issueMove?: Maybe<IssueMovePayload>;
  issueMoveList?: Maybe<IssueMoveListPayload>;
  issueSetAssignees?: Maybe<IssueSetAssigneesPayload>;
  issueSetConfidential?: Maybe<IssueSetConfidentialPayload>;
  issueSetCrmContacts?: Maybe<IssueSetCrmContactsPayload>;
  issueSetDueDate?: Maybe<IssueSetDueDatePayload>;
  issueSetEpic?: Maybe<IssueSetEpicPayload>;
  issueSetEscalationPolicy?: Maybe<IssueSetEscalationPolicyPayload>;
  issueSetEscalationStatus?: Maybe<IssueSetEscalationStatusPayload>;
  issueSetIteration?: Maybe<IssueSetIterationPayload>;
  issueSetLocked?: Maybe<IssueSetLockedPayload>;
  issueSetSeverity?: Maybe<IssueSetSeverityPayload>;
  issueSetSubscription?: Maybe<IssueSetSubscriptionPayload>;
  issueSetWeight?: Maybe<IssueSetWeightPayload>;
  issueUnlinkAlert?: Maybe<IssueUnlinkAlertPayload>;
  /**
   * Allows updating several properties for a set of issues. Does nothing if the
   * `bulk_update_issues_mutation` feature flag is disabled. Introduced in 15.9:
   * This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  issuesBulkUpdate?: Maybe<IssuesBulkUpdatePayload>;
  iterationCadenceCreate?: Maybe<IterationCadenceCreatePayload>;
  iterationCadenceDestroy?: Maybe<IterationCadenceDestroyPayload>;
  iterationCadenceUpdate?: Maybe<IterationCadenceUpdatePayload>;
  iterationCreate?: Maybe<IterationCreatePayload>;
  iterationDelete?: Maybe<IterationDeletePayload>;
  jiraImportStart?: Maybe<JiraImportStartPayload>;
  jiraImportUsers?: Maybe<JiraImportUsersPayload>;
  jobArtifactsDestroy?: Maybe<JobArtifactsDestroyPayload>;
  jobCancel?: Maybe<JobCancelPayload>;
  jobPlay?: Maybe<JobPlayPayload>;
  jobRetry?: Maybe<JobRetryPayload>;
  jobUnschedule?: Maybe<JobUnschedulePayload>;
  labelCreate?: Maybe<LabelCreatePayload>;
  markAsSpamSnippet?: Maybe<MarkAsSpamSnippetPayload>;
  /**
   * Accepts a merge request.
   * When accepted, the source branch will be merged into the target branch, either
   * immediately if possible, or using one of the automatic merge strategies.
   */
  mergeRequestAccept?: Maybe<MergeRequestAcceptPayload>;
  mergeRequestCreate?: Maybe<MergeRequestCreatePayload>;
  mergeRequestReviewerRereview?: Maybe<MergeRequestReviewerRereviewPayload>;
  mergeRequestSetAssignees?: Maybe<MergeRequestSetAssigneesPayload>;
  mergeRequestSetDraft?: Maybe<MergeRequestSetDraftPayload>;
  mergeRequestSetLabels?: Maybe<MergeRequestSetLabelsPayload>;
  mergeRequestSetLocked?: Maybe<MergeRequestSetLockedPayload>;
  mergeRequestSetMilestone?: Maybe<MergeRequestSetMilestonePayload>;
  mergeRequestSetReviewers?: Maybe<MergeRequestSetReviewersPayload>;
  mergeRequestSetSubscription?: Maybe<MergeRequestSetSubscriptionPayload>;
  /** Update attributes of a merge request */
  mergeRequestUpdate?: Maybe<MergeRequestUpdatePayload>;
  mergeRequestUpdateApprovalRule?: Maybe<MergeRequestUpdateApprovalRulePayload>;
  namespaceBanDestroy?: Maybe<NamespaceBanDestroyPayload>;
  namespaceCiCdSettingsUpdate?: Maybe<NamespaceCiCdSettingsUpdatePayload>;
  namespaceIncreaseStorageTemporarily?: Maybe<NamespaceIncreaseStorageTemporarilyPayload>;
  oncallRotationCreate?: Maybe<OncallRotationCreatePayload>;
  oncallRotationDestroy?: Maybe<OncallRotationDestroyPayload>;
  oncallRotationUpdate?: Maybe<OncallRotationUpdatePayload>;
  oncallScheduleCreate?: Maybe<OncallScheduleCreatePayload>;
  oncallScheduleDestroy?: Maybe<OncallScheduleDestroyPayload>;
  oncallScheduleUpdate?: Maybe<OncallScheduleUpdatePayload>;
  pagesMarkOnboardingComplete?: Maybe<PagesMarkOnboardingCompletePayload>;
  pipelineCancel?: Maybe<PipelineCancelPayload>;
  pipelineDestroy?: Maybe<PipelineDestroyPayload>;
  pipelineRetry?: Maybe<PipelineRetryPayload>;
  pipelineScheduleCreate?: Maybe<PipelineScheduleCreatePayload>;
  pipelineScheduleDelete?: Maybe<PipelineScheduleDeletePayload>;
  pipelineSchedulePlay?: Maybe<PipelineSchedulePlayPayload>;
  pipelineScheduleTakeOwnership?: Maybe<PipelineScheduleTakeOwnershipPayload>;
  pipelineScheduleUpdate?: Maybe<PipelineScheduleUpdatePayload>;
  projectCiCdSettingsUpdate?: Maybe<ProjectCiCdSettingsUpdatePayload>;
  projectInitializeProductAnalytics?: Maybe<ProjectInitializeProductAnalyticsPayload>;
  /** Updates multiple members of a project. To use this mutation, you must have at least the Maintainer role. */
  projectMemberBulkUpdate?: Maybe<ProjectMemberBulkUpdatePayload>;
  /** Assign (or unset) a compliance framework to a project. */
  projectSetComplianceFramework?: Maybe<ProjectSetComplianceFrameworkPayload>;
  projectSetLocked?: Maybe<ProjectSetLockedPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9. */
  projectSyncFork?: Maybe<ProjectSyncForkPayload>;
  prometheusIntegrationCreate?: Maybe<PrometheusIntegrationCreatePayload>;
  prometheusIntegrationResetToken?: Maybe<PrometheusIntegrationResetTokenPayload>;
  prometheusIntegrationUpdate?: Maybe<PrometheusIntegrationUpdatePayload>;
  promoteToEpic?: Maybe<PromoteToEpicPayload>;
  releaseAssetLinkCreate?: Maybe<ReleaseAssetLinkCreatePayload>;
  releaseAssetLinkDelete?: Maybe<ReleaseAssetLinkDeletePayload>;
  releaseAssetLinkUpdate?: Maybe<ReleaseAssetLinkUpdatePayload>;
  releaseCreate?: Maybe<ReleaseCreatePayload>;
  releaseDelete?: Maybe<ReleaseDeletePayload>;
  releaseUpdate?: Maybe<ReleaseUpdatePayload>;
  removeProjectFromSecurityDashboard?: Maybe<RemoveProjectFromSecurityDashboardPayload>;
  /** Repositions a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`) */
  repositionImageDiffNote?: Maybe<RepositionImageDiffNotePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10. */
  runnerCreate?: Maybe<RunnerCreatePayload>;
  runnerDelete?: Maybe<RunnerDeletePayload>;
  runnerUpdate?: Maybe<RunnerUpdatePayload>;
  runnersRegistrationTokenReset?: Maybe<RunnersRegistrationTokenResetPayload>;
  savedReplyCreate?: Maybe<SavedReplyCreatePayload>;
  savedReplyDestroy?: Maybe<SavedReplyDestroyPayload>;
  savedReplyUpdate?: Maybe<SavedReplyUpdatePayload>;
  /** Commits the `policy_yaml` content to the assigned security policy project for the given project (`full_path`) */
  scanExecutionPolicyCommit?: Maybe<ScanExecutionPolicyCommitPayload>;
  securityFindingCreateIssue?: Maybe<SecurityFindingCreateIssuePayload>;
  securityFindingCreateMergeRequest?: Maybe<SecurityFindingCreateMergeRequestPayload>;
  securityFindingDismiss?: Maybe<SecurityFindingDismissPayload>;
  securityFindingRevertToDetected?: Maybe<SecurityFindingRevertToDetectedPayload>;
  /**
   * Assigns the specified project(`security_policy_project_id`) as security policy
   * project for the given project(`full_path`). If the project already has a
   * security policy project, this reassigns the project's security policy project
   * with the given `security_policy_project_id`
   */
  securityPolicyProjectAssign?: Maybe<SecurityPolicyProjectAssignPayload>;
  /** Creates and assigns a security policy project for the given project (`full_path`) */
  securityPolicyProjectCreate?: Maybe<SecurityPolicyProjectCreatePayload>;
  /** Unassigns the security policy project for the given project (`full_path`). */
  securityPolicyProjectUnassign?: Maybe<SecurityPolicyProjectUnassignPayload>;
  securityTrainingUpdate?: Maybe<SecurityTrainingUpdatePayload>;
  terraformStateDelete?: Maybe<TerraformStateDeletePayload>;
  terraformStateLock?: Maybe<TerraformStateLockPayload>;
  terraformStateUnlock?: Maybe<TerraformStateUnlockPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6. */
  timelineEventCreate?: Maybe<TimelineEventCreatePayload>;
  timelineEventDestroy?: Maybe<TimelineEventDestroyPayload>;
  timelineEventPromoteFromNote?: Maybe<TimelineEventPromoteFromNotePayload>;
  timelineEventTagCreate?: Maybe<TimelineEventTagCreatePayload>;
  timelineEventUpdate?: Maybe<TimelineEventUpdatePayload>;
  timelogCreate?: Maybe<TimelogCreatePayload>;
  timelogDelete?: Maybe<TimelogDeletePayload>;
  todoCreate?: Maybe<TodoCreatePayload>;
  todoMarkDone?: Maybe<TodoMarkDonePayload>;
  todoRestore?: Maybe<TodoRestorePayload>;
  todoRestoreMany?: Maybe<TodoRestoreManyPayload>;
  todosMarkAllDone?: Maybe<TodosMarkAllDonePayload>;
  updateAlertStatus?: Maybe<UpdateAlertStatusPayload>;
  updateBoard?: Maybe<UpdateBoardPayload>;
  updateBoardEpicUserPreferences?: Maybe<UpdateBoardEpicUserPreferencesPayload>;
  updateBoardList?: Maybe<UpdateBoardListPayload>;
  updateComplianceFramework?: Maybe<UpdateComplianceFrameworkPayload>;
  updateContainerExpirationPolicy?: Maybe<UpdateContainerExpirationPolicyPayload>;
  /**
   * These settings can be adjusted by the group Owner or Maintainer.
   * [Issue 370471](https://gitlab.com/gitlab-org/gitlab/-/issues/370471) proposes limiting
   * this to Owners only to match the permissions level in the user interface.
   */
  updateDependencyProxyImageTtlGroupPolicy?: Maybe<UpdateDependencyProxyImageTtlGroupPolicyPayload>;
  /**
   * These settings can be adjusted by the group Owner or Maintainer.
   * [Issue 370471](https://gitlab.com/gitlab-org/gitlab/-/issues/370471) proposes limiting
   * this to Owners only to match the permissions level in the user interface.
   */
  updateDependencyProxySettings?: Maybe<UpdateDependencyProxySettingsPayload>;
  updateEpic?: Maybe<UpdateEpicPayload>;
  updateEpicBoardList?: Maybe<UpdateEpicBoardListPayload>;
  /**
   * Updates a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`).
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   */
  updateImageDiffNote?: Maybe<UpdateImageDiffNotePayload>;
  updateIssue?: Maybe<UpdateIssuePayload>;
  updateIteration?: Maybe<UpdateIterationPayload>;
  /**
   * These settings can be adjusted by the group Owner or Maintainer.
   * [Issue 370471](https://gitlab.com/gitlab-org/gitlab/-/issues/370471) proposes limiting
   * this to Owners only to match the permissions level in the user interface.
   */
  updateNamespacePackageSettings?: Maybe<UpdateNamespacePackageSettingsPayload>;
  /**
   * Updates a Note.
   * If the body of the Note contains only quick actions,
   * the Note will be destroyed during an update, and no Note will be
   * returned.
   */
  updateNote?: Maybe<UpdateNotePayload>;
  updatePackagesCleanupPolicy?: Maybe<UpdatePackagesCleanupPolicyPayload>;
  updateRequirement?: Maybe<UpdateRequirementPayload>;
  updateSnippet?: Maybe<UpdateSnippetPayload>;
  /** Deletes an upload. */
  uploadDelete?: Maybe<UploadDeletePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1. */
  userAchievementsDelete?: Maybe<UserAchievementsDeletePayload>;
  userCalloutCreate?: Maybe<UserCalloutCreatePayload>;
  userPreferencesUpdate?: Maybe<UserPreferencesUpdatePayload>;
  userSetNamespaceCommitEmail?: Maybe<UserSetNamespaceCommitEmailPayload>;
  vulnerabilityConfirm?: Maybe<VulnerabilityConfirmPayload>;
  vulnerabilityCreate?: Maybe<VulnerabilityCreatePayload>;
  vulnerabilityDismiss?: Maybe<VulnerabilityDismissPayload>;
  vulnerabilityExternalIssueLinkCreate?: Maybe<VulnerabilityExternalIssueLinkCreatePayload>;
  vulnerabilityExternalIssueLinkDestroy?: Maybe<VulnerabilityExternalIssueLinkDestroyPayload>;
  vulnerabilityIssueLinkCreate?: Maybe<VulnerabilityIssueLinkCreatePayload>;
  vulnerabilityResolve?: Maybe<VulnerabilityResolvePayload>;
  vulnerabilityRevertToDetected?: Maybe<VulnerabilityRevertToDetectedPayload>;
  /**
   * Converts the work item to a new type Introduced in 15.11: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  workItemConvert?: Maybe<WorkItemConvertPayload>;
  /**
   * Creates a work item. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemCreate?: Maybe<WorkItemCreatePayload>;
  /**
   * Creates a work item from a task in another work item's description. Introduced
   * in 15.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemCreateFromTask?: Maybe<WorkItemCreateFromTaskPayload>;
  /**
   * Deletes a work item. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemDelete?: Maybe<WorkItemDeletePayload>;
  /**
   * Deletes a task in a work item's description. Introduced in 15.1: This feature
   * is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemDeleteTask?: Maybe<WorkItemDeleteTaskPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10. */
  workItemExport?: Maybe<WorkItemExportPayload>;
  /**
   * Updates a work item by Global ID. Introduced in 15.1: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemUpdate?: Maybe<WorkItemUpdatePayload>;
  /**
   * Updates a work item's task by Global ID. Introduced in 15.1: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItemUpdateTask?: Maybe<WorkItemUpdateTaskPayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0. */
  workspaceCreate?: Maybe<WorkspaceCreatePayload>;
  /** @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0. */
  workspaceUpdate?: Maybe<WorkspaceUpdatePayload>;
};


export type MutationAchievementsAwardArgs = {
  input: AchievementsAwardInput;
};


export type MutationAchievementsCreateArgs = {
  input: AchievementsCreateInput;
};


export type MutationAchievementsDeleteArgs = {
  input: AchievementsDeleteInput;
};


export type MutationAchievementsRevokeArgs = {
  input: AchievementsRevokeInput;
};


export type MutationAchievementsUpdateArgs = {
  input: AchievementsUpdateInput;
};


export type MutationAddProjectToSecurityDashboardArgs = {
  input: AddProjectToSecurityDashboardInput;
};


export type MutationAdminSidekiqQueuesDeleteJobsArgs = {
  input: AdminSidekiqQueuesDeleteJobsInput;
};


export type MutationAiActionArgs = {
  input: AiActionInput;
};


export type MutationAlertSetAssigneesArgs = {
  input: AlertSetAssigneesInput;
};


export type MutationAlertTodoCreateArgs = {
  input: AlertTodoCreateInput;
};


export type MutationApproveDeploymentArgs = {
  input: ApproveDeploymentInput;
};


export type MutationArtifactDestroyArgs = {
  input: ArtifactDestroyInput;
};


export type MutationAuditEventsStreamingDestinationEventsAddArgs = {
  input: AuditEventsStreamingDestinationEventsAddInput;
};


export type MutationAuditEventsStreamingDestinationEventsRemoveArgs = {
  input: AuditEventsStreamingDestinationEventsRemoveInput;
};


export type MutationAuditEventsStreamingHeadersCreateArgs = {
  input: AuditEventsStreamingHeadersCreateInput;
};


export type MutationAuditEventsStreamingHeadersDestroyArgs = {
  input: AuditEventsStreamingHeadersDestroyInput;
};


export type MutationAuditEventsStreamingHeadersUpdateArgs = {
  input: AuditEventsStreamingHeadersUpdateInput;
};


export type MutationAuditEventsStreamingInstanceHeadersCreateArgs = {
  input: AuditEventsStreamingInstanceHeadersCreateInput;
};


export type MutationAuditEventsStreamingInstanceHeadersDestroyArgs = {
  input: AuditEventsStreamingInstanceHeadersDestroyInput;
};


export type MutationAuditEventsStreamingInstanceHeadersUpdateArgs = {
  input: AuditEventsStreamingInstanceHeadersUpdateInput;
};


export type MutationAwardEmojiAddArgs = {
  input: AwardEmojiAddInput;
};


export type MutationAwardEmojiRemoveArgs = {
  input: AwardEmojiRemoveInput;
};


export type MutationAwardEmojiToggleArgs = {
  input: AwardEmojiToggleInput;
};


export type MutationBoardEpicCreateArgs = {
  input: BoardEpicCreateInput;
};


export type MutationBoardListCreateArgs = {
  input: BoardListCreateInput;
};


export type MutationBoardListUpdateLimitMetricsArgs = {
  input: BoardListUpdateLimitMetricsInput;
};


export type MutationBuildForecastArgs = {
  input: BuildForecastInput;
};


export type MutationBulkDestroyJobArtifactsArgs = {
  input: BulkDestroyJobArtifactsInput;
};


export type MutationBulkEnableDevopsAdoptionNamespacesArgs = {
  input: BulkEnableDevopsAdoptionNamespacesInput;
};


export type MutationBulkRunnerDeleteArgs = {
  input: BulkRunnerDeleteInput;
};


export type MutationCatalogResourcesCreateArgs = {
  input: CatalogResourcesCreateInput;
};


export type MutationCiAiGenerateConfigArgs = {
  input: CiAiGenerateConfigInput;
};


export type MutationCiJobTokenScopeAddProjectArgs = {
  input: CiJobTokenScopeAddProjectInput;
};


export type MutationCiJobTokenScopeRemoveProjectArgs = {
  input: CiJobTokenScopeRemoveProjectInput;
};


export type MutationClusterAgentDeleteArgs = {
  input: ClusterAgentDeleteInput;
};


export type MutationClusterAgentTokenCreateArgs = {
  input: ClusterAgentTokenCreateInput;
};


export type MutationClusterAgentTokenRevokeArgs = {
  input: ClusterAgentTokenRevokeInput;
};


export type MutationCommitCreateArgs = {
  input: CommitCreateInput;
};


export type MutationConfigureContainerScanningArgs = {
  input: ConfigureContainerScanningInput;
};


export type MutationConfigureDependencyScanningArgs = {
  input: ConfigureDependencyScanningInput;
};


export type MutationConfigureSastArgs = {
  input: ConfigureSastInput;
};


export type MutationConfigureSastIacArgs = {
  input: ConfigureSastIacInput;
};


export type MutationConfigureSecretDetectionArgs = {
  input: ConfigureSecretDetectionInput;
};


export type MutationCorpusCreateArgs = {
  input: CorpusCreateInput;
};


export type MutationCreateAlertIssueArgs = {
  input: CreateAlertIssueInput;
};


export type MutationCreateAnnotationArgs = {
  input: CreateAnnotationInput;
};


export type MutationCreateBoardArgs = {
  input: CreateBoardInput;
};


export type MutationCreateBranchArgs = {
  input: CreateBranchInput;
};


export type MutationCreateClusterAgentArgs = {
  input: CreateClusterAgentInput;
};


export type MutationCreateComplianceFrameworkArgs = {
  input: CreateComplianceFrameworkInput;
};


export type MutationCreateCustomEmojiArgs = {
  input: CreateCustomEmojiInput;
};


export type MutationCreateDiffNoteArgs = {
  input: CreateDiffNoteInput;
};


export type MutationCreateEpicArgs = {
  input: CreateEpicInput;
};


export type MutationCreateImageDiffNoteArgs = {
  input: CreateImageDiffNoteInput;
};


export type MutationCreateIssueArgs = {
  input: CreateIssueInput;
};


export type MutationCreateIterationArgs = {
  input: CreateIterationInput;
};


export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


export type MutationCreateRequirementArgs = {
  input: CreateRequirementInput;
};


export type MutationCreateSnippetArgs = {
  input: CreateSnippetInput;
};


export type MutationCreateTestCaseArgs = {
  input: CreateTestCaseInput;
};


export type MutationCustomerRelationsContactCreateArgs = {
  input: CustomerRelationsContactCreateInput;
};


export type MutationCustomerRelationsContactUpdateArgs = {
  input: CustomerRelationsContactUpdateInput;
};


export type MutationCustomerRelationsOrganizationCreateArgs = {
  input: CustomerRelationsOrganizationCreateInput;
};


export type MutationCustomerRelationsOrganizationUpdateArgs = {
  input: CustomerRelationsOrganizationUpdateInput;
};


export type MutationDastOnDemandScanCreateArgs = {
  input: DastOnDemandScanCreateInput;
};


export type MutationDastProfileCreateArgs = {
  input: DastProfileCreateInput;
};


export type MutationDastProfileDeleteArgs = {
  input: DastProfileDeleteInput;
};


export type MutationDastProfileRunArgs = {
  input: DastProfileRunInput;
};


export type MutationDastProfileUpdateArgs = {
  input: DastProfileUpdateInput;
};


export type MutationDastScannerProfileCreateArgs = {
  input: DastScannerProfileCreateInput;
};


export type MutationDastScannerProfileDeleteArgs = {
  input: DastScannerProfileDeleteInput;
};


export type MutationDastScannerProfileUpdateArgs = {
  input: DastScannerProfileUpdateInput;
};


export type MutationDastSiteProfileCreateArgs = {
  input: DastSiteProfileCreateInput;
};


export type MutationDastSiteProfileDeleteArgs = {
  input: DastSiteProfileDeleteInput;
};


export type MutationDastSiteProfileUpdateArgs = {
  input: DastSiteProfileUpdateInput;
};


export type MutationDastSiteTokenCreateArgs = {
  input: DastSiteTokenCreateInput;
};


export type MutationDastSiteValidationCreateArgs = {
  input: DastSiteValidationCreateInput;
};


export type MutationDastSiteValidationRevokeArgs = {
  input: DastSiteValidationRevokeInput;
};


export type MutationDeleteAnnotationArgs = {
  input: DeleteAnnotationInput;
};


export type MutationDesignManagementDeleteArgs = {
  input: DesignManagementDeleteInput;
};


export type MutationDesignManagementMoveArgs = {
  input: DesignManagementMoveInput;
};


export type MutationDesignManagementUpdateArgs = {
  input: DesignManagementUpdateInput;
};


export type MutationDesignManagementUploadArgs = {
  input: DesignManagementUploadInput;
};


export type MutationDestroyBoardArgs = {
  input: DestroyBoardInput;
};


export type MutationDestroyBoardListArgs = {
  input: DestroyBoardListInput;
};


export type MutationDestroyComplianceFrameworkArgs = {
  input: DestroyComplianceFrameworkInput;
};


export type MutationDestroyContainerRepositoryArgs = {
  input: DestroyContainerRepositoryInput;
};


export type MutationDestroyContainerRepositoryTagsArgs = {
  input: DestroyContainerRepositoryTagsInput;
};


export type MutationDestroyCustomEmojiArgs = {
  input: DestroyCustomEmojiInput;
};


export type MutationDestroyEpicBoardArgs = {
  input: DestroyEpicBoardInput;
};


export type MutationDestroyNoteArgs = {
  input: DestroyNoteInput;
};


export type MutationDestroyPackageArgs = {
  input: DestroyPackageInput;
};


export type MutationDestroyPackageFileArgs = {
  input: DestroyPackageFileInput;
};


export type MutationDestroyPackageFilesArgs = {
  input: DestroyPackageFilesInput;
};


export type MutationDestroyPackagesArgs = {
  input: DestroyPackagesInput;
};


export type MutationDestroySnippetArgs = {
  input: DestroySnippetInput;
};


export type MutationDisableDevopsAdoptionNamespaceArgs = {
  input: DisableDevopsAdoptionNamespaceInput;
};


export type MutationDiscussionToggleResolveArgs = {
  input: DiscussionToggleResolveInput;
};


export type MutationEchoCreateArgs = {
  input: EchoCreateInput;
};


export type MutationEnableDevopsAdoptionNamespaceArgs = {
  input: EnableDevopsAdoptionNamespaceInput;
};


export type MutationEnvironmentCreateArgs = {
  input: EnvironmentCreateInput;
};


export type MutationEnvironmentDeleteArgs = {
  input: EnvironmentDeleteInput;
};


export type MutationEnvironmentStopArgs = {
  input: EnvironmentStopInput;
};


export type MutationEnvironmentUpdateArgs = {
  input: EnvironmentUpdateInput;
};


export type MutationEnvironmentsCanaryIngressUpdateArgs = {
  input: EnvironmentsCanaryIngressUpdateInput;
};


export type MutationEpicAddIssueArgs = {
  input: EpicAddIssueInput;
};


export type MutationEpicBoardCreateArgs = {
  input: EpicBoardCreateInput;
};


export type MutationEpicBoardListCreateArgs = {
  input: EpicBoardListCreateInput;
};


export type MutationEpicBoardListDestroyArgs = {
  input: EpicBoardListDestroyInput;
};


export type MutationEpicBoardUpdateArgs = {
  input: EpicBoardUpdateInput;
};


export type MutationEpicMoveListArgs = {
  input: EpicMoveListInput;
};


export type MutationEpicSetSubscriptionArgs = {
  input: EpicSetSubscriptionInput;
};


export type MutationEpicTreeReorderArgs = {
  input: EpicTreeReorderInput;
};


export type MutationEscalationPolicyCreateArgs = {
  input: EscalationPolicyCreateInput;
};


export type MutationEscalationPolicyDestroyArgs = {
  input: EscalationPolicyDestroyInput;
};


export type MutationEscalationPolicyUpdateArgs = {
  input: EscalationPolicyUpdateInput;
};


export type MutationExportRequirementsArgs = {
  input: ExportRequirementsInput;
};


export type MutationExternalAuditEventDestinationCreateArgs = {
  input: ExternalAuditEventDestinationCreateInput;
};


export type MutationExternalAuditEventDestinationDestroyArgs = {
  input: ExternalAuditEventDestinationDestroyInput;
};


export type MutationExternalAuditEventDestinationUpdateArgs = {
  input: ExternalAuditEventDestinationUpdateInput;
};


export type MutationGeoRegistriesUpdateArgs = {
  input: GeoRegistriesUpdateInput;
};


export type MutationGitlabSubscriptionActivateArgs = {
  input: GitlabSubscriptionActivateInput;
};


export type MutationGoogleCloudLoggingConfigurationCreateArgs = {
  input: GoogleCloudLoggingConfigurationCreateInput;
};


export type MutationGoogleCloudLoggingConfigurationDestroyArgs = {
  input: GoogleCloudLoggingConfigurationDestroyInput;
};


export type MutationGoogleCloudLoggingConfigurationUpdateArgs = {
  input: GoogleCloudLoggingConfigurationUpdateInput;
};


export type MutationGroupMemberBulkUpdateArgs = {
  input: GroupMemberBulkUpdateInput;
};


export type MutationGroupUpdateArgs = {
  input: GroupUpdateInput;
};


export type MutationHttpIntegrationCreateArgs = {
  input: HttpIntegrationCreateInput;
};


export type MutationHttpIntegrationDestroyArgs = {
  input: HttpIntegrationDestroyInput;
};


export type MutationHttpIntegrationResetTokenArgs = {
  input: HttpIntegrationResetTokenInput;
};


export type MutationHttpIntegrationUpdateArgs = {
  input: HttpIntegrationUpdateInput;
};


export type MutationInstanceExternalAuditEventDestinationCreateArgs = {
  input: InstanceExternalAuditEventDestinationCreateInput;
};


export type MutationInstanceExternalAuditEventDestinationDestroyArgs = {
  input: InstanceExternalAuditEventDestinationDestroyInput;
};


export type MutationInstanceExternalAuditEventDestinationUpdateArgs = {
  input: InstanceExternalAuditEventDestinationUpdateInput;
};


export type MutationIssuableResourceLinkCreateArgs = {
  input: IssuableResourceLinkCreateInput;
};


export type MutationIssuableResourceLinkDestroyArgs = {
  input: IssuableResourceLinkDestroyInput;
};


export type MutationIssueLinkAlertsArgs = {
  input: IssueLinkAlertsInput;
};


export type MutationIssueMoveArgs = {
  input: IssueMoveInput;
};


export type MutationIssueMoveListArgs = {
  input: IssueMoveListInput;
};


export type MutationIssueSetAssigneesArgs = {
  input: IssueSetAssigneesInput;
};


export type MutationIssueSetConfidentialArgs = {
  input: IssueSetConfidentialInput;
};


export type MutationIssueSetCrmContactsArgs = {
  input: IssueSetCrmContactsInput;
};


export type MutationIssueSetDueDateArgs = {
  input: IssueSetDueDateInput;
};


export type MutationIssueSetEpicArgs = {
  input: IssueSetEpicInput;
};


export type MutationIssueSetEscalationPolicyArgs = {
  input: IssueSetEscalationPolicyInput;
};


export type MutationIssueSetEscalationStatusArgs = {
  input: IssueSetEscalationStatusInput;
};


export type MutationIssueSetIterationArgs = {
  input: IssueSetIterationInput;
};


export type MutationIssueSetLockedArgs = {
  input: IssueSetLockedInput;
};


export type MutationIssueSetSeverityArgs = {
  input: IssueSetSeverityInput;
};


export type MutationIssueSetSubscriptionArgs = {
  input: IssueSetSubscriptionInput;
};


export type MutationIssueSetWeightArgs = {
  input: IssueSetWeightInput;
};


export type MutationIssueUnlinkAlertArgs = {
  input: IssueUnlinkAlertInput;
};


export type MutationIssuesBulkUpdateArgs = {
  input: IssuesBulkUpdateInput;
};


export type MutationIterationCadenceCreateArgs = {
  input: IterationCadenceCreateInput;
};


export type MutationIterationCadenceDestroyArgs = {
  input: IterationCadenceDestroyInput;
};


export type MutationIterationCadenceUpdateArgs = {
  input: IterationCadenceUpdateInput;
};


export type MutationIterationCreateArgs = {
  input: IterationCreateInput;
};


export type MutationIterationDeleteArgs = {
  input: IterationDeleteInput;
};


export type MutationJiraImportStartArgs = {
  input: JiraImportStartInput;
};


export type MutationJiraImportUsersArgs = {
  input: JiraImportUsersInput;
};


export type MutationJobArtifactsDestroyArgs = {
  input: JobArtifactsDestroyInput;
};


export type MutationJobCancelArgs = {
  input: JobCancelInput;
};


export type MutationJobPlayArgs = {
  input: JobPlayInput;
};


export type MutationJobRetryArgs = {
  input: JobRetryInput;
};


export type MutationJobUnscheduleArgs = {
  input: JobUnscheduleInput;
};


export type MutationLabelCreateArgs = {
  input: LabelCreateInput;
};


export type MutationMarkAsSpamSnippetArgs = {
  input: MarkAsSpamSnippetInput;
};


export type MutationMergeRequestAcceptArgs = {
  input: MergeRequestAcceptInput;
};


export type MutationMergeRequestCreateArgs = {
  input: MergeRequestCreateInput;
};


export type MutationMergeRequestReviewerRereviewArgs = {
  input: MergeRequestReviewerRereviewInput;
};


export type MutationMergeRequestSetAssigneesArgs = {
  input: MergeRequestSetAssigneesInput;
};


export type MutationMergeRequestSetDraftArgs = {
  input: MergeRequestSetDraftInput;
};


export type MutationMergeRequestSetLabelsArgs = {
  input: MergeRequestSetLabelsInput;
};


export type MutationMergeRequestSetLockedArgs = {
  input: MergeRequestSetLockedInput;
};


export type MutationMergeRequestSetMilestoneArgs = {
  input: MergeRequestSetMilestoneInput;
};


export type MutationMergeRequestSetReviewersArgs = {
  input: MergeRequestSetReviewersInput;
};


export type MutationMergeRequestSetSubscriptionArgs = {
  input: MergeRequestSetSubscriptionInput;
};


export type MutationMergeRequestUpdateArgs = {
  input: MergeRequestUpdateInput;
};


export type MutationMergeRequestUpdateApprovalRuleArgs = {
  input: MergeRequestUpdateApprovalRuleInput;
};


export type MutationNamespaceBanDestroyArgs = {
  input: NamespaceBanDestroyInput;
};


export type MutationNamespaceCiCdSettingsUpdateArgs = {
  input: NamespaceCiCdSettingsUpdateInput;
};


export type MutationNamespaceIncreaseStorageTemporarilyArgs = {
  input: NamespaceIncreaseStorageTemporarilyInput;
};


export type MutationOncallRotationCreateArgs = {
  input: OncallRotationCreateInput;
};


export type MutationOncallRotationDestroyArgs = {
  input: OncallRotationDestroyInput;
};


export type MutationOncallRotationUpdateArgs = {
  input: OncallRotationUpdateInput;
};


export type MutationOncallScheduleCreateArgs = {
  input: OncallScheduleCreateInput;
};


export type MutationOncallScheduleDestroyArgs = {
  input: OncallScheduleDestroyInput;
};


export type MutationOncallScheduleUpdateArgs = {
  input: OncallScheduleUpdateInput;
};


export type MutationPagesMarkOnboardingCompleteArgs = {
  input: PagesMarkOnboardingCompleteInput;
};


export type MutationPipelineCancelArgs = {
  input: PipelineCancelInput;
};


export type MutationPipelineDestroyArgs = {
  input: PipelineDestroyInput;
};


export type MutationPipelineRetryArgs = {
  input: PipelineRetryInput;
};


export type MutationPipelineScheduleCreateArgs = {
  input: PipelineScheduleCreateInput;
};


export type MutationPipelineScheduleDeleteArgs = {
  input: PipelineScheduleDeleteInput;
};


export type MutationPipelineSchedulePlayArgs = {
  input: PipelineSchedulePlayInput;
};


export type MutationPipelineScheduleTakeOwnershipArgs = {
  input: PipelineScheduleTakeOwnershipInput;
};


export type MutationPipelineScheduleUpdateArgs = {
  input: PipelineScheduleUpdateInput;
};


export type MutationProjectCiCdSettingsUpdateArgs = {
  input: ProjectCiCdSettingsUpdateInput;
};


export type MutationProjectInitializeProductAnalyticsArgs = {
  input: ProjectInitializeProductAnalyticsInput;
};


export type MutationProjectMemberBulkUpdateArgs = {
  input: ProjectMemberBulkUpdateInput;
};


export type MutationProjectSetComplianceFrameworkArgs = {
  input: ProjectSetComplianceFrameworkInput;
};


export type MutationProjectSetLockedArgs = {
  input: ProjectSetLockedInput;
};


export type MutationProjectSyncForkArgs = {
  input: ProjectSyncForkInput;
};


export type MutationPrometheusIntegrationCreateArgs = {
  input: PrometheusIntegrationCreateInput;
};


export type MutationPrometheusIntegrationResetTokenArgs = {
  input: PrometheusIntegrationResetTokenInput;
};


export type MutationPrometheusIntegrationUpdateArgs = {
  input: PrometheusIntegrationUpdateInput;
};


export type MutationPromoteToEpicArgs = {
  input: PromoteToEpicInput;
};


export type MutationReleaseAssetLinkCreateArgs = {
  input: ReleaseAssetLinkCreateInput;
};


export type MutationReleaseAssetLinkDeleteArgs = {
  input: ReleaseAssetLinkDeleteInput;
};


export type MutationReleaseAssetLinkUpdateArgs = {
  input: ReleaseAssetLinkUpdateInput;
};


export type MutationReleaseCreateArgs = {
  input: ReleaseCreateInput;
};


export type MutationReleaseDeleteArgs = {
  input: ReleaseDeleteInput;
};


export type MutationReleaseUpdateArgs = {
  input: ReleaseUpdateInput;
};


export type MutationRemoveProjectFromSecurityDashboardArgs = {
  input: RemoveProjectFromSecurityDashboardInput;
};


export type MutationRepositionImageDiffNoteArgs = {
  input: RepositionImageDiffNoteInput;
};


export type MutationRunnerCreateArgs = {
  input: RunnerCreateInput;
};


export type MutationRunnerDeleteArgs = {
  input: RunnerDeleteInput;
};


export type MutationRunnerUpdateArgs = {
  input: RunnerUpdateInput;
};


export type MutationRunnersRegistrationTokenResetArgs = {
  input: RunnersRegistrationTokenResetInput;
};


export type MutationSavedReplyCreateArgs = {
  input: SavedReplyCreateInput;
};


export type MutationSavedReplyDestroyArgs = {
  input: SavedReplyDestroyInput;
};


export type MutationSavedReplyUpdateArgs = {
  input: SavedReplyUpdateInput;
};


export type MutationScanExecutionPolicyCommitArgs = {
  input: ScanExecutionPolicyCommitInput;
};


export type MutationSecurityFindingCreateIssueArgs = {
  input: SecurityFindingCreateIssueInput;
};


export type MutationSecurityFindingCreateMergeRequestArgs = {
  input: SecurityFindingCreateMergeRequestInput;
};


export type MutationSecurityFindingDismissArgs = {
  input: SecurityFindingDismissInput;
};


export type MutationSecurityFindingRevertToDetectedArgs = {
  input: SecurityFindingRevertToDetectedInput;
};


export type MutationSecurityPolicyProjectAssignArgs = {
  input: SecurityPolicyProjectAssignInput;
};


export type MutationSecurityPolicyProjectCreateArgs = {
  input: SecurityPolicyProjectCreateInput;
};


export type MutationSecurityPolicyProjectUnassignArgs = {
  input: SecurityPolicyProjectUnassignInput;
};


export type MutationSecurityTrainingUpdateArgs = {
  input: SecurityTrainingUpdateInput;
};


export type MutationTerraformStateDeleteArgs = {
  input: TerraformStateDeleteInput;
};


export type MutationTerraformStateLockArgs = {
  input: TerraformStateLockInput;
};


export type MutationTerraformStateUnlockArgs = {
  input: TerraformStateUnlockInput;
};


export type MutationTimelineEventCreateArgs = {
  input: TimelineEventCreateInput;
};


export type MutationTimelineEventDestroyArgs = {
  input: TimelineEventDestroyInput;
};


export type MutationTimelineEventPromoteFromNoteArgs = {
  input: TimelineEventPromoteFromNoteInput;
};


export type MutationTimelineEventTagCreateArgs = {
  input: TimelineEventTagCreateInput;
};


export type MutationTimelineEventUpdateArgs = {
  input: TimelineEventUpdateInput;
};


export type MutationTimelogCreateArgs = {
  input: TimelogCreateInput;
};


export type MutationTimelogDeleteArgs = {
  input: TimelogDeleteInput;
};


export type MutationTodoCreateArgs = {
  input: TodoCreateInput;
};


export type MutationTodoMarkDoneArgs = {
  input: TodoMarkDoneInput;
};


export type MutationTodoRestoreArgs = {
  input: TodoRestoreInput;
};


export type MutationTodoRestoreManyArgs = {
  input: TodoRestoreManyInput;
};


export type MutationTodosMarkAllDoneArgs = {
  input: TodosMarkAllDoneInput;
};


export type MutationUpdateAlertStatusArgs = {
  input: UpdateAlertStatusInput;
};


export type MutationUpdateBoardArgs = {
  input: UpdateBoardInput;
};


export type MutationUpdateBoardEpicUserPreferencesArgs = {
  input: UpdateBoardEpicUserPreferencesInput;
};


export type MutationUpdateBoardListArgs = {
  input: UpdateBoardListInput;
};


export type MutationUpdateComplianceFrameworkArgs = {
  input: UpdateComplianceFrameworkInput;
};


export type MutationUpdateContainerExpirationPolicyArgs = {
  input: UpdateContainerExpirationPolicyInput;
};


export type MutationUpdateDependencyProxyImageTtlGroupPolicyArgs = {
  input: UpdateDependencyProxyImageTtlGroupPolicyInput;
};


export type MutationUpdateDependencyProxySettingsArgs = {
  input: UpdateDependencyProxySettingsInput;
};


export type MutationUpdateEpicArgs = {
  input: UpdateEpicInput;
};


export type MutationUpdateEpicBoardListArgs = {
  input: UpdateEpicBoardListInput;
};


export type MutationUpdateImageDiffNoteArgs = {
  input: UpdateImageDiffNoteInput;
};


export type MutationUpdateIssueArgs = {
  input: UpdateIssueInput;
};


export type MutationUpdateIterationArgs = {
  input: UpdateIterationInput;
};


export type MutationUpdateNamespacePackageSettingsArgs = {
  input: UpdateNamespacePackageSettingsInput;
};


export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


export type MutationUpdatePackagesCleanupPolicyArgs = {
  input: UpdatePackagesCleanupPolicyInput;
};


export type MutationUpdateRequirementArgs = {
  input: UpdateRequirementInput;
};


export type MutationUpdateSnippetArgs = {
  input: UpdateSnippetInput;
};


export type MutationUploadDeleteArgs = {
  input: UploadDeleteInput;
};


export type MutationUserAchievementsDeleteArgs = {
  input: UserAchievementsDeleteInput;
};


export type MutationUserCalloutCreateArgs = {
  input: UserCalloutCreateInput;
};


export type MutationUserPreferencesUpdateArgs = {
  input: UserPreferencesUpdateInput;
};


export type MutationUserSetNamespaceCommitEmailArgs = {
  input: UserSetNamespaceCommitEmailInput;
};


export type MutationVulnerabilityConfirmArgs = {
  input: VulnerabilityConfirmInput;
};


export type MutationVulnerabilityCreateArgs = {
  input: VulnerabilityCreateInput;
};


export type MutationVulnerabilityDismissArgs = {
  input: VulnerabilityDismissInput;
};


export type MutationVulnerabilityExternalIssueLinkCreateArgs = {
  input: VulnerabilityExternalIssueLinkCreateInput;
};


export type MutationVulnerabilityExternalIssueLinkDestroyArgs = {
  input: VulnerabilityExternalIssueLinkDestroyInput;
};


export type MutationVulnerabilityIssueLinkCreateArgs = {
  input: VulnerabilityIssueLinkCreateInput;
};


export type MutationVulnerabilityResolveArgs = {
  input: VulnerabilityResolveInput;
};


export type MutationVulnerabilityRevertToDetectedArgs = {
  input: VulnerabilityRevertToDetectedInput;
};


export type MutationWorkItemConvertArgs = {
  input: WorkItemConvertInput;
};


export type MutationWorkItemCreateArgs = {
  input: WorkItemCreateInput;
};


export type MutationWorkItemCreateFromTaskArgs = {
  input: WorkItemCreateFromTaskInput;
};


export type MutationWorkItemDeleteArgs = {
  input: WorkItemDeleteInput;
};


export type MutationWorkItemDeleteTaskArgs = {
  input: WorkItemDeleteTaskInput;
};


export type MutationWorkItemExportArgs = {
  input: WorkItemExportInput;
};


export type MutationWorkItemUpdateArgs = {
  input: WorkItemUpdateInput;
};


export type MutationWorkItemUpdateTaskArgs = {
  input: WorkItemUpdateTaskInput;
};


export type MutationWorkspaceCreateArgs = {
  input: WorkspaceCreateInput;
};


export type MutationWorkspaceUpdateArgs = {
  input: WorkspaceUpdateInput;
};

/** Different toggles for changing mutator behavior */
export type MutationOperationMode =
  /** Performs an append operation. */
  | 'APPEND'
  /** Performs a removal operation. */
  | 'REMOVE'
  /** Performs a replace operation. */
  | 'REPLACE';

export type Namespace = {
  __typename?: 'Namespace';
  /**
   * Achievements for the namespace. Returns `null` if the `achievements` feature
   * flag is disabled. Introduced in 15.8: This feature is an Experiment. It can be
   * changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.
   */
  achievements?: Maybe<AchievementConnection>;
  /**
   * Size limit for repositories in the namespace in bytes. This limit only applies
   * to namespaces under Project limit enforcement.
   */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']>;
  /** Actual storage size limit for the namespace in bytes. This limit is agnostic of enforcement type. */
  actualSizeLimit?: Maybe<Scalars['Float']>;
  /** Additional storage purchased for the root namespace in bytes. */
  additionalPurchasedStorageSize?: Maybe<Scalars['Float']>;
  /** Compliance frameworks available to projects in this namespace. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /**
   * Includes at least one project where the repository size exceeds the limit.
   * This only applies to namespaces under Project limit enforcement.
   */
  containsLockedProjects: Scalars['Boolean'];
  /** Indicates if the cross_project_pipeline feature is available for the namespace. */
  crossProjectPipelineAvailable: Scalars['Boolean'];
  /** Description of the namespace. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Full name of the namespace. */
  fullName: Scalars['String'];
  /** Full path of the namespace. */
  fullPath: Scalars['ID'];
  /** ID of the namespace. */
  id: Scalars['ID'];
  /** Status of the temporary storage increase. */
  isTemporaryStorageIncreaseEnabled: Scalars['Boolean'];
  /** Indicates if Large File Storage (LFS) is enabled for namespace. */
  lfsEnabled?: Maybe<Scalars['Boolean']>;
  /** Name of the namespace. */
  name: Scalars['String'];
  /** Package settings for the namespace. */
  packageSettings?: Maybe<PackageSettings>;
  /** Path of the namespace. */
  path: Scalars['String'];
  /** Projects within this namespace. */
  projects: ProjectConnection;
  /**
   * Number of projects in the root namespace where the repository size exceeds the
   * limit. This only applies to namespaces under Project limit enforcement.
   */
  repositorySizeExcessProjectCount: Scalars['Int'];
  /** Indicates if users can request access to namespace. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']>;
  /** Aggregated storage statistics of the namespace. Only available for root namespaces. */
  rootStorageStatistics?: Maybe<RootStorageStatistics>;
  /** Scan Execution Policies of the namespace. */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the project */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Shared runners availability for the namespace and its descendants. */
  sharedRunnersSetting?: Maybe<SharedRunnersSetting>;
  /**
   * Storage limit included in the root namespace plan in bytes. This limit only
   * applies to namespaces under Namespace limit enforcement.
   */
  storageSizeLimit?: Maybe<Scalars['Float']>;
  /** Date until the temporary storage increase is active. */
  temporaryStorageIncreaseEndsOn?: Maybe<Scalars['Time']>;
  /**
   * Timelog categories for the namespace. Introduced in 15.3: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Total repository size of all projects in the root namespace in bytes. */
  totalRepositorySize?: Maybe<Scalars['Float']>;
  /**
   * Total excess repository size of all projects in the root namespace in bytes.
   * This only applies to namespaces under Project limit enforcement.
   */
  totalRepositorySizeExcess?: Maybe<Scalars['Float']>;
  /** Visibility of the namespace. */
  visibility?: Maybe<Scalars['String']>;
};


export type NamespaceAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['AchievementsAchievementID']>>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NamespaceComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NamespaceProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  complianceFrameworkFilters?: InputMaybe<ComplianceFrameworkFilters>;
  first?: InputMaybe<Scalars['Int']>;
  hasCodeCoverage?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  includeSubgroups?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  notAimedForDeletion?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<NamespaceProjectSort>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']>;
};


export type NamespaceScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type NamespaceTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type NamespaceBan = {
  __typename?: 'NamespaceBan';
  /** Global ID of the namespace ban. */
  id: Scalars['GlobalID'];
  /** Root namespace to which the ban applies. */
  namespace: Namespace;
  /** User to which the namespace ban applies. */
  user: UserCore;
};

/** Autogenerated input type of NamespaceBanDestroy */
export type NamespaceBanDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the namespace ban to remove. */
  id: Scalars['NamespacesNamespaceBanID'];
};

/** Autogenerated return type of NamespaceBanDestroy */
export type NamespaceBanDestroyPayload = {
  __typename?: 'NamespaceBanDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Namespace Ban. */
  namespaceBan?: Maybe<NamespaceBan>;
};

export type NamespaceCiCdSetting = {
  __typename?: 'NamespaceCiCdSetting';
  /** Indicates if stale runners directly belonging to this namespace should be periodically pruned. */
  allowStaleRunnerPruning?: Maybe<Scalars['Boolean']>;
  /** Namespace the CI/CD settings belong to. */
  namespace?: Maybe<Namespace>;
};

/** Autogenerated input type of NamespaceCiCdSettingsUpdate */
export type NamespaceCiCdSettingsUpdateInput = {
  /** Indicates if stale runners directly belonging to this namespace should be periodically pruned. */
  allowStaleRunnerPruning?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the namespace the settings belong to. */
  fullPath: Scalars['ID'];
};

/** Autogenerated return type of NamespaceCiCdSettingsUpdate */
export type NamespaceCiCdSettingsUpdatePayload = {
  __typename?: 'NamespaceCiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: NamespaceCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type NamespaceCommitEmail = {
  __typename?: 'NamespaceCommitEmail';
  /** Timestamp the namespace commit email was created. */
  createdAt: Scalars['Time'];
  /** Email. */
  email: Email;
  /** Internal ID of the namespace commit email. */
  id: Scalars['ID'];
  /** Namespace. */
  namespace: Namespace;
  /** Timestamp the namespace commit email was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for NamespaceCommitEmail. */
export type NamespaceCommitEmailConnection = {
  __typename?: 'NamespaceCommitEmailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NamespaceCommitEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NamespaceCommitEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NamespaceCommitEmailEdge = {
  __typename?: 'NamespaceCommitEmailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<NamespaceCommitEmail>;
};

/** The connection type for Namespace. */
export type NamespaceConnection = {
  __typename?: 'NamespaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NamespaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Namespace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NamespaceEdge = {
  __typename?: 'NamespaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Namespace>;
};

/** Autogenerated input type of NamespaceIncreaseStorageTemporarily */
export type NamespaceIncreaseStorageTemporarilyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the namespace to mutate. */
  id: Scalars['NamespaceID'];
};

/** Autogenerated return type of NamespaceIncreaseStorageTemporarily */
export type NamespaceIncreaseStorageTemporarilyPayload = {
  __typename?: 'NamespaceIncreaseStorageTemporarilyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Namespace after mutation. */
  namespace?: Maybe<Namespace>;
};

/** Values for sorting projects */
export type NamespaceProjectSort =
  /** Sort by latest activity, descending order. */
  | 'ACTIVITY_DESC'
  /** Most similar to the search query. */
  | 'SIMILARITY'
  /** Sort by excess repository storage size, descending order. */
  | 'STORAGE'
  /** Sort by total storage size, ascending order. */
  | 'STORAGE_SIZE_ASC'
  /** Sort by total storage size, descending order. */
  | 'STORAGE_SIZE_DESC';

export type NegatedBoardIssueInput = {
  /** Filter by assignee username. */
  assigneeUsername?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by epic ID. Incompatible with epicWildcardId. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /**
   * Health status not applied to the issue.
   *                     Includes issues where health status is not set.
   */
  healthStatusFilter?: InputMaybe<HealthStatus>;
  /** List of IIDs of issues. For example `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /** Filter by a list of iteration IDs. Incompatible with iterationWildcardId. */
  iterationId?: InputMaybe<Array<Scalars['IterationID']>>;
  /** Filter by iteration title. */
  iterationTitle?: InputMaybe<Scalars['String']>;
  /** Filter by iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<NegatedIterationWildcardId>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by milestone title. */
  milestoneTitle?: InputMaybe<Scalars['String']>;
  /** Filter by milestone ID wildcard. */
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** Filter by release tag. */
  releaseTag?: InputMaybe<Scalars['String']>;
  /** Filter by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Filter by weight. */
  weight?: InputMaybe<Scalars['String']>;
};

export type NegatedComplianceFrameworkFilters = {
  /** ID of the compliance framework. */
  id?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
};

export type NegatedEpicBoardIssueInput = {
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by reaction emoji applied by the current user. Wildcard values "NONE" and "ANY" are supported. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
};

export type NegatedEpicFilterInput = {
  /** Filter by author username. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** Filter by label name. */
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
};

export type NegatedIssueFilterInput = {
  /** ID of a user not assigned to the issues. */
  assigneeId?: InputMaybe<Scalars['String']>;
  /** Usernames of users not assigned to the issue. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  /** Username of a user who didn't author the issue. */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** ID of an epic not associated with the issues. */
  epicId?: InputMaybe<Scalars['String']>;
  /**
   * Health status not applied to the issue.
   *                     Includes issues where health status is not set.
   */
  healthStatusFilter?: InputMaybe<HealthStatus>;
  /** List of IIDs of issues to exclude. For example, `[1, 2]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /** List of iteration Global IDs not applied to the issue. */
  iterationId?: InputMaybe<Array<Scalars['ID']>>;
  /** Filter by negated iteration ID wildcard. */
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  /** Labels not applied to this issue. */
  labelName?: InputMaybe<Array<Scalars['String']>>;
  /** Milestone not applied to this issue. */
  milestoneTitle?: InputMaybe<Array<Scalars['String']>>;
  /** Filter by negated milestone wildcard values. */
  milestoneWildcardId?: InputMaybe<NegatedMilestoneWildcardId>;
  /** Filter by reaction emoji applied by the current user. */
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  /** Release tag not associated with the issue's milestone. Ignored when parent is a group. */
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  /** Filters out issues by the given issue types. */
  types?: InputMaybe<Array<IssueType>>;
  /** Weight not applied to the issue. */
  weight?: InputMaybe<Scalars['String']>;
};

/** Negated Iteration ID wildcard values */
export type NegatedIterationWildcardId =
  /** Current iteration. */
  | 'CURRENT';

/** Negated Milestone ID wildcard values */
export type NegatedMilestoneWildcardId =
  /** Milestone assigned is open and yet to be started (start date > today). */
  | 'STARTED'
  /** Milestone assigned is open but due in the past (due date <= today). */
  | 'UPCOMING';

/** Describes where code is deployed for a project organized by folder. */
export type NestedEnvironment = {
  __typename?: 'NestedEnvironment';
  /** Latest environment in the folder. */
  environment?: Maybe<Environment>;
  /** Human-readable name of the environment. */
  name: Scalars['String'];
  /** Number of environments nested in the folder. */
  size: Scalars['Int'];
};

/** The connection type for NestedEnvironment. */
export type NestedEnvironmentConnection = {
  __typename?: 'NestedEnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NestedEnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NestedEnvironment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NestedEnvironmentEdge = {
  __typename?: 'NestedEnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<NestedEnvironment>;
};

/** Represents the network policy */
export type NetworkPolicy = {
  __typename?: 'NetworkPolicy';
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Environments where this policy is applied. */
  environments?: Maybe<EnvironmentConnection>;
  /** Indicates whether this policy is created from AutoDevops. */
  fromAutoDevops: Scalars['Boolean'];
  /** Kind of the policy. */
  kind: NetworkPolicyKind;
  /** Name of the policy. */
  name: Scalars['String'];
  /** Namespace of the policy. */
  namespace: Scalars['String'];
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};


/** Represents the network policy */
export type NetworkPolicyEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for NetworkPolicy. */
export type NetworkPolicyConnection = {
  __typename?: 'NetworkPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NetworkPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NetworkPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NetworkPolicyEdge = {
  __typename?: 'NetworkPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<NetworkPolicy>;
};

/** Kind of the network policy */
export type NetworkPolicyKind =
  /** Policy kind of Cilium Network Policy. */
  | 'CiliumNetworkPolicy'
  /** Policy kind of Network Policy. */
  | 'NetworkPolicy';

export type Note = ResolvableInterface & {
  __typename?: 'Note';
  /** User who wrote this note. */
  author: UserCore;
  /** Indicates whether the note author is a contributor. */
  authorIsContributor?: Maybe<Scalars['Boolean']>;
  /** List of award emojis associated with the note. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Content of the note. */
  body: Scalars['String'];
  /** GitLab Flavored Markdown rendering of `note` */
  bodyHtml?: Maybe<Scalars['String']>;
  /**
   * Indicates if this note is confidential. Deprecated in 15.5: This was renamed.
   * @deprecated This was renamed. Please use `internal`. Deprecated in 15.5.
   */
  confidential?: Maybe<Scalars['Boolean']>;
  /** Timestamp of the note creation. */
  createdAt: Scalars['Time'];
  /** Discussion this note is a part of. */
  discussion?: Maybe<Discussion>;
  /** ID of the note. */
  id: Scalars['NoteID'];
  /** Indicates if this note is internal. */
  internal?: Maybe<Scalars['Boolean']>;
  /** Timestamp when note was last edited. */
  lastEditedAt?: Maybe<Scalars['Time']>;
  /** User who last edited the note. */
  lastEditedBy?: Maybe<UserCore>;
  /** Max access level of the note author in the project. */
  maxAccessLevelOfAuthor?: Maybe<Scalars['String']>;
  /** Position of this note on a diff. */
  position?: Maybe<DiffPosition>;
  /** Project associated with the note. */
  project?: Maybe<Project>;
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether this note was created by the system or by a user. */
  system: Scalars['Boolean'];
  /** Name of the icon corresponding to a system note. */
  systemNoteIconName?: Maybe<Scalars['String']>;
  /** Metadata for the given note if it is a system note. */
  systemNoteMetadata?: Maybe<SystemNoteMetadata>;
  /** Timestamp of the note's last activity. */
  updatedAt: Scalars['Time'];
  /** URL to view this Note in the Web UI. */
  url?: Maybe<Scalars['String']>;
  /** Permissions for the current user on the resource */
  userPermissions: NotePermissions;
};


export type NoteAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: 'NoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Note>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: 'NoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Note>;
};

export type NotePermissions = {
  __typename?: 'NotePermissions';
  /** Indicates the user can perform `admin_note` on this resource */
  adminNote: Scalars['Boolean'];
  /** Indicates the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `read_note` on this resource */
  readNote: Scalars['Boolean'];
  /** Indicates the user can perform `reposition_note` on this resource */
  repositionNote: Scalars['Boolean'];
  /** Indicates the user can perform `resolve_note` on this resource */
  resolveNote: Scalars['Boolean'];
};

export type NoteableInterface = {
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** All notes on this noteable. */
  notes: NoteConnection;
};


export type NoteableInterfaceCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NoteableInterfaceDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type NoteableInterfaceNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an object that supports notes. */
export type NoteableType = Design | Issue | MergeRequest;

/** Work item notes collection type. */
export type NotesFilterType =
  /** Show all activity */
  | 'ALL_NOTES'
  /** Show history only */
  | 'ONLY_ACTIVITY'
  /** Show comments only */
  | 'ONLY_COMMENTS';

/** Nuget dependency link metadata */
export type NugetDependencyLinkMetadata = {
  __typename?: 'NugetDependencyLinkMetadata';
  /** ID of the metadatum. */
  id: Scalars['PackagesNugetDependencyLinkMetadatumID'];
  /** Target framework of the dependency link package. */
  targetFramework: Scalars['String'];
};

/** Nuget metadata */
export type NugetMetadata = {
  __typename?: 'NugetMetadata';
  /** Icon URL of the Nuget package. */
  iconUrl?: Maybe<Scalars['String']>;
  /** ID of the metadatum. */
  id: Scalars['PackagesNugetMetadatumID'];
  /** License URL of the Nuget package. */
  licenseUrl?: Maybe<Scalars['String']>;
  /** Project URL of the Nuget package. */
  projectUrl?: Maybe<Scalars['String']>;
};

/** The rotation participant and color palette */
export type OncallParticipantType = {
  __typename?: 'OncallParticipantType';
  /** Color palette to assign to the on-call user. For example "blue". */
  colorPalette?: Maybe<Scalars['String']>;
  /** Color weight to assign to for the on-call user, for example "500". Max 4 chars. For easy identification of the user. */
  colorWeight?: Maybe<Scalars['String']>;
  /** ID of the on-call participant. */
  id: Scalars['IncidentManagementOncallParticipantID'];
  /** User who is participating. */
  user: UserCore;
};

/** The connection type for OncallParticipantType. */
export type OncallParticipantTypeConnection = {
  __typename?: 'OncallParticipantTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OncallParticipantTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OncallParticipantType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type OncallParticipantTypeEdge = {
  __typename?: 'OncallParticipantTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<OncallParticipantType>;
};

/** Active period time range for on-call rotation */
export type OncallRotationActivePeriodInputType = {
  /** End of the rotation active period in 24 hour format. For example, "18:30". */
  endTime: Scalars['String'];
  /** Start of the rotation active period in 24 hour format. For example, "18:30". */
  startTime: Scalars['String'];
};

/** Active period time range for on-call rotation */
export type OncallRotationActivePeriodType = {
  __typename?: 'OncallRotationActivePeriodType';
  /** End of the rotation active period. */
  endTime?: Maybe<Scalars['String']>;
  /** Start of the rotation active period. */
  startTime?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of OncallRotationCreate */
export type OncallRotationCreateInput = {
  /** Active period of time that the on-call rotation should take place. */
  activePeriod?: InputMaybe<OncallRotationActivePeriodInputType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** End date and time of the on-call rotation, in the timezone of the on-call schedule. */
  endsAt?: InputMaybe<OncallRotationDateInputType>;
  /** Name of the on-call rotation. */
  name: Scalars['String'];
  /** Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies. */
  participants: Array<OncallUserInputType>;
  /** Project to create the on-call schedule in. */
  projectPath: Scalars['ID'];
  /** Rotation length of the on-call rotation. */
  rotationLength: OncallRotationLengthInputType;
  /** IID of the on-call schedule to create the on-call rotation in. */
  scheduleIid: Scalars['String'];
  /** Start date and time of the on-call rotation, in the timezone of the on-call schedule. */
  startsAt: OncallRotationDateInputType;
};

/** Autogenerated return type of OncallRotationCreate */
export type OncallRotationCreatePayload = {
  __typename?: 'OncallRotationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** Date input type for on-call rotation */
export type OncallRotationDateInputType = {
  /** Date component of the date in YYYY-MM-DD format. */
  date: Scalars['String'];
  /** Time component of the date in 24hr HH:MM format. */
  time: Scalars['String'];
};

/** Autogenerated input type of OncallRotationDestroy */
export type OncallRotationDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the on-call rotation to remove. */
  id: Scalars['IncidentManagementOncallRotationID'];
  /** Project to remove the on-call schedule from. */
  projectPath: Scalars['ID'];
  /** IID of the on-call schedule to the on-call rotation belongs to. */
  scheduleIid: Scalars['String'];
};

/** Autogenerated return type of OncallRotationDestroy */
export type OncallRotationDestroyPayload = {
  __typename?: 'OncallRotationDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** The rotation length of the on-call rotation */
export type OncallRotationLengthInputType = {
  /** Rotation length of the on-call rotation. */
  length: Scalars['Int'];
  /** Unit of the rotation length of the on-call rotation. */
  unit: OncallRotationUnitEnum;
};

/** Rotation length unit of an on-call rotation */
export type OncallRotationUnitEnum =
  /** Days */
  | 'DAYS'
  /** Hours */
  | 'HOURS'
  /** Weeks */
  | 'WEEKS';

/** Autogenerated input type of OncallRotationUpdate */
export type OncallRotationUpdateInput = {
  /** Active period of time that the on-call rotation should take place. */
  activePeriod?: InputMaybe<OncallRotationActivePeriodInputType>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** End date and time of the on-call rotation, in the timezone of the on-call schedule. */
  endsAt?: InputMaybe<OncallRotationDateInputType>;
  /** ID of the on-call schedule to create the on-call rotation in. */
  id: Scalars['IncidentManagementOncallRotationID'];
  /** Name of the on-call rotation. */
  name?: InputMaybe<Scalars['String']>;
  /** Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies. */
  participants?: InputMaybe<Array<OncallUserInputType>>;
  /** Rotation length of the on-call rotation. */
  rotationLength?: InputMaybe<OncallRotationLengthInputType>;
  /** Start date and time of the on-call rotation, in the timezone of the on-call schedule. */
  startsAt?: InputMaybe<OncallRotationDateInputType>;
};

/** Autogenerated return type of OncallRotationUpdate */
export type OncallRotationUpdatePayload = {
  __typename?: 'OncallRotationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call rotation. */
  oncallRotation?: Maybe<IncidentManagementOncallRotation>;
};

/** Autogenerated input type of OncallScheduleCreate */
export type OncallScheduleCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the on-call schedule. */
  description?: InputMaybe<Scalars['String']>;
  /** Name of the on-call schedule. */
  name: Scalars['String'];
  /** Project to create the on-call schedule in. */
  projectPath: Scalars['ID'];
  /** Timezone of the on-call schedule. */
  timezone: Scalars['String'];
};

/** Autogenerated return type of OncallScheduleCreate */
export type OncallScheduleCreatePayload = {
  __typename?: 'OncallScheduleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** Autogenerated input type of OncallScheduleDestroy */
export type OncallScheduleDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** On-call schedule internal ID to remove. */
  iid: Scalars['String'];
  /** Project to remove the on-call schedule from. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of OncallScheduleDestroy */
export type OncallScheduleDestroyPayload = {
  __typename?: 'OncallScheduleDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** Autogenerated input type of OncallScheduleUpdate */
export type OncallScheduleUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the on-call schedule. */
  description?: InputMaybe<Scalars['String']>;
  /** On-call schedule internal ID to update. */
  iid: Scalars['String'];
  /** Name of the on-call schedule. */
  name?: InputMaybe<Scalars['String']>;
  /** Project to update the on-call schedule in. */
  projectPath: Scalars['ID'];
  /** Timezone of the on-call schedule. */
  timezone?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of OncallScheduleUpdate */
export type OncallScheduleUpdatePayload = {
  __typename?: 'OncallScheduleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** On-call schedule. */
  oncallSchedule?: Maybe<IncidentManagementOncallSchedule>;
};

/** The rotation user and color palette */
export type OncallUserInputType = {
  /** Value of DataVisualizationColorEnum. The color from the palette to assign to the on-call user. */
  colorPalette?: InputMaybe<DataVisualizationColorEnum>;
  /**
   * Color weight to assign to for the on-call user. To view on-call schedules in
   * GitLab, do not provide a value below 500. A value between 500 and 950 ensures
   * sufficient contrast.
   */
  colorWeight?: InputMaybe<DataVisualizationWeightEnum>;
  /** Username of the user to participate in the on-call rotation. For example, `"user_one"`. */
  username: Scalars['String'];
};

export type OrchestrationPolicy = {
  /** Description of the policy. */
  description: Scalars['String'];
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Name of the policy. */
  name: Scalars['String'];
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};

/** Values for sorting organizations */
export type OrganizationSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Default Rate in ascending order. */
  | 'DEFAULT_RATE_ASC'
  /** Default Rate in descending order. */
  | 'DEFAULT_RATE_DESC'
  /** Description in ascending order. */
  | 'DESCRIPTION_ASC'
  /** Description in descending order. */
  | 'DESCRIPTION_DESC'
  /** Name in ascending order. */
  | 'NAME_ASC'
  /** Name in descending order. */
  | 'NAME_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Represents the total number of organizations for the represented states. */
export type OrganizationStateCounts = {
  __typename?: 'OrganizationStateCounts';
  /** Number of organizations with state `ACTIVE` */
  active?: Maybe<Scalars['Int']>;
  /** Number of organizations with state `ALL` */
  all?: Maybe<Scalars['Int']>;
  /** Number of organizations with state `INACTIVE` */
  inactive?: Maybe<Scalars['Int']>;
};

/** Represents a package with pipelines in the Package Registry */
export type Package = {
  __typename?: 'Package';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Whether the user can destroy the package. */
  canDestroy: Scalars['Boolean'];
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the package. */
  id: Scalars['PackagesPackageID'];
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String'];
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Pipelines that built the package. Max page size 20. */
  pipelines?: Maybe<PipelineConnection>;
  /** Project where the package is stored. */
  project: Project;
  /** Package status. */
  status: PackageStatus;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
  /** Version string. */
  version?: Maybe<Scalars['String']>;
};


/** Represents a package with pipelines in the Package Registry */
export type PackagePipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package with pipelines in the Package Registry */
export type PackageTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents a package in the Package Registry */
export type PackageBase = {
  __typename?: 'PackageBase';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Whether the user can destroy the package. */
  canDestroy: Scalars['Boolean'];
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** ID of the package. */
  id: Scalars['PackagesPackageID'];
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String'];
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Project where the package is stored. */
  project: Project;
  /** Package status. */
  status: PackageStatus;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
  /** Version string. */
  version?: Maybe<Scalars['String']>;
};


/** Represents a package in the Package Registry */
export type PackageBaseTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PackageBase. */
export type PackageBaseConnection = {
  __typename?: 'PackageBaseConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageBaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageBase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageBaseEdge = {
  __typename?: 'PackageBaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageBase>;
};

/** Represents a composer JSON file */
export type PackageComposerJsonType = {
  __typename?: 'PackageComposerJsonType';
  /** License set in the Composer JSON file. */
  license?: Maybe<Scalars['String']>;
  /** Name set in the Composer JSON file. */
  name?: Maybe<Scalars['String']>;
  /** Type set in the Composer JSON file. */
  type?: Maybe<Scalars['String']>;
  /** Version set in the Composer JSON file. */
  version?: Maybe<Scalars['String']>;
};

/** The connection type for Package. */
export type PackageConnection = {
  __typename?: 'PackageConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Package>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents a package dependency. */
export type PackageDependency = {
  __typename?: 'PackageDependency';
  /** ID of the dependency. */
  id: Scalars['PackagesDependencyID'];
  /** Name of the dependency. */
  name: Scalars['String'];
  /** Version pattern of the dependency. */
  versionPattern: Scalars['String'];
};

/** Represents a package dependency link */
export type PackageDependencyLink = {
  __typename?: 'PackageDependencyLink';
  /** Dependency. */
  dependency?: Maybe<PackageDependency>;
  /** Dependency type. */
  dependencyType: PackageDependencyType;
  /** ID of the dependency link. */
  id: Scalars['PackagesDependencyLinkID'];
  /** Dependency link metadata. */
  metadata?: Maybe<DependencyLinkMetadata>;
};

/** The connection type for PackageDependencyLink. */
export type PackageDependencyLinkConnection = {
  __typename?: 'PackageDependencyLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageDependencyLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageDependencyLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageDependencyLinkEdge = {
  __typename?: 'PackageDependencyLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageDependencyLink>;
};

export type PackageDependencyType =
  /** bundleDependencies dependency type */
  | 'BUNDLE_DEPENDENCIES'
  /** dependencies dependency type */
  | 'DEPENDENCIES'
  /** devDependencies dependency type */
  | 'DEV_DEPENDENCIES'
  /** peerDependencies dependency type */
  | 'PEER_DEPENDENCIES';

/** Represents a package details in the Package Registry */
export type PackageDetailsType = {
  __typename?: 'PackageDetailsType';
  /** Map of links to perform actions on the package. */
  _links: PackageLinks;
  /** Whether the user can destroy the package. */
  canDestroy: Scalars['Boolean'];
  /** Url of the Composer setup endpoint. */
  composerConfigRepositoryUrl?: Maybe<Scalars['String']>;
  /** Url of the Composer endpoint. */
  composerUrl?: Maybe<Scalars['String']>;
  /** Url of the Conan project endpoint. */
  conanUrl?: Maybe<Scalars['String']>;
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Dependency link. */
  dependencyLinks?: Maybe<PackageDependencyLinkConnection>;
  /** ID of the package. */
  id: Scalars['PackagesPackageID'];
  /** Last time that a file of this package was downloaded. */
  lastDownloadedAt?: Maybe<Scalars['Time']>;
  /** Url of the Maven project endpoint. */
  mavenUrl?: Maybe<Scalars['String']>;
  /** Package metadata. */
  metadata?: Maybe<PackageMetadata>;
  /** Name of the package. */
  name: Scalars['String'];
  /** Url of the NPM project endpoint. */
  npmUrl?: Maybe<Scalars['String']>;
  /** Url of the Nuget project endpoint. */
  nugetUrl?: Maybe<Scalars['String']>;
  /** Package files. */
  packageFiles?: Maybe<PackageFileConnection>;
  /** Package type. */
  packageType: PackageTypeEnum;
  /** Pipelines that built the package. Max page size 20. */
  pipelines?: Maybe<PipelineConnection>;
  /** Project where the package is stored. */
  project: Project;
  /** Indicates if there is public access to the package. */
  publicPackage?: Maybe<Scalars['Boolean']>;
  /** Url of the PyPi project setup endpoint. */
  pypiSetupUrl?: Maybe<Scalars['String']>;
  /** Url of the PyPi project endpoint. */
  pypiUrl?: Maybe<Scalars['String']>;
  /** Package status. */
  status: PackageStatus;
  /** Package tags. */
  tags?: Maybe<PackageTagConnection>;
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
  /** Version string. */
  version?: Maybe<Scalars['String']>;
  /** Other versions of the package. */
  versions?: Maybe<PackageBaseConnection>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeDependencyLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypePackageFilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypePipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a package details in the Package Registry */
export type PackageDetailsTypeVersionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type PackageEdge = {
  __typename?: 'PackageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Package>;
};

/** Represents a package file */
export type PackageFile = {
  __typename?: 'PackageFile';
  /** Created date. */
  createdAt: Scalars['Time'];
  /** Download path of the package file. */
  downloadPath: Scalars['String'];
  /** Md5 of the package file. */
  fileMd5?: Maybe<Scalars['String']>;
  /** File metadata. */
  fileMetadata?: Maybe<PackageFileMetadata>;
  /** Name of the package file. */
  fileName: Scalars['String'];
  /** Sha1 of the package file. */
  fileSha1?: Maybe<Scalars['String']>;
  /** Sha256 of the package file. */
  fileSha256?: Maybe<Scalars['String']>;
  /** ID of the file. */
  id: Scalars['PackagesPackageFileID'];
  /** Size of the package file. */
  size: Scalars['String'];
  /** Updated date. */
  updatedAt: Scalars['Time'];
};

/** The connection type for PackageFile. */
export type PackageFileConnection = {
  __typename?: 'PackageFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageFileEdge = {
  __typename?: 'PackageFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFile>;
};

/** Represents metadata associated with a Package file */
export type PackageFileMetadata = {
  /** Date of creation. */
  createdAt: Scalars['Time'];
  /** Date of most recent update. */
  updatedAt: Scalars['Time'];
};

/** Represents the Geo sync and verification state of a package file */
export type PackageFileRegistry = {
  __typename?: 'PackageFileRegistry';
  /** Timestamp when the PackageFileRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the PackageFileRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the PackageFileRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the PackageFileRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the PackageFile. */
  packageFileId: Scalars['ID'];
  /** Timestamp after which the PackageFileRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the PackageFileRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the PackageFileRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the PackageFileRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the PackageFileRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for PackageFileRegistry. */
export type PackageFileRegistryConnection = {
  __typename?: 'PackageFileRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageFileRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageFileRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageFileRegistryEdge = {
  __typename?: 'PackageFileRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageFileRegistry>;
};

/** Values for sorting group packages */
export type PackageGroupSort =
  /** Ordered by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Ordered by created_at in descending order. */
  | 'CREATED_DESC'
  /** Ordered by name in ascending order. */
  | 'NAME_ASC'
  /** Ordered by name in descending order. */
  | 'NAME_DESC'
  /** Ordered by project path in ascending order. */
  | 'PROJECT_PATH_ASC'
  /** Ordered by project path in descending order. */
  | 'PROJECT_PATH_DESC'
  /** Ordered by type in ascending order. */
  | 'TYPE_ASC'
  /** Ordered by type in descending order. */
  | 'TYPE_DESC'
  /** Ordered by version in ascending order. */
  | 'VERSION_ASC'
  /** Ordered by version in descending order. */
  | 'VERSION_DESC';

/** Represents a Helm dependency */
export type PackageHelmDependencyType = {
  __typename?: 'PackageHelmDependencyType';
  /** Alias of the dependency. */
  alias?: Maybe<Scalars['String']>;
  /** Condition of the dependency. */
  condition?: Maybe<Scalars['String']>;
  /** Indicates the dependency is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Import-values of the dependency. */
  importValues?: Maybe<Array<Scalars['JSON']>>;
  /** Name of the dependency. */
  name?: Maybe<Scalars['String']>;
  /** Repository of the dependency. */
  repository?: Maybe<Scalars['String']>;
  /** Tags of the dependency. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** Version of the dependency. */
  version?: Maybe<Scalars['String']>;
};

/** Represents a Helm maintainer */
export type PackageHelmMaintainerType = {
  __typename?: 'PackageHelmMaintainerType';
  /** Email of the maintainer. */
  email?: Maybe<Scalars['String']>;
  /** Name of the maintainer. */
  name?: Maybe<Scalars['String']>;
  /** URL of the maintainer. */
  url?: Maybe<Scalars['String']>;
};

/** Represents the contents of a Helm Chart.yml file */
export type PackageHelmMetadataType = {
  __typename?: 'PackageHelmMetadataType';
  /** Annotations for the chart. */
  annotations?: Maybe<Scalars['JSON']>;
  /** API version of the chart. */
  apiVersion: Scalars['String'];
  /** App version of the chart. */
  appVersion?: Maybe<Scalars['String']>;
  /** Condition for the chart. */
  condition?: Maybe<Scalars['String']>;
  /** Dependencies of the chart. */
  dependencies?: Maybe<Array<PackageHelmDependencyType>>;
  /** Indicates if the chart is deprecated. */
  deprecated?: Maybe<Scalars['Boolean']>;
  /** Description of the chart. */
  description?: Maybe<Scalars['String']>;
  /** URL of the home page. */
  home?: Maybe<Scalars['String']>;
  /** URL to an SVG or PNG image for the chart. */
  icon?: Maybe<Scalars['String']>;
  /** Keywords for the chart. */
  keywords?: Maybe<Array<Scalars['String']>>;
  /** Kubernetes versions for the chart. */
  kubeVersion?: Maybe<Scalars['String']>;
  /** Maintainers of the chart. */
  maintainers?: Maybe<Array<PackageHelmMaintainerType>>;
  /** Name of the chart. */
  name: Scalars['String'];
  /** URLs of the source code for the chart. */
  sources?: Maybe<Array<Scalars['String']>>;
  /** Tags for the chart. */
  tags?: Maybe<Scalars['String']>;
  /** Type of the chart. */
  type?: Maybe<Scalars['String']>;
  /** Version of the chart. */
  version: Scalars['String'];
};

/** Represents links to perform actions on the package */
export type PackageLinks = {
  __typename?: 'PackageLinks';
  /** Path to the package details page. */
  webPath?: Maybe<Scalars['String']>;
};

/** Values for package manager */
export type PackageManager =
  /** Package manager: bundler. */
  | 'BUNDLER'
  /** Package manager: composer. */
  | 'COMPOSER'
  /** Package manager: conan. */
  | 'CONAN'
  /** Package manager: go. */
  | 'GO'
  /** Package manager: gradle. */
  | 'GRADLE'
  /** Package manager: maven. */
  | 'MAVEN'
  /** Package manager: npm. */
  | 'NPM'
  /** Package manager: nuget. */
  | 'NUGET'
  /** Package manager: pip. */
  | 'PIP'
  /** Package manager: pipenv. */
  | 'PIPENV'
  /** Package manager: pnpm. */
  | 'PNPM'
  /** Package manager: sbt. */
  | 'SBT'
  /** Package manager: setuptools. */
  | 'SETUPTOOLS'
  /** Package manager: yarn. */
  | 'YARN';

/** Represents metadata associated with a Package */
export type PackageMetadata = ComposerMetadata | ConanMetadata | MavenMetadata | NugetMetadata | PypiMetadata;

/** Namespace-level Package Registry settings */
export type PackageSettings = {
  __typename?: 'PackageSettings';
  /**
   * When generic_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  genericDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate generic packages are allowed for this namespace. */
  genericDuplicatesAllowed: Scalars['Boolean'];
  /** Indicates whether Maven package forwarding is locked for all descendent namespaces. */
  lockMavenPackageRequestsForwarding: Scalars['Boolean'];
  /** Indicates whether npm package forwarding is locked for all descendent namespaces. */
  lockNpmPackageRequestsForwarding: Scalars['Boolean'];
  /** Indicates whether PyPI package forwarding is locked for all descendent namespaces. */
  lockPypiPackageRequestsForwarding: Scalars['Boolean'];
  /**
   * When maven_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  mavenDuplicateExceptionRegex?: Maybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate Maven packages are allowed for this namespace. */
  mavenDuplicatesAllowed: Scalars['Boolean'];
  /** Indicates whether Maven package forwarding is allowed for this namespace. */
  mavenPackageRequestsForwarding?: Maybe<Scalars['Boolean']>;
  /** Indicates whether Maven package forwarding settings are locked by a parent namespace. */
  mavenPackageRequestsForwardingLocked: Scalars['Boolean'];
  /** Indicates whether npm package forwarding is allowed for this namespace. */
  npmPackageRequestsForwarding?: Maybe<Scalars['Boolean']>;
  /** Indicates whether npm package forwarding settings are locked by a parent namespace. */
  npmPackageRequestsForwardingLocked: Scalars['Boolean'];
  /** Indicates whether PyPI package forwarding is allowed for this namespace. */
  pypiPackageRequestsForwarding?: Maybe<Scalars['Boolean']>;
  /** Indicates whether PyPI package forwarding settings are locked by a parent namespace. */
  pypiPackageRequestsForwardingLocked: Scalars['Boolean'];
};

/** Values for sorting package */
export type PackageSort =
  /** Ordered by created_at in ascending order. */
  | 'CREATED_ASC'
  /** Ordered by created_at in descending order. */
  | 'CREATED_DESC'
  /** Ordered by name in ascending order. */
  | 'NAME_ASC'
  /** Ordered by name in descending order. */
  | 'NAME_DESC'
  /** Ordered by type in ascending order. */
  | 'TYPE_ASC'
  /** Ordered by type in descending order. */
  | 'TYPE_DESC'
  /** Ordered by version in ascending order. */
  | 'VERSION_ASC'
  /** Ordered by version in descending order. */
  | 'VERSION_DESC';

export type PackageStatus =
  /** Packages with a default status */
  | 'DEFAULT'
  /** Packages with a error status */
  | 'ERROR'
  /** Packages with a hidden status */
  | 'HIDDEN'
  /** Packages with a pending_destruction status */
  | 'PENDING_DESTRUCTION'
  /** Packages with a processing status */
  | 'PROCESSING';

/** Represents a package tag */
export type PackageTag = {
  __typename?: 'PackageTag';
  /** Created date. */
  createdAt: Scalars['Time'];
  /** ID of the tag. */
  id: Scalars['ID'];
  /** Name of the tag. */
  name: Scalars['String'];
  /** Updated date. */
  updatedAt: Scalars['Time'];
};

/** The connection type for PackageTag. */
export type PackageTagConnection = {
  __typename?: 'PackageTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackageTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PackageTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PackageTagEdge = {
  __typename?: 'PackageTagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PackageTag>;
};

export type PackageTypeEnum =
  /** Packages from the Composer package manager */
  | 'COMPOSER'
  /** Packages from the Conan package manager */
  | 'CONAN'
  /** Packages from the Debian package manager */
  | 'DEBIAN'
  /** Packages from the Generic package manager */
  | 'GENERIC'
  /** Packages from the Golang package manager */
  | 'GOLANG'
  /** Packages from the Helm package manager */
  | 'HELM'
  /** Packages from the Maven package manager */
  | 'MAVEN'
  /** Packages from the Ml_model package manager */
  | 'ML_MODEL'
  /** Packages from the npm package manager */
  | 'NPM'
  /** Packages from the Nuget package manager */
  | 'NUGET'
  /** Packages from the PyPI package manager */
  | 'PYPI'
  /** Packages from the Rpm package manager */
  | 'RPM'
  /** Packages from the Rubygems package manager */
  | 'RUBYGEMS'
  /** Packages from the Terraform Module package manager */
  | 'TERRAFORM_MODULE';

export type PackagesCleanupKeepDuplicatedPackageFilesEnum =
  /** Value to keep all package files */
  | 'ALL_PACKAGE_FILES'
  /** Value to keep 50 package files */
  | 'FIFTY_PACKAGE_FILES'
  /** Value to keep 40 package files */
  | 'FORTY_PACKAGE_FILES'
  /** Value to keep 1 package files */
  | 'ONE_PACKAGE_FILE'
  /** Value to keep 10 package files */
  | 'TEN_PACKAGE_FILES'
  /** Value to keep 30 package files */
  | 'THIRTY_PACKAGE_FILES'
  /** Value to keep 20 package files */
  | 'TWENTY_PACKAGE_FILES';

/** A packages cleanup policy designed to keep only packages and packages assets that matter most */
export type PackagesCleanupPolicy = {
  __typename?: 'PackagesCleanupPolicy';
  /** Number of duplicated package files to retain. */
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum;
  /** Next time that this packages cleanup policy will be executed. */
  nextRunAt?: Maybe<Scalars['Time']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** Represents the Geo replication and verification state of a pages_deployment */
export type PagesDeploymentRegistry = {
  __typename?: 'PagesDeploymentRegistry';
  /** Timestamp when the PagesDeploymentRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the PagesDeploymentRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the PagesDeploymentRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the PagesDeploymentRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the Pages Deployment. */
  pagesDeploymentId: Scalars['ID'];
  /** Timestamp after which the PagesDeploymentRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the PagesDeploymentRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the PagesDeploymentRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the PagesDeploymentRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the PagesDeploymentRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for PagesDeploymentRegistry. */
export type PagesDeploymentRegistryConnection = {
  __typename?: 'PagesDeploymentRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PagesDeploymentRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PagesDeploymentRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PagesDeploymentRegistryEdge = {
  __typename?: 'PagesDeploymentRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PagesDeploymentRegistry>;
};

/** Autogenerated input type of PagesMarkOnboardingComplete */
export type PagesMarkOnboardingCompleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of PagesMarkOnboardingComplete */
export type PagesMarkOnboardingCompletePayload = {
  __typename?: 'PagesMarkOnboardingCompletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Indicates the new onboarding_complete state of the project's Pages metadata. */
  onboardingComplete: Scalars['Boolean'];
};

/** Represents a file or directory in the project repository that has been locked. */
export type PathLock = {
  __typename?: 'PathLock';
  /** ID of the path lock. */
  id: Scalars['PathLockID'];
  /** Locked path. */
  path?: Maybe<Scalars['String']>;
  /** User that has locked this path. */
  user?: Maybe<UserCore>;
};

/** The connection type for PathLock. */
export type PathLockConnection = {
  __typename?: 'PathLockConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PathLockEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PathLock>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PathLockEdge = {
  __typename?: 'PathLockEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PathLock>;
};

export type Pipeline = {
  __typename?: 'Pipeline';
  /** Indicates if the pipeline is active. */
  active: Scalars['Boolean'];
  /** Base SHA of the source branch. */
  beforeSha?: Maybe<Scalars['String']>;
  /** Specifies if a pipeline can be canceled. */
  cancelable: Scalars['Boolean'];
  /** Code Quality report summary for a pipeline. */
  codeQualityReportSummary?: Maybe<CodeQualityReportSummary>;
  /** Code Quality degradations reported on the pipeline. */
  codeQualityReports?: Maybe<CodeQualityDegradationConnection>;
  /** Git commit of the pipeline. */
  commit?: Maybe<Commit>;
  /** Path to the commit that triggered the pipeline. */
  commitPath?: Maybe<Scalars['String']>;
  /** Timestamp of the pipeline's commit. */
  committedAt?: Maybe<Scalars['Time']>;
  /** Indicates if a pipeline is complete. */
  complete: Scalars['Boolean'];
  /**
   * Configuration source of the pipeline (UNKNOWN_SOURCE, REPOSITORY_SOURCE,
   * AUTO_DEVOPS_SOURCE, WEBIDE_SOURCE, REMOTE_SOURCE, EXTERNAL_PROJECT_SOURCE,
   * BRIDGE_SOURCE, PARAMETER_SOURCE, COMPLIANCE_SOURCE)
   */
  configSource?: Maybe<PipelineConfigSourceEnum>;
  /** Coverage percentage. */
  coverage?: Maybe<Scalars['Float']>;
  /** Timestamp of the pipeline's creation. */
  createdAt: Scalars['Time'];
  /** DAST profile associated with the pipeline. */
  dastProfile?: Maybe<DastProfile>;
  /** Detailed status of the pipeline. */
  detailedStatus: DetailedStatus;
  /** Pipelines this pipeline will trigger. */
  downstream?: Maybe<PipelineConnection>;
  /** Duration of the pipeline in seconds. */
  duration?: Maybe<Scalars['Int']>;
  /** Timestamp of the pipeline's completion. */
  finishedAt?: Maybe<Scalars['Time']>;
  /** ID of the pipeline. */
  id: Scalars['ID'];
  /** Internal ID of the pipeline. */
  iid: Scalars['String'];
  /** Specific job in this pipeline, either by name or ID. */
  job?: Maybe<CiJob>;
  /** Job artifacts of the pipeline. */
  jobArtifacts?: Maybe<Array<CiJobArtifact>>;
  /** Jobs belonging to the pipeline. */
  jobs?: Maybe<CiJobConnection>;
  /** Event type of the pipeline associated with a merge request. */
  mergeRequestEventType?: Maybe<PipelineMergeRequestEventType>;
  /** Relative path to the pipeline's page. */
  path?: Maybe<Scalars['String']>;
  /** Project the pipeline belongs to. */
  project?: Maybe<Project>;
  /** How long the pipeline was queued before starting. */
  queuedDuration?: Maybe<Scalars['Duration']>;
  /** Reference to the branch from which the pipeline was triggered. */
  ref?: Maybe<Scalars['String']>;
  /** Reference path to the branch from which the pipeline was triggered. */
  refPath?: Maybe<Scalars['String']>;
  /** Specifies if a pipeline can be retried. */
  retryable: Scalars['Boolean'];
  /** Vulnerability finding reported on the pipeline. */
  securityReportFinding?: Maybe<PipelineSecurityReportFinding>;
  /** Vulnerability findings reported on the pipeline. */
  securityReportFindings?: Maybe<PipelineSecurityReportFindingConnection>;
  /** Vulnerability and scanned resource counts for each security scanner of the pipeline. */
  securityReportSummary?: Maybe<SecurityReportSummary>;
  /** SHA of the pipeline's commit. */
  sha?: Maybe<Scalars['String']>;
  /** Job where pipeline was triggered from. */
  sourceJob?: Maybe<CiJob>;
  /** Stages of the pipeline. */
  stages?: Maybe<CiStageConnection>;
  /** Timestamp when the pipeline was started. */
  startedAt?: Maybe<Scalars['Time']>;
  /**
   * Status of the pipeline (CREATED, WAITING_FOR_RESOURCE, PREPARING, PENDING,
   * RUNNING, FAILED, SUCCESS, CANCELED, SKIPPED, MANUAL, SCHEDULED)
   */
  status: PipelineStatusEnum;
  /** Summary of the test report generated by the pipeline. */
  testReportSummary: TestReportSummary;
  /** A specific test suite in a pipeline test report. */
  testSuite?: Maybe<TestSuite>;
  /** Timestamp of the pipeline's last activity. */
  updatedAt: Scalars['Time'];
  /** Pipeline that triggered the pipeline. */
  upstream?: Maybe<Pipeline>;
  /** Pipeline user. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: PipelinePermissions;
  /** Indicates if the pipeline has jobs with `needs` dependencies. */
  usesNeeds?: Maybe<Scalars['Boolean']>;
  /** Pipeline warning messages. */
  warningMessages?: Maybe<Array<PipelineMessage>>;
  /** Indicates if a pipeline has warnings. */
  warnings: Scalars['Boolean'];
};


export type PipelineCodeQualityReportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineDownstreamArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineJobArgs = {
  id?: InputMaybe<Scalars['JobID']>;
  name?: InputMaybe<Scalars['String']>;
};


export type PipelineJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  jobKind?: InputMaybe<CiJobKind>;
  last?: InputMaybe<Scalars['Int']>;
  retried?: InputMaybe<Scalars['Boolean']>;
  securityReportTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
  whenExecuted?: InputMaybe<Array<Scalars['String']>>;
};


export type PipelineSecurityReportFindingArgs = {
  uuid: Scalars['String'];
};


export type PipelineSecurityReportFindingsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  reportType?: InputMaybe<Array<Scalars['String']>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  severity?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type PipelineShaArgs = {
  format?: InputMaybe<ShaFormat>;
};


export type PipelineStagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type PipelineTestSuiteArgs = {
  buildIds: Array<Scalars['ID']>;
};

export type PipelineAnalytics = {
  __typename?: 'PipelineAnalytics';
  /** Labels for the monthly pipeline count. */
  monthPipelinesLabels?: Maybe<Array<Scalars['String']>>;
  /** Total monthly successful pipeline count. */
  monthPipelinesSuccessful?: Maybe<Array<Scalars['Int']>>;
  /** Total monthly pipeline count. */
  monthPipelinesTotals?: Maybe<Array<Scalars['Int']>>;
  /** Pipeline times labels. */
  pipelineTimesLabels?: Maybe<Array<Scalars['String']>>;
  /** Pipeline times. */
  pipelineTimesValues?: Maybe<Array<Scalars['Int']>>;
  /** Labels for the weekly pipeline count. */
  weekPipelinesLabels?: Maybe<Array<Scalars['String']>>;
  /** Total weekly successful pipeline count. */
  weekPipelinesSuccessful?: Maybe<Array<Scalars['Int']>>;
  /** Total weekly pipeline count. */
  weekPipelinesTotals?: Maybe<Array<Scalars['Int']>>;
  /** Labels for the yearly pipeline count. */
  yearPipelinesLabels?: Maybe<Array<Scalars['String']>>;
  /** Total yearly successful pipeline count. */
  yearPipelinesSuccessful?: Maybe<Array<Scalars['Int']>>;
  /** Total yearly pipeline count. */
  yearPipelinesTotals?: Maybe<Array<Scalars['Int']>>;
};

/** Represents the Geo sync and verification state of a pipeline artifact */
export type PipelineArtifactRegistry = {
  __typename?: 'PipelineArtifactRegistry';
  /** Timestamp when the PipelineArtifactRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the PipelineArtifactRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the PipelineArtifactRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the PipelineArtifactRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the pipeline artifact. */
  pipelineArtifactId: Scalars['ID'];
  /** Timestamp after which the PipelineArtifactRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the PipelineArtifactRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the PipelineArtifactRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the PipelineArtifactRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the PipelineArtifactRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for PipelineArtifactRegistry. */
export type PipelineArtifactRegistryConnection = {
  __typename?: 'PipelineArtifactRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineArtifactRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineArtifactRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineArtifactRegistryEdge = {
  __typename?: 'PipelineArtifactRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineArtifactRegistry>;
};

/** Autogenerated input type of PipelineCancel */
export type PipelineCancelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID'];
};

/** Autogenerated return type of PipelineCancel */
export type PipelineCancelPayload = {
  __typename?: 'PipelineCancelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type PipelineConfigSourceEnum =
  /** Auto DevOps source. */
  | 'AUTO_DEVOPS_SOURCE'
  /** Bridge source. */
  | 'BRIDGE_SOURCE'
  /** Compliance source. */
  | 'COMPLIANCE_SOURCE'
  /** External project source. */
  | 'EXTERNAL_PROJECT_SOURCE'
  /** Parameter source. */
  | 'PARAMETER_SOURCE'
  /** Remote source. */
  | 'REMOTE_SOURCE'
  /** Repository source. */
  | 'REPOSITORY_SOURCE'
  /** Unknown source. */
  | 'UNKNOWN_SOURCE'
  /** Webide source. */
  | 'WEBIDE_SOURCE';

/** The connection type for Pipeline. */
export type PipelineConnection = {
  __typename?: 'PipelineConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Pipeline>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents pipeline counts for the project */
export type PipelineCounts = {
  __typename?: 'PipelineCounts';
  /** Total number of pipelines for the project. */
  all?: Maybe<Scalars['Int']>;
  /** Number of pipelines with scope FINISHED for the project */
  finished?: Maybe<Scalars['Int']>;
  /** Number of pipelines with scope PENDING for the project */
  pending?: Maybe<Scalars['Int']>;
  /** Number of pipelines with scope RUNNING for the project */
  running?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of PipelineDestroy */
export type PipelineDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID'];
};

/** Autogenerated return type of PipelineDestroy */
export type PipelineDestroyPayload = {
  __typename?: 'PipelineDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type PipelineEdge = {
  __typename?: 'PipelineEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Pipeline>;
};

/** Event type of the pipeline associated with a merge request */
export type PipelineMergeRequestEventType =
  /** Pipeline run on the changes in the merge request source branch. */
  | 'DETACHED'
  /** Pipeline run on the changes from the source branch combined with the target branch. */
  | 'MERGED_RESULT'
  /** Pipeline ran as part of a merge train. */
  | 'MERGE_TRAIN';

export type PipelineMessage = {
  __typename?: 'PipelineMessage';
  /** Content of the pipeline message. */
  content: Scalars['String'];
  /** ID of the pipeline message. */
  id: Scalars['ID'];
};

export type PipelinePermissions = {
  __typename?: 'PipelinePermissions';
  /** Indicates the user can perform `admin_pipeline` on this resource */
  adminPipeline: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_pipeline` on this resource */
  destroyPipeline: Scalars['Boolean'];
  /** Indicates the user can perform `update_pipeline` on this resource */
  updatePipeline: Scalars['Boolean'];
};

/** Autogenerated input type of PipelineRetry */
export type PipelineRetryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline to mutate. */
  id: Scalars['CiPipelineID'];
};

/** Autogenerated return type of PipelineRetry */
export type PipelineRetryPayload = {
  __typename?: 'PipelineRetryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Pipeline after mutation. */
  pipeline?: Maybe<Pipeline>;
};

/** Represents a pipeline schedule */
export type PipelineSchedule = {
  __typename?: 'PipelineSchedule';
  /** Indicates if the pipeline schedule is active. */
  active: Scalars['Boolean'];
  /** Timestamp of when the pipeline schedule was created. */
  createdAt: Scalars['Time'];
  /** Cron notation for the schedule. */
  cron: Scalars['String'];
  /** Timezone for the pipeline schedule. */
  cronTimezone: Scalars['String'];
  /** Description of the pipeline schedule. */
  description?: Maybe<Scalars['String']>;
  /** Edit path of the pipeline schedule. */
  editPath?: Maybe<Scalars['String']>;
  /** Indicates if a pipelines schedule belongs to a tag. */
  forTag: Scalars['Boolean'];
  /** ID of the pipeline schedule. */
  id: Scalars['ID'];
  /** Last pipeline object. */
  lastPipeline?: Maybe<Pipeline>;
  /** Time when the next pipeline will run. */
  nextRunAt: Scalars['Time'];
  /** Owner of the pipeline schedule. */
  owner: UserCore;
  /** Project of the pipeline schedule. */
  project?: Maybe<Project>;
  /** Time when the next pipeline will run. */
  realNextRun: Scalars['Time'];
  /** Ref of the pipeline schedule. */
  ref?: Maybe<Scalars['String']>;
  /** Git ref for the pipeline schedule. */
  refForDisplay?: Maybe<Scalars['String']>;
  /** Path to the ref that triggered the pipeline. */
  refPath?: Maybe<Scalars['String']>;
  /** Timestamp of when the pipeline schedule was last updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: PipelineSchedulePermissions;
  /** Pipeline schedule variables. */
  variables?: Maybe<PipelineScheduleVariableConnection>;
};


/** Represents a pipeline schedule */
export type PipelineScheduleVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PipelineSchedule. */
export type PipelineScheduleConnection = {
  __typename?: 'PipelineScheduleConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineScheduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineSchedule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of PipelineScheduleCreate */
export type PipelineScheduleCreateInput = {
  /** Indicates if the pipeline schedule should be active or not. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Cron expression of the pipeline schedule. */
  cron: Scalars['String'];
  /**
   * Cron time zone supported by ActiveSupport::TimeZone.
   * For example: "Pacific Time (US & Canada)" (default: "UTC").
   */
  cronTimezone?: InputMaybe<Scalars['String']>;
  /** Description of the pipeline schedule. */
  description: Scalars['String'];
  /** Full path of the project the pipeline schedule is associated with. */
  projectPath: Scalars['ID'];
  /** Ref of the pipeline schedule. */
  ref: Scalars['String'];
  /** Variables for the pipeline schedule. */
  variables?: InputMaybe<Array<PipelineScheduleVariableInput>>;
};

/** Autogenerated return type of PipelineScheduleCreate */
export type PipelineScheduleCreatePayload = {
  __typename?: 'PipelineScheduleCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created pipeline schedule. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

/** Autogenerated input type of PipelineScheduleDelete */
export type PipelineScheduleDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID'];
};

/** Autogenerated return type of PipelineScheduleDelete */
export type PipelineScheduleDeletePayload = {
  __typename?: 'PipelineScheduleDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type PipelineScheduleEdge = {
  __typename?: 'PipelineScheduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineSchedule>;
};

export type PipelineSchedulePermissions = {
  __typename?: 'PipelineSchedulePermissions';
  /** Indicates the user can perform `admin_pipeline_schedule` on this resource */
  adminPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `play_pipeline_schedule` on this resource */
  playPipelineSchedule: Scalars['Boolean'];
  /**
   * Indicates the user can perform `take_ownership_pipeline_schedule` on this
   * resource Deprecated in 15.9: Use admin_pipeline_schedule permission to
   * determine if the user can take ownership of a pipeline schedule.
   * @deprecated Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule. Deprecated in 15.9.
   */
  takeOwnershipPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `update_pipeline_schedule` on this resource */
  updatePipelineSchedule: Scalars['Boolean'];
};

/** Autogenerated input type of PipelineSchedulePlay */
export type PipelineSchedulePlayInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID'];
};

/** Autogenerated return type of PipelineSchedulePlay */
export type PipelineSchedulePlayPayload = {
  __typename?: 'PipelineSchedulePlayPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Pipeline schedule after mutation. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

export type PipelineScheduleStatus =
  /** Active pipeline schedules. */
  | 'ACTIVE'
  /** Inactive pipeline schedules. */
  | 'INACTIVE';

/** Autogenerated input type of PipelineScheduleTakeOwnership */
export type PipelineScheduleTakeOwnershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID'];
};

/** Autogenerated return type of PipelineScheduleTakeOwnership */
export type PipelineScheduleTakeOwnershipPayload = {
  __typename?: 'PipelineScheduleTakeOwnershipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated pipeline schedule ownership. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

/** Autogenerated input type of PipelineScheduleUpdate */
export type PipelineScheduleUpdateInput = {
  /** Indicates if the pipeline schedule should be active or not. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Cron expression of the pipeline schedule. */
  cron?: InputMaybe<Scalars['String']>;
  /**
   * Cron time zone supported by ActiveSupport::TimeZone.
   * For example: "Pacific Time (US & Canada)" (default: "UTC").
   */
  cronTimezone?: InputMaybe<Scalars['String']>;
  /** Description of the pipeline schedule. */
  description?: InputMaybe<Scalars['String']>;
  /** ID of the pipeline schedule to mutate. */
  id: Scalars['CiPipelineScheduleID'];
  /** Ref of the pipeline schedule. */
  ref?: InputMaybe<Scalars['String']>;
  /** Variables for the pipeline schedule. */
  variables?: InputMaybe<Array<PipelineScheduleVariableInput>>;
};

/** Autogenerated return type of PipelineScheduleUpdate */
export type PipelineScheduleUpdatePayload = {
  __typename?: 'PipelineScheduleUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated pipeline schedule. */
  pipelineSchedule?: Maybe<PipelineSchedule>;
};

export type PipelineScheduleVariable = CiVariable & {
  __typename?: 'PipelineScheduleVariable';
  /** ID of the variable. */
  id: Scalars['ID'];
  /** Name of the variable. */
  key?: Maybe<Scalars['String']>;
  /** Indicates whether the variable is raw. */
  raw?: Maybe<Scalars['Boolean']>;
  /** Value of the variable. */
  value?: Maybe<Scalars['String']>;
  /** Type of the variable. */
  variableType?: Maybe<CiVariableType>;
};

/** The connection type for PipelineScheduleVariable. */
export type PipelineScheduleVariableConnection = {
  __typename?: 'PipelineScheduleVariableConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineScheduleVariableEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineScheduleVariable>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineScheduleVariableEdge = {
  __typename?: 'PipelineScheduleVariableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineScheduleVariable>;
};

/** Attributes for the pipeline schedule variable. */
export type PipelineScheduleVariableInput = {
  /** Name of the variable. */
  key: Scalars['String'];
  /** Value of the variable. */
  value: Scalars['String'];
  /** Type of the variable. */
  variableType: CiVariableType;
};

export type PipelineScopeEnum =
  /** Branches. */
  | 'BRANCHES'
  /** Pipeline has completed. */
  | 'FINISHED'
  /** Pipeline has not started running yet. */
  | 'PENDING'
  /** Pipeline is running. */
  | 'RUNNING'
  /** Tags. */
  | 'TAGS';

/** Represents vulnerability finding of a security report on the pipeline. */
export type PipelineSecurityReportFinding = {
  __typename?: 'PipelineSecurityReportFinding';
  /** List of assets associated with the vulnerability. */
  assets?: Maybe<Array<AssetType>>;
  /** Description of the vulnerability finding. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Details of the security finding. */
  details: Array<VulnerabilityDetail>;
  /** Reason for the dismissal of the security report finding. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** Time of the dismissal of the security report finding. */
  dismissedAt?: Maybe<Scalars['Time']>;
  /** User who dismissed the security report finding. */
  dismissedBy?: Maybe<UserCore>;
  /** Evidence for the vulnerability. */
  evidence?: Maybe<VulnerabilityEvidence>;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']>;
  /** Identifiers of the vulnerability finding. */
  identifiers: Array<VulnerabilityIdentifier>;
  /** List of issue links related to the vulnerability. */
  issueLinks?: Maybe<VulnerabilityIssueLinkConnection>;
  /** List of links associated with the vulnerability. */
  links?: Maybe<Array<VulnerabilityLink>>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /** Merge request that fixes the vulnerability. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Project on which the vulnerability finding was found. */
  project?: Maybe<Project>;
  /**
   * Same as uuid. It is strongly suggested to use the uuid field instead. Deprecated in 16.1: Use uuid instead.
   * @deprecated Use uuid instead. Deprecated in 16.1.
   */
  projectFingerprint?: Maybe<Scalars['String']>;
  /** Remediations of the security report finding. */
  remediations?: Maybe<Array<VulnerabilityRemediationType>>;
  /** Type of the security report that found the vulnerability finding. */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability finding. */
  severity?: Maybe<VulnerabilitySeverity>;
  /** Solution for resolving the security report finding. */
  solution?: Maybe<Scalars['String']>;
  /** Finding status. */
  state?: Maybe<VulnerabilityState>;
  /** Comment for the state of the security report finding. */
  stateComment?: Maybe<Scalars['String']>;
  /** Title of the vulnerability finding. */
  title?: Maybe<Scalars['String']>;
  /** UUIDv5 digest based on the vulnerability's report type, primary identifier, location, fingerprint, project identifier. */
  uuid?: Maybe<Scalars['String']>;
  /** Vulnerability related to the security report finding. */
  vulnerability?: Maybe<Vulnerability>;
};


/** Represents vulnerability finding of a security report on the pipeline. */
export type PipelineSecurityReportFindingIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PipelineSecurityReportFinding. */
export type PipelineSecurityReportFindingConnection = {
  __typename?: 'PipelineSecurityReportFindingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PipelineSecurityReportFindingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PipelineSecurityReportFinding>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PipelineSecurityReportFindingEdge = {
  __typename?: 'PipelineSecurityReportFindingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PipelineSecurityReportFinding>;
};

export type PipelineStatusEnum =
  /** Pipeline was canceled before completion. */
  | 'CANCELED'
  /** Pipeline has been created. */
  | 'CREATED'
  /** At least one stage of the pipeline failed. */
  | 'FAILED'
  /** Pipeline needs to be manually started. */
  | 'MANUAL'
  /** Pipeline has not started running yet. */
  | 'PENDING'
  /** Pipeline is preparing to run. */
  | 'PREPARING'
  /** Pipeline is running. */
  | 'RUNNING'
  /** Pipeline is scheduled to run. */
  | 'SCHEDULED'
  /** Pipeline was skipped. */
  | 'SKIPPED'
  /** Pipeline completed successfully. */
  | 'SUCCESS'
  /** A resource (for example, a runner) that the pipeline requires to run is unavailable. */
  | 'WAITING_FOR_RESOURCE';

export type PreviewBillableUserChange = {
  __typename?: 'PreviewBillableUserChange';
  /** Total number of billable users after change. */
  newBillableUserCount?: Maybe<Scalars['Int']>;
  /** Number of seats in subscription. */
  seatsInSubscription?: Maybe<Scalars['Int']>;
  /** If the group will have an increased overage after change. */
  willIncreaseOverage?: Maybe<Scalars['Boolean']>;
};

/** Represents a product analytics dashboard. */
export type ProductAnalyticsDashboard = {
  __typename?: 'ProductAnalyticsDashboard';
  /** Description of the dashboard. */
  description?: Maybe<Scalars['String']>;
  /** Panels shown on the dashboard. */
  panels: ProductAnalyticsDashboardPanelConnection;
  /** Slug of the dashboard. */
  slug: Scalars['String'];
  /** Title of the dashboard. */
  title: Scalars['String'];
  /** Indicates whether the dashboard is user-defined or provided by GitLab. */
  userDefined: Scalars['Boolean'];
};


/** Represents a product analytics dashboard. */
export type ProductAnalyticsDashboardPanelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ProductAnalyticsDashboard. */
export type ProductAnalyticsDashboardConnection = {
  __typename?: 'ProductAnalyticsDashboardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductAnalyticsDashboardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProductAnalyticsDashboard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProductAnalyticsDashboardEdge = {
  __typename?: 'ProductAnalyticsDashboardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductAnalyticsDashboard>;
};

/** Represents a product analytics dashboard panel. */
export type ProductAnalyticsDashboardPanel = {
  __typename?: 'ProductAnalyticsDashboardPanel';
  /** Description of the position and size of the panel. */
  gridAttributes?: Maybe<Scalars['JSON']>;
  /** Overrides for the visualization query object. */
  queryOverrides?: Maybe<Scalars['JSON']>;
  /** Title of the panel. */
  title: Scalars['String'];
  /** Visualization of the panel. */
  visualization: ProductAnalyticsDashboardVisualization;
};

/** The connection type for ProductAnalyticsDashboardPanel. */
export type ProductAnalyticsDashboardPanelConnection = {
  __typename?: 'ProductAnalyticsDashboardPanelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductAnalyticsDashboardPanelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProductAnalyticsDashboardPanel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProductAnalyticsDashboardPanelEdge = {
  __typename?: 'ProductAnalyticsDashboardPanelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductAnalyticsDashboardPanel>;
};

/** Represents a product analytics dashboard visualization. */
export type ProductAnalyticsDashboardVisualization = {
  __typename?: 'ProductAnalyticsDashboardVisualization';
  /** Data of the visualization. */
  data: Scalars['JSON'];
  /** Options of the visualization. */
  options: Scalars['JSON'];
  /** Slug of the visualization. */
  slug: Scalars['String'];
  /** Type of the visualization. */
  type: Scalars['String'];
};

/** The connection type for ProductAnalyticsDashboardVisualization. */
export type ProductAnalyticsDashboardVisualizationConnection = {
  __typename?: 'ProductAnalyticsDashboardVisualizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductAnalyticsDashboardVisualizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProductAnalyticsDashboardVisualization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProductAnalyticsDashboardVisualizationEdge = {
  __typename?: 'ProductAnalyticsDashboardVisualizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductAnalyticsDashboardVisualization>;
};

/** Current state of the product analytics stack. */
export type ProductAnalyticsState =
  /** Stack has been initialized and has data. */
  | 'COMPLETE'
  /** Stack has not been created yet. */
  | 'CREATE_INSTANCE'
  /** Stack is currently initializing. */
  | 'LOADING_INSTANCE'
  /** Stack is waiting for events from users. */
  | 'WAITING_FOR_EVENTS';

export type Project = {
  __typename?: 'Project';
  /** Size limit for the repository in bytes. */
  actualRepositorySizeLimit?: Maybe<Scalars['Float']>;
  /** Agent configurations defined by the project */
  agentConfigurations?: Maybe<AgentConfigurationConnection>;
  /**
   * Ai Chat conversations related to a given project. Introduced in 16.0: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  aiConversations?: Maybe<ProjectConversations>;
  /** A single Alert Management alert of the project. */
  alertManagementAlert?: Maybe<AlertManagementAlert>;
  /** Counts of alerts by status for the project. */
  alertManagementAlertStatusCounts?: Maybe<AlertManagementAlertStatusCountsType>;
  /** Alert Management alerts of the project. */
  alertManagementAlerts?: Maybe<AlertManagementAlertConnection>;
  /** HTTP Integrations which can receive alerts for the project. */
  alertManagementHttpIntegrations?: Maybe<AlertManagementHttpIntegrationConnection>;
  /** Integrations which can receive alerts for the project. */
  alertManagementIntegrations?: Maybe<AlertManagementIntegrationConnection>;
  /** Extract alert fields from payload for custom mapping. */
  alertManagementPayloadFields?: Maybe<Array<AlertManagementPayloadAlertField>>;
  /**
   * If `only_allow_merge_if_pipeline_succeeds` is true, indicates if merge
   * requests of the project can also be merged with skipped jobs.
   */
  allowMergeOnSkippedPipeline?: Maybe<Scalars['Boolean']>;
  /** API fuzzing configuration for the project. */
  apiFuzzingCiConfiguration?: Maybe<ApiFuzzingCiConfiguration>;
  /** Indicates the archived status of the project. */
  archived?: Maybe<Scalars['Boolean']>;
  /** Indicates if issues referenced by merge requests and commits within the default branch are closed automatically. */
  autocloseReferencedIssues?: Maybe<Scalars['Boolean']>;
  /** URL to avatar image file of the project. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** A single board of the project. */
  board?: Maybe<Board>;
  /** Boards of the project. */
  boards?: Maybe<BoardConnection>;
  /** Branch rules configured for the project. */
  branchRules?: Maybe<BranchRuleConnection>;
  /** Authorized cluster agents for the project through ci_access keyword. */
  ciAccessAuthorizedAgents?: Maybe<ClusterAgentAuthorizationCiAccessConnection>;
  /** CI/CD settings for the project. */
  ciCdSettings?: Maybe<ProjectCiCdSetting>;
  /** Path of the CI configuration file. */
  ciConfigPathOrDefault: Scalars['String'];
  /**
   * CI/CD config variable. Introduced in 15.3: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.
   */
  ciConfigVariables?: Maybe<Array<CiConfigVariable>>;
  /** The CI Job Tokens scope of access. */
  ciJobTokenScope?: Maybe<CiJobTokenScopeType>;
  /** Find a single CI/CD template by name. */
  ciTemplate?: Maybe<CiTemplate>;
  /** List of the project's CI/CD variables. */
  ciVariables?: Maybe<CiProjectVariableConnection>;
  /** Find a single cluster agent by name. */
  clusterAgent?: Maybe<ClusterAgent>;
  /** Cluster agents associated with the project. */
  clusterAgents?: Maybe<ClusterAgentConnection>;
  /** Code coverage summary associated with the project. */
  codeCoverageSummary?: Maybe<CodeCoverageSummary>;
  /**
   * Get tag names containing a given commit. Introduced in 16.0: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  commitReferences?: Maybe<CommitReferences>;
  /** Compliance frameworks associated with the project. */
  complianceFrameworks?: Maybe<ComplianceFrameworkConnection>;
  /** Container expiration policy of the project. */
  containerExpirationPolicy?: Maybe<ContainerExpirationPolicy>;
  /** Indicates if Container Registry is enabled for the current user */
  containerRegistryEnabled?: Maybe<Scalars['Boolean']>;
  /** Container repositories of the project. */
  containerRepositories?: Maybe<ContainerRepositoryConnection>;
  /** Number of container repositories in the project. */
  containerRepositoriesCount: Scalars['Int'];
  /** Find corpuses of the project. */
  corpuses?: Maybe<CoverageFuzzingCorpusConnection>;
  /** Timestamp of the project creation. */
  createdAt?: Maybe<Scalars['Time']>;
  /** DAST Profile associated with the project. */
  dastProfile?: Maybe<DastProfile>;
  /** DAST Profiles associated with the project. */
  dastProfiles?: Maybe<DastProfileConnection>;
  /** DAST scanner profiles associated with the project. */
  dastScannerProfiles?: Maybe<DastScannerProfileConnection>;
  /** DAST Site Profile associated with the project. */
  dastSiteProfile?: Maybe<DastSiteProfile>;
  /** DAST Site Profiles associated with the project. */
  dastSiteProfiles?: Maybe<DastSiteProfileConnection>;
  /** DAST Site Validations associated with the project. */
  dastSiteValidations?: Maybe<DastSiteValidationConnection>;
  /** Data transfer data point for a specific period. This is mocked data under a development feature flag. */
  dataTransfer?: Maybe<ProjectDataTransfer>;
  /**
   * Software dependencies used by the project. Introduced in 15.9: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  dependencies?: Maybe<DependencyConnection>;
  /** Details of the deployment of the project. */
  deployment?: Maybe<Deployment>;
  /** Short description of the project. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Project's DORA metrics. */
  dora?: Maybe<Dora>;
  /** A single environment of the project. */
  environment?: Maybe<Environment>;
  /** Environments of the project. This field can only be resolved for one project in any single request. */
  environments?: Maybe<EnvironmentConnection>;
  /**
   * Flow metrics for value stream analytics. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  flowMetrics?: Maybe<ProjectValueStreamAnalyticsFlowMetrics>;
  /**
   * Details of the fork project compared to its upstream project. Introduced in
   * 15.7: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.
   */
  forkDetails?: Maybe<ForkDetails>;
  /** Namespaces in which the current user can fork the project into. */
  forkTargets?: Maybe<NamespaceConnection>;
  /** Number of times the project has been forked. */
  forksCount: Scalars['Int'];
  /** Full path of the project. */
  fullPath: Scalars['ID'];
  /** Preview Billable User Changes */
  gitlabSubscriptionsPreviewBillableUserChange?: Maybe<PreviewBillableUserChange>;
  /** Grafana integration details for the project. */
  grafanaIntegration?: Maybe<GrafanaIntegration>;
  /** Group of the project. */
  group?: Maybe<Group>;
  /** Indicates whether Jira issue creation from vulnerabilities is enabled. */
  hasJiraVulnerabilityIssueCreationEnabled: Scalars['Boolean'];
  /** URL to connect to the project via HTTPS. */
  httpUrlToRepo?: Maybe<Scalars['String']>;
  /** ID of the project. */
  id: Scalars['ID'];
  /** Status of import background job of the project. */
  importStatus?: Maybe<Scalars['String']>;
  /** Incident Management escalation policies of the project. */
  incidentManagementEscalationPolicies?: Maybe<EscalationPolicyTypeConnection>;
  /** Incident Management escalation policy of the project. */
  incidentManagementEscalationPolicy?: Maybe<EscalationPolicyType>;
  /** Incident Management On-call schedules of the project. */
  incidentManagementOncallSchedules?: Maybe<IncidentManagementOncallScheduleConnection>;
  /** Incident Management Timeline event associated with the incident. */
  incidentManagementTimelineEvent?: Maybe<TimelineEventType>;
  /** Timeline event tags for the project. */
  incidentManagementTimelineEventTags?: Maybe<Array<TimelineEventTagType>>;
  /** Incident Management Timeline events associated with the incident. */
  incidentManagementTimelineEvents?: Maybe<TimelineEventTypeConnection>;
  /** List of CI/CD variables the project inherited from its parent group and ancestors. */
  inheritedCiVariables?: Maybe<InheritedCiVariableConnection>;
  /**
   * Indicates if a project is a catalog resource. Introduced in 15.11: This
   * feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  isCatalogResource?: Maybe<Scalars['Boolean']>;
  /** A single issue of the project. */
  issue?: Maybe<Issue>;
  /** Counts of issues by status for the project. */
  issueStatusCounts?: Maybe<IssueStatusCountsType>;
  /** Issues of the project. */
  issues?: Maybe<IssueConnection>;
  /** Indicates if Issues are enabled for the current user */
  issuesEnabled?: Maybe<Scalars['Boolean']>;
  /** Find iteration cadences. */
  iterationCadences?: Maybe<IterationCadenceConnection>;
  /** Find iterations. */
  iterations?: Maybe<IterationConnection>;
  /** Status of Jira import background job of the project. */
  jiraImportStatus?: Maybe<Scalars['String']>;
  /** Jira imports into the project. */
  jiraImports?: Maybe<JiraImportConnection>;
  /** One job belonging to the project, selected by ID. */
  job?: Maybe<CiJob>;
  /** Jobs of a project. This field can only be resolved for one project in any single request. */
  jobs?: Maybe<CiJobConnection>;
  /** Indicates if CI/CD pipeline jobs are enabled for the current user. */
  jobsEnabled?: Maybe<Scalars['Boolean']>;
  /** Label available on this project. */
  label?: Maybe<Label>;
  /** Labels available on this project. */
  labels?: Maybe<LabelConnection>;
  /** Programming languages used in the project. */
  languages?: Maybe<Array<RepositoryLanguage>>;
  /** Timestamp of the project last activity. */
  lastActivityAt?: Maybe<Scalars['Time']>;
  /** Indicates if the project has Large File Storage (LFS) enabled. */
  lfsEnabled?: Maybe<Scalars['Boolean']>;
  /** Template used to create merge commit message in merge requests. */
  mergeCommitTemplate?: Maybe<Scalars['String']>;
  /** A single merge request of the project. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Merge requests of the project. */
  mergeRequests?: Maybe<MergeRequestConnection>;
  /** Indicates that committers of the given merge request cannot approve. */
  mergeRequestsDisableCommittersApproval: Scalars['Boolean'];
  /** Indicates if Merge Requests are enabled for the current user */
  mergeRequestsEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Indicates if no merge commits should be created and all merges should instead
   * be fast-forwarded, which means that merging is only allowed if the branch
   * could be fast-forwarded.
   */
  mergeRequestsFfOnlyEnabled?: Maybe<Scalars['Boolean']>;
  /** Milestones of the project. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the project (without namespace). */
  name: Scalars['String'];
  /** Full name of the project with its namespace. */
  nameWithNamespace: Scalars['String'];
  /** Namespace of the project. */
  namespace?: Maybe<Namespace>;
  /** Environments for this project with nested folders, can only be resolved for one project in any single request */
  nestedEnvironments?: Maybe<NestedEnvironmentConnection>;
  /**
   * Network Policies of the project Deprecated in 14.8: Network policies are
   * deprecated and will be removed in GitLab 16.0. Since GitLab 15.0 this field
   * returns no data.
   * @deprecated Network policies are deprecated and will be removed in GitLab 16.0. Since GitLab 15.0 this field returns no data. Deprecated in 14.8.
   */
  networkPolicies?: Maybe<NetworkPolicyConnection>;
  /** Indicates if merge requests of the project can only be merged when all the discussions are resolved. */
  onlyAllowMergeIfAllDiscussionsAreResolved?: Maybe<Scalars['Boolean']>;
  /** Indicates that merges of merge requests should be blocked unless all status checks have passed. */
  onlyAllowMergeIfAllStatusChecksPassed?: Maybe<Scalars['Boolean']>;
  /** Indicates if merge requests of the project can only be merged with successful jobs. */
  onlyAllowMergeIfPipelineSucceeds?: Maybe<Scalars['Boolean']>;
  /** Number of open issues for the project. */
  openIssuesCount?: Maybe<Scalars['Int']>;
  /** Packages of the project. */
  packages?: Maybe<PackageConnection>;
  /** Packages cleanup policy for the project. */
  packagesCleanupPolicy?: Maybe<PackagesCleanupPolicy>;
  /** Path of the project. */
  path: Scalars['String'];
  /** The project's path locks. */
  pathLocks?: Maybe<PathLockConnection>;
  /** Build pipeline of the project. */
  pipeline?: Maybe<Pipeline>;
  /** Pipeline analytics. */
  pipelineAnalytics?: Maybe<PipelineAnalytics>;
  /** Build pipeline counts of the project. */
  pipelineCounts?: Maybe<PipelineCounts>;
  /** Pipeline schedules of the project. This field can only be resolved for one project per request. */
  pipelineSchedules?: Maybe<PipelineScheduleConnection>;
  /** Build pipelines of the project. */
  pipelines?: Maybe<PipelineConnection>;
  /**
   * Indicates if a link to create or view a merge request should display after a
   * push to Git repositories of the project from the command line.
   */
  printingMergeRequestLinkEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Product Analytics dashboards of the project. Introduced in 15.6: This feature
   * is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.
   */
  productAnalyticsDashboards?: Maybe<ProductAnalyticsDashboardConnection>;
  /**
   * Product Analytics instrumentation key assigned to the project. Introduced in
   * 16.0: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  productAnalyticsInstrumentationKey?: Maybe<Scalars['String']>;
  /**
   * Current state of the product analytics stack for this project.Can only be
   * called for one project in a single request Introduced in 15.10: This feature
   * is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  productAnalyticsState?: Maybe<ProductAnalyticsState>;
  /**
   * Visualizations of the project or associated configuration project. Introduced
   * in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  productAnalyticsVisualizations?: Maybe<ProductAnalyticsDashboardVisualizationConnection>;
  /** Members of the project. */
  projectMembers?: Maybe<MemberInterfaceConnection>;
  /** Indicates if there is public access to pipelines and job details of the project, including output logs and artifacts. */
  publicJobs?: Maybe<Scalars['Boolean']>;
  /** Project's push rules settings. */
  pushRules?: Maybe<PushRules>;
  /** List of recently visited boards of the project. Maximum size is 4. */
  recentIssueBoards?: Maybe<BoardConnection>;
  /** A single release of the project. */
  release?: Maybe<Release>;
  /** Releases of the project. */
  releases?: Maybe<ReleaseConnection>;
  /** Indicates if `Delete source branch` option should be enabled by default for all new merge requests of the project. */
  removeSourceBranchAfterMerge?: Maybe<Scalars['Boolean']>;
  /** Git repository of the project. */
  repository?: Maybe<Repository>;
  /** Size of repository that exceeds the limit in bytes. */
  repositorySizeExcess?: Maybe<Scalars['Float']>;
  /** Indicates if users can request member access to the project. */
  requestAccessEnabled?: Maybe<Scalars['Boolean']>;
  /** Find a single requirement. */
  requirement?: Maybe<Requirement>;
  /** Number of requirements for the project by their state. */
  requirementStatesCount?: Maybe<RequirementStatesCount>;
  /** Find requirements. */
  requirements?: Maybe<RequirementConnection>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** SAST CI configuration for the project. */
  sastCiConfiguration?: Maybe<SastCiConfiguration>;
  /** Scan Execution Policies of the project */
  scanExecutionPolicies?: Maybe<ScanExecutionPolicyConnection>;
  /** Scan Result Policies of the project */
  scanResultPolicies?: Maybe<ScanResultPolicyConnection>;
  /** Path to project's security dashboard. */
  securityDashboardPath?: Maybe<Scalars['String']>;
  /** Information about security analyzers used in the project. */
  securityScanners?: Maybe<SecurityScanners>;
  /** List of security training providers for the project */
  securityTrainingProviders?: Maybe<Array<ProjectSecurityTraining>>;
  /** Security training URLs for the enabled training providers of the project. */
  securityTrainingUrls?: Maybe<Array<SecurityTrainingUrl>>;
  /** Detailed version of a Sentry error on the project. */
  sentryDetailedError?: Maybe<SentryDetailedError>;
  /** Paginated collection of Sentry errors on the project. */
  sentryErrors?: Maybe<SentryErrorCollection>;
  /** E-mail address of the Service Desk. */
  serviceDeskAddress?: Maybe<Scalars['String']>;
  /** Indicates if the project has Service Desk enabled. */
  serviceDeskEnabled?: Maybe<Scalars['Boolean']>;
  /**
   * Project services. Deprecated in 15.9: This will be renamed to `Project.integrations`.
   * @deprecated This will be renamed to `Project.integrations`. Deprecated in 15.9.
   */
  services?: Maybe<ServiceConnection>;
  /** Indicates if shared runners are enabled for the project. */
  sharedRunnersEnabled?: Maybe<Scalars['Boolean']>;
  /** Snippets of the project. */
  snippets?: Maybe<SnippetConnection>;
  /** Indicates if Snippets are enabled for the current user */
  snippetsEnabled?: Maybe<Scalars['Boolean']>;
  /** Template used to create squash commit message in merge requests. */
  squashCommitTemplate?: Maybe<Scalars['String']>;
  /** Indicates if `squashReadOnly` is enabled. */
  squashReadOnly: Scalars['Boolean'];
  /** URL to connect to the project via SSH. */
  sshUrlToRepo?: Maybe<Scalars['String']>;
  /** Number of times the project has been starred. */
  starCount: Scalars['Int'];
  /** Statistics of the project. */
  statistics?: Maybe<ProjectStatistics>;
  /** Redirects for Statistics of the project. */
  statisticsDetailsPaths?: Maybe<ProjectStatisticsRedirect>;
  /** Commit message used to apply merge request suggestions. */
  suggestionCommitMessage?: Maybe<Scalars['String']>;
  /**
   * List of project topics (not Git tags). Deprecated in 13.12: Use `topics`.
   * @deprecated Use `topics`. Deprecated in 13.12.
   */
  tagList?: Maybe<Scalars['String']>;
  /** Find a single Terraform state by name. */
  terraformState?: Maybe<TerraformState>;
  /** Terraform states associated with the project. */
  terraformStates?: Maybe<TerraformStateConnection>;
  /**
   * Timelog categories for the project. Introduced in 15.3: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.
   */
  timelogCategories?: Maybe<TimeTrackingTimelogCategoryConnection>;
  /** Time logged on issues and merge requests in the project. */
  timelogs?: Maybe<TimelogConnection>;
  /** List of project topics. */
  topics?: Maybe<Array<Scalars['String']>>;
  /**
   * Tracking key assigned to the project. Introduced in 16.0: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  trackingKey?: Maybe<Scalars['String']>;
  /** Authorized cluster agents for the project through user_access keyword. */
  userAccessAuthorizedAgents?: Maybe<ClusterAgentAuthorizationUserAccessConnection>;
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
  /** Visibility of the project. */
  visibility?: Maybe<Scalars['String']>;
  /**
   * Visible forks of the project. Introduced in 15.10: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  visibleForks?: Maybe<ProjectConnection>;
  /** Vulnerabilities reported on the project. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the project. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Container images reported on the project vulnerabilities. */
  vulnerabilityImages?: Maybe<VulnerabilityContainerImageConnection>;
  /** Vulnerability scanners reported on the project vulnerabilities. */
  vulnerabilityScanners?: Maybe<VulnerabilityScannerConnection>;
  /** Counts for each vulnerability severity in the project. */
  vulnerabilitySeveritiesCount?: Maybe<VulnerabilitySeveritiesCount>;
  /** Web URL of the project. */
  webUrl?: Maybe<Scalars['String']>;
  /** Indicates if Wikis are enabled for the current user */
  wikiEnabled?: Maybe<Scalars['Boolean']>;
  /** Work item types available to the project. */
  workItemTypes?: Maybe<WorkItemTypeConnection>;
  /**
   * Work items of the project. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItems?: Maybe<WorkItemConnection>;
};


export type ProjectAgentConfigurationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementAlertArgs = {
  assigneeUsername?: InputMaybe<Scalars['String']>;
  domain?: AlertManagementDomainFilter;
  iid?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


export type ProjectAlertManagementAlertStatusCountsArgs = {
  assigneeUsername?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
};


export type ProjectAlertManagementAlertsArgs = {
  after?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  domain?: AlertManagementDomainFilter;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<AlertManagementAlertSort>;
  statuses?: InputMaybe<Array<AlertManagementStatus>>;
};


export type ProjectAlertManagementHttpIntegrationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['AlertManagementHttpIntegrationID']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementIntegrationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['GlobalID']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectAlertManagementPayloadFieldsArgs = {
  payloadExample: Scalars['String'];
};


export type ProjectBoardArgs = {
  id: Scalars['BoardID'];
};


export type ProjectBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['BoardID']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectBranchRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectCiAccessAuthorizedAgentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectCiConfigVariablesArgs = {
  ref: Scalars['String'];
};


export type ProjectCiTemplateArgs = {
  name: Scalars['String'];
};


export type ProjectCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<CiVariableSort>;
};


export type ProjectClusterAgentArgs = {
  hasRemoteDevelopmentAgentConfig?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};


export type ProjectClusterAgentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  hasRemoteDevelopmentAgentConfig?: InputMaybe<Scalars['Boolean']>;
  hasVulnerabilities?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectCommitReferencesArgs = {
  commitSha: Scalars['String'];
};


export type ProjectComplianceFrameworksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectContainerRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<ContainerRepositorySort>;
};


export type ProjectCorpusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastProfileArgs = {
  hasDastProfileSchedule?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['DastProfileID'];
};


export type ProjectDastProfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  hasDastProfileSchedule?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastScannerProfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastSiteProfileArgs = {
  id: Scalars['DastSiteProfileID'];
};


export type ProjectDastSiteProfilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectDastSiteValidationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  normalizedTargetUrls?: InputMaybe<Array<Scalars['String']>>;
  status?: InputMaybe<DastSiteValidationStatusEnum>;
};


export type ProjectDataTransferArgs = {
  from?: InputMaybe<Scalars['Date']>;
  to?: InputMaybe<Scalars['Date']>;
};


export type ProjectDependenciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  componentNames?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  packageManagers?: InputMaybe<Array<PackageManager>>;
  sort?: InputMaybe<DependencySort>;
};


export type ProjectDeploymentArgs = {
  iid: Scalars['ID'];
};


export type ProjectEnvironmentArgs = {
  name?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<Scalars['String']>;
};


export type ProjectEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<Scalars['String']>;
};


export type ProjectForkDetailsArgs = {
  ref?: InputMaybe<Scalars['String']>;
};


export type ProjectForkTargetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type ProjectGitlabSubscriptionsPreviewBillableUserChangeArgs = {
  addGroupId?: InputMaybe<Scalars['Int']>;
  addUserEmails?: InputMaybe<Array<Scalars['String']>>;
  addUserIds?: InputMaybe<Array<Scalars['Int']>>;
  role: GitlabSubscriptionsUserRole;
};


export type ProjectIncidentManagementEscalationPoliciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};


export type ProjectIncidentManagementEscalationPolicyArgs = {
  id: Scalars['IncidentManagementEscalationPolicyID'];
  name?: InputMaybe<Scalars['String']>;
};


export type ProjectIncidentManagementOncallSchedulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIncidentManagementTimelineEventArgs = {
  id: Scalars['IncidentManagementTimelineEventID'];
  incidentId: Scalars['IssueID'];
};


export type ProjectIncidentManagementTimelineEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  incidentId: Scalars['IssueID'];
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectInheritedCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectIssueArgs = {
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  epicId?: InputMaybe<Scalars['String']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  healthStatus?: InputMaybe<HealthStatus>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationTitle?: InputMaybe<Scalars['String']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  weight?: InputMaybe<Scalars['String']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectIssueStatusCountsArgs = {
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  epicId?: InputMaybe<Scalars['String']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationTitle?: InputMaybe<Scalars['String']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  weight?: InputMaybe<Scalars['String']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  epicId?: InputMaybe<Scalars['String']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  first?: InputMaybe<Scalars['Int']>;
  healthStatus?: InputMaybe<HealthStatus>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationTitle?: InputMaybe<Scalars['String']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  releaseTag?: InputMaybe<Array<Scalars['String']>>;
  releaseTagWildcardId?: InputMaybe<ReleaseTagWildcardId>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  weight?: InputMaybe<Scalars['String']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type ProjectIterationCadencesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  automatic?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  durationInWeeks?: InputMaybe<Scalars['Int']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['IterationsCadenceID']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
};


export type ProjectIterationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['ID']>;
  iid?: InputMaybe<Scalars['ID']>;
  in?: InputMaybe<Array<IterationSearchableField>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceIds?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<IterationSort>;
  state?: InputMaybe<IterationState>;
  timeframe?: InputMaybe<Timeframe>;
  title?: InputMaybe<Scalars['String']>;
};


export type ProjectJiraImportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectJobArgs = {
  id: Scalars['JobID'];
};


export type ProjectJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
  withArtifacts?: InputMaybe<Scalars['Boolean']>;
};


export type ProjectLabelArgs = {
  title: Scalars['String'];
};


export type ProjectLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeAncestorGroups?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  searchTerm?: InputMaybe<Scalars['String']>;
};


export type ProjectMergeRequestArgs = {
  iid: Scalars['String'];
};


export type ProjectMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


export type ProjectMilestonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  containingDate?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  includeAncestors?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  searchTitle?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MilestoneSort>;
  state?: InputMaybe<MilestoneStateEnum>;
  timeframe?: InputMaybe<Timeframe>;
  title?: InputMaybe<Scalars['String']>;
};


export type ProjectNestedEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<Scalars['String']>;
};


export type ProjectNetworkPoliciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  environmentId?: InputMaybe<Scalars['EnvironmentID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includeVersionless?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  packageName?: InputMaybe<Scalars['String']>;
  packageType?: InputMaybe<PackageTypeEnum>;
  sort?: InputMaybe<PackageSort>;
  status?: InputMaybe<PackageStatus>;
};


export type ProjectPathLocksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectPipelineArgs = {
  iid?: InputMaybe<Scalars['ID']>;
  sha?: InputMaybe<Scalars['String']>;
};


export type ProjectPipelineCountsArgs = {
  ref?: InputMaybe<Scalars['String']>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};


export type ProjectPipelineSchedulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<PipelineScheduleStatus>;
};


export type ProjectPipelinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  ref?: InputMaybe<Scalars['String']>;
  scope?: InputMaybe<PipelineScopeEnum>;
  sha?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<PipelineStatusEnum>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


export type ProjectProductAnalyticsDashboardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type ProjectProductAnalyticsVisualizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type ProjectProjectMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relations?: InputMaybe<Array<ProjectMemberRelation>>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MemberSort>;
};


export type ProjectRecentIssueBoardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectReleaseArgs = {
  tagName: Scalars['String'];
};


export type ProjectReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<ReleaseSort>;
};


export type ProjectRequirementArgs = {
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  lastTestReportState?: InputMaybe<RequirementStatusFilter>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<Sort>;
  state?: InputMaybe<RequirementState>;
  workItemIid?: InputMaybe<Scalars['ID']>;
  workItemIids?: InputMaybe<Array<Scalars['ID']>>;
};


export type ProjectRequirementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['ID']>;
  iids?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  lastTestReportState?: InputMaybe<RequirementStatusFilter>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<Sort>;
  state?: InputMaybe<RequirementState>;
  workItemIid?: InputMaybe<Scalars['ID']>;
  workItemIids?: InputMaybe<Array<Scalars['ID']>>;
};


export type ProjectRunnersArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  paused?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
};


export type ProjectScanExecutionPoliciesArgs = {
  actionScanTypes?: InputMaybe<Array<SecurityReportTypeEnum>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectScanResultPoliciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  relationship?: InputMaybe<SecurityPolicyRelationType>;
};


export type ProjectSecurityTrainingProvidersArgs = {
  onlyEnabled?: InputMaybe<Scalars['Boolean']>;
};


export type ProjectSecurityTrainingUrlsArgs = {
  filename?: InputMaybe<Scalars['String']>;
  identifierExternalIds: Array<Scalars['String']>;
};


export type ProjectSentryDetailedErrorArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID'];
};


export type ProjectServicesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<ServiceType>;
};


export type ProjectSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


export type ProjectTerraformStateArgs = {
  name: Scalars['String'];
};


export type ProjectTerraformStatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectTimelogCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


export type ProjectUserAccessAuthorizedAgentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVisibleForksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  minimumAccessLevel?: InputMaybe<AccessLevelEnum>;
};


export type ProjectVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']>>;
  first?: InputMaybe<Scalars['Int']>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  sort?: InputMaybe<VulnerabilitySort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type ProjectVulnerabilitiesCountByDayArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate: Scalars['ISO8601Date'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startDate: Scalars['ISO8601Date'];
};


export type ProjectVulnerabilityImagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilityScannersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type ProjectVulnerabilitySeveritiesCountArgs = {
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type ProjectWorkItemTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  taskable?: InputMaybe<Scalars['Boolean']>;
};


export type ProjectWorkItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  last?: InputMaybe<Scalars['Int']>;
  requirementLegacyWidget?: InputMaybe<RequirementLegacyFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<WorkItemSort>;
  state?: InputMaybe<IssuableState>;
  statusWidget?: InputMaybe<StatusFilterInput>;
  types?: InputMaybe<Array<IssueType>>;
};

export type ProjectCiCdSetting = {
  __typename?: 'ProjectCiCdSetting';
  /** Indicates CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: Maybe<Scalars['Boolean']>;
  /** Indicates CI/CD job tokens generated in this project have restricted access to other projects. */
  jobTokenScopeEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether to keep the latest builds artifacts. */
  keepLatestArtifact?: Maybe<Scalars['Boolean']>;
  /** Whether merge pipelines are enabled. */
  mergePipelinesEnabled?: Maybe<Scalars['Boolean']>;
  /** Whether merge trains are enabled. */
  mergeTrainsEnabled?: Maybe<Scalars['Boolean']>;
  /** Project the CI/CD settings belong to. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of ProjectCiCdSettingsUpdate */
export type ProjectCiCdSettingsUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full Path of the project the settings belong to. */
  fullPath: Scalars['ID'];
  /** Indicates CI/CD job tokens generated in other projects have restricted access to this project. */
  inboundJobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * Indicates CI/CD job tokens generated in this project have restricted access to
   * other projects. Deprecated in 16.0: Outbound job token scope is being removed.
   * This field can now only be set to false.
   * @deprecated Outbound job token scope is being removed. This field can now only be set to false. Deprecated in 16.0.
   */
  jobTokenScopeEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the latest artifact should be kept for the project. */
  keepLatestArtifact?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if merge pipelines are enabled for the project. */
  mergePipelinesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if merge trains are enabled for the project. */
  mergeTrainsEnabled?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of ProjectCiCdSettingsUpdate */
export type ProjectCiCdSettingsUpdatePayload = {
  __typename?: 'ProjectCiCdSettingsUpdatePayload';
  /** CI/CD settings after mutation. */
  ciCdSettings: ProjectCiCdSetting;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** The connection type for Project. */
export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type ProjectConversations = {
  __typename?: 'ProjectConversations';
  /**
   * Messages generated by open ai and the user. Introduced in 16.0: This feature
   * is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  ciConfigMessages?: Maybe<AiMessageTypeConnection>;
};


export type ProjectConversationsCiConfigMessagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ProjectDataTransfer = {
  __typename?: 'ProjectDataTransfer';
  /** Data nodes. */
  egressNodes?: Maybe<EgressNodeConnection>;
  /** Total egress for that project in that period of time. */
  totalEgress?: Maybe<Scalars['BigInt']>;
};


export type ProjectDataTransferEgressNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

/** Autogenerated input type of ProjectInitializeProductAnalytics */
export type ProjectInitializeProductAnalyticsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project to initialize. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ProjectInitializeProductAnalytics */
export type ProjectInitializeProductAnalyticsPayload = {
  __typename?: 'ProjectInitializeProductAnalyticsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project on which the initialization took place. */
  project?: Maybe<Project>;
};

/** Represents a Project Membership */
export type ProjectMember = MemberInterface & {
  __typename?: 'ProjectMember';
  /** GitLab::Access level. */
  accessLevel?: Maybe<AccessLevel>;
  /** Date and time the membership was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** User that authorized membership. */
  createdBy?: Maybe<UserCore>;
  /** Date and time the membership expires. */
  expiresAt?: Maybe<Scalars['Time']>;
  /** ID of the member. */
  id: Scalars['ID'];
  /** Find a merge request. */
  mergeRequestInteraction?: Maybe<UserMergeRequestInteraction>;
  /** Project that User is a member of. */
  project?: Maybe<Project>;
  /** Date and time the membership was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** User that is associated with the member object. */
  user?: Maybe<UserCore>;
  /** Permissions for the current user on the resource */
  userPermissions: ProjectPermissions;
};


/** Represents a Project Membership */
export type ProjectMemberMergeRequestInteractionArgs = {
  id: Scalars['MergeRequestID'];
};

/** Autogenerated input type of ProjectMemberBulkUpdate */
export type ProjectMemberBulkUpdateInput = {
  /** Access level to update the members to. */
  accessLevel: MemberAccessLevel;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Date and time the membership expires. */
  expiresAt?: InputMaybe<Scalars['Time']>;
  /** Global ID of the project. */
  projectId: Scalars['ProjectID'];
  /** Global IDs of the members. */
  userIds: Array<Scalars['UserID']>;
};

/** Autogenerated return type of ProjectMemberBulkUpdate */
export type ProjectMemberBulkUpdatePayload = {
  __typename?: 'ProjectMemberBulkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project members after mutation. */
  projectMembers?: Maybe<Array<ProjectMember>>;
};

/** The connection type for ProjectMember. */
export type ProjectMemberConnection = {
  __typename?: 'ProjectMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectMemberEdge = {
  __typename?: 'ProjectMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectMember>;
};

/** Project member relation */
export type ProjectMemberRelation =
  /** Descendants members */
  | 'DESCENDANTS'
  /** Direct members */
  | 'DIRECT'
  /** Inherited members */
  | 'INHERITED'
  /** Invited Groups members */
  | 'INVITED_GROUPS'
  /** Shared Into Ancestors members */
  | 'SHARED_INTO_ANCESTORS';

export type ProjectPermissions = {
  __typename?: 'ProjectPermissions';
  /** Indicates the user can perform `admin_operations` on this resource */
  adminOperations: Scalars['Boolean'];
  /** Indicates the user can perform `admin_path_locks` on this resource */
  adminPathLocks: Scalars['Boolean'];
  /** Indicates the user can perform `admin_project` on this resource */
  adminProject: Scalars['Boolean'];
  /** Indicates the user can perform `admin_remote_mirror` on this resource */
  adminRemoteMirror: Scalars['Boolean'];
  /** Indicates the user can perform `admin_wiki` on this resource */
  adminWiki: Scalars['Boolean'];
  /** Indicates the user can perform `archive_project` on this resource */
  archiveProject: Scalars['Boolean'];
  /** Indicates the user can perform `change_namespace` on this resource */
  changeNamespace: Scalars['Boolean'];
  /** Indicates the user can perform `change_visibility_level` on this resource */
  changeVisibilityLevel: Scalars['Boolean'];
  /** Indicates the user can perform `create_deployment` on this resource */
  createDeployment: Scalars['Boolean'];
  /** Indicates the user can perform `create_design` on this resource */
  createDesign: Scalars['Boolean'];
  /** Indicates the user can perform `create_issue` on this resource */
  createIssue: Scalars['Boolean'];
  /** Indicates the user can perform `create_label` on this resource */
  createLabel: Scalars['Boolean'];
  /** Indicates the user can perform `create_merge_request_from` on this resource */
  createMergeRequestFrom: Scalars['Boolean'];
  /** Indicates the user can perform `create_merge_request_in` on this resource */
  createMergeRequestIn: Scalars['Boolean'];
  /** Indicates the user can perform `create_pages` on this resource */
  createPages: Scalars['Boolean'];
  /** Indicates the user can perform `create_pipeline` on this resource */
  createPipeline: Scalars['Boolean'];
  /** Indicates the user can perform `create_pipeline_schedule` on this resource */
  createPipelineSchedule: Scalars['Boolean'];
  /** Indicates the user can perform `create_snippet` on this resource */
  createSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `create_wiki` on this resource */
  createWiki: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_design` on this resource */
  destroyDesign: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_pages` on this resource */
  destroyPages: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_wiki` on this resource */
  destroyWiki: Scalars['Boolean'];
  /** Indicates the user can perform `download_code` on this resource */
  downloadCode: Scalars['Boolean'];
  /** Indicates the user can perform `download_wiki_code` on this resource */
  downloadWikiCode: Scalars['Boolean'];
  /** Indicates the user can perform `fork_project` on this resource */
  forkProject: Scalars['Boolean'];
  /** Indicates the user can perform `push_code` on this resource */
  pushCode: Scalars['Boolean'];
  /** Indicates the user can perform `push_to_delete_protected_branch` on this resource */
  pushToDeleteProtectedBranch: Scalars['Boolean'];
  /** Indicates the user can perform `read_commit_status` on this resource */
  readCommitStatus: Scalars['Boolean'];
  /** Indicates the user can perform `read_cycle_analytics` on this resource */
  readCycleAnalytics: Scalars['Boolean'];
  /** Indicates the user can perform `read_design` on this resource */
  readDesign: Scalars['Boolean'];
  /** Indicates the user can perform `read_environment` on this resource */
  readEnvironment: Scalars['Boolean'];
  /** Indicates the user can perform `read_merge_request` on this resource */
  readMergeRequest: Scalars['Boolean'];
  /** Indicates the user can perform `read_pages_content` on this resource */
  readPagesContent: Scalars['Boolean'];
  /** Indicates the user can perform `read_project` on this resource */
  readProject: Scalars['Boolean'];
  /** Indicates the user can perform `read_project_member` on this resource */
  readProjectMember: Scalars['Boolean'];
  /** Indicates the user can perform `read_wiki` on this resource */
  readWiki: Scalars['Boolean'];
  /** Indicates the user can perform `remove_fork_project` on this resource */
  removeForkProject: Scalars['Boolean'];
  /** Indicates the user can perform `remove_pages` on this resource */
  removePages: Scalars['Boolean'];
  /** Indicates the user can perform `remove_project` on this resource */
  removeProject: Scalars['Boolean'];
  /** Indicates the user can perform `rename_project` on this resource */
  renameProject: Scalars['Boolean'];
  /** Indicates the user can perform `request_access` on this resource */
  requestAccess: Scalars['Boolean'];
  /** Indicates the user can perform `update_pages` on this resource */
  updatePages: Scalars['Boolean'];
  /** Indicates the user can perform `update_wiki` on this resource */
  updateWiki: Scalars['Boolean'];
  /** Indicates the user can perform `upload_file` on this resource */
  uploadFile: Scalars['Boolean'];
};

/** Represents the source of a security policy belonging to a project */
export type ProjectSecurityPolicySource = {
  __typename?: 'ProjectSecurityPolicySource';
  /** Project the policy is associated with. */
  project?: Maybe<Project>;
};

export type ProjectSecurityTraining = {
  __typename?: 'ProjectSecurityTraining';
  /** Description of the training provider. */
  description?: Maybe<Scalars['String']>;
  /** ID of the training provider. */
  id: Scalars['GlobalID'];
  /** Represents whether the provider is enabled or not. */
  isEnabled: Scalars['Boolean'];
  /** Represents whether the provider is set as primary or not. */
  isPrimary: Scalars['Boolean'];
  /** Logo URL of the provider. */
  logoUrl?: Maybe<Scalars['String']>;
  /** Name of the training provider. */
  name: Scalars['String'];
  /** URL of the provider. */
  url: Scalars['String'];
};

/** Autogenerated input type of ProjectSetComplianceFramework */
export type ProjectSetComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the compliance framework to assign to the project. Set to `null` to unset. */
  complianceFrameworkId?: InputMaybe<Scalars['ComplianceManagementFrameworkID']>;
  /** ID of the project to change the compliance framework of. */
  projectId: Scalars['ProjectID'];
};

/** Autogenerated return type of ProjectSetComplianceFramework */
export type ProjectSetComplianceFrameworkPayload = {
  __typename?: 'ProjectSetComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of ProjectSetLocked */
export type ProjectSetLockedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path to the file. */
  filePath: Scalars['String'];
  /** Whether or not to lock the file path. */
  lock: Scalars['Boolean'];
  /** Full path of the project to mutate. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of ProjectSetLocked */
export type ProjectSetLockedPayload = {
  __typename?: 'ProjectSetLockedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project after mutation. */
  project?: Maybe<Project>;
};

export type ProjectStatistics = {
  __typename?: 'ProjectStatistics';
  /** Build artifacts size of the project in bytes. */
  buildArtifactsSize: Scalars['Float'];
  /** Commit count of the project. */
  commitCount: Scalars['Float'];
  /** Container Registry size of the project in bytes. */
  containerRegistrySize?: Maybe<Scalars['Float']>;
  /** Large File Storage (LFS) object size of the project in bytes. */
  lfsObjectsSize: Scalars['Float'];
  /** Packages size of the project in bytes. */
  packagesSize: Scalars['Float'];
  /** CI Pipeline artifacts size in bytes. */
  pipelineArtifactsSize?: Maybe<Scalars['Float']>;
  /** Repository size of the project in bytes. */
  repositorySize: Scalars['Float'];
  /** Snippets size of the project in bytes. */
  snippetsSize?: Maybe<Scalars['Float']>;
  /** Storage size of the project in bytes. */
  storageSize: Scalars['Float'];
  /** Uploads size of the project in bytes. */
  uploadsSize?: Maybe<Scalars['Float']>;
  /** Wiki size of the project in bytes. */
  wikiSize?: Maybe<Scalars['Float']>;
};

export type ProjectStatisticsRedirect = {
  __typename?: 'ProjectStatisticsRedirect';
  /** Redirection Route for job_artifacts. */
  buildArtifacts: Scalars['String'];
  /** Redirection Route for container_registry. */
  containerRegistry: Scalars['String'];
  /** Redirection Route for packages. */
  packages: Scalars['String'];
  /** Redirection Route for repository. */
  repository: Scalars['String'];
  /** Redirection Route for snippets. */
  snippets: Scalars['String'];
  /** Redirection Route for wiki. */
  wiki: Scalars['String'];
};

/** Autogenerated input type of ProjectSyncFork */
export type ProjectSyncForkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project to initialize. */
  projectPath: Scalars['ID'];
  /** Ref of the fork to fetch into. */
  targetBranch: Scalars['String'];
};

/** Autogenerated return type of ProjectSyncFork */
export type ProjectSyncForkPayload = {
  __typename?: 'ProjectSyncForkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Updated fork details. */
  details?: Maybe<ForkDetails>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetrics = {
  __typename?: 'ProjectValueStreamAnalyticsFlowMetrics';
  /** Median time from first commit to issue closed */
  cycleTime?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of production deployments in the given period. */
  deploymentCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of issues opened in the given period. */
  issueCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Number of open issues closed (completed) in the given period. Maximum value is 10,001. */
  issuesCompletedCount?: Maybe<ValueStreamAnalyticsMetric>;
  /** Median time from when the issue was created to when it was closed. */
  leadTime?: Maybe<ValueStreamAnalyticsMetric>;
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsCycleTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsDeploymentCountArgs = {
  from: Scalars['Time'];
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsIssueCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsIssuesCompletedCountArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  to: Scalars['Time'];
};


/** Exposes aggregated value stream flow metrics */
export type ProjectValueStreamAnalyticsFlowMetricsLeadTimeArgs = {
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  authorUsername?: InputMaybe<Scalars['String']>;
  from: Scalars['Time'];
  labelNames?: InputMaybe<Array<Scalars['String']>>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  to: Scalars['Time'];
};

/** Represents the Geo replication and verification state of a project_wiki_repository */
export type ProjectWikiRepositoryRegistry = {
  __typename?: 'ProjectWikiRepositoryRegistry';
  /** Timestamp when the ProjectWikiRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the ProjectWikiRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the ProjectWikiRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the ProjectWikiRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** ID of the Project Wiki Repository. */
  projectWikiRepositoryId: Scalars['ID'];
  /** Timestamp after which the ProjectWikiRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the ProjectWikiRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the ProjectWikiRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the ProjectWikiRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the ProjectWikiRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for ProjectWikiRepositoryRegistry. */
export type ProjectWikiRepositoryRegistryConnection = {
  __typename?: 'ProjectWikiRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectWikiRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectWikiRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProjectWikiRepositoryRegistryEdge = {
  __typename?: 'ProjectWikiRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectWikiRepositoryRegistry>;
};

/** The alert condition for Prometheus */
export type PrometheusAlert = {
  __typename?: 'PrometheusAlert';
  /** Human-readable text of the alert condition. */
  humanizedText: Scalars['String'];
  /** ID of the alert condition. */
  id: Scalars['ID'];
};

/** Autogenerated input type of PrometheusIntegrationCreate */
export type PrometheusIntegrationCreateInput = {
  /** Whether the integration is receiving alerts. */
  active: Scalars['Boolean'];
  /** Endpoint at which Prometheus can be queried. */
  apiUrl?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Project to create the integration in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of PrometheusIntegrationCreate */
export type PrometheusIntegrationCreatePayload = {
  __typename?: 'PrometheusIntegrationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PrometheusIntegrationResetToken */
export type PrometheusIntegrationResetTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['IntegrationsPrometheusID'];
};

/** Autogenerated return type of PrometheusIntegrationResetToken */
export type PrometheusIntegrationResetTokenPayload = {
  __typename?: 'PrometheusIntegrationResetTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PrometheusIntegrationUpdate */
export type PrometheusIntegrationUpdateInput = {
  /** Whether the integration is receiving alerts. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Endpoint at which Prometheus can be queried. */
  apiUrl?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the integration to mutate. */
  id: Scalars['IntegrationsPrometheusID'];
};

/** Autogenerated return type of PrometheusIntegrationUpdate */
export type PrometheusIntegrationUpdatePayload = {
  __typename?: 'PrometheusIntegrationUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Newly created integration. */
  integration?: Maybe<AlertManagementPrometheusIntegration>;
};

/** Autogenerated input type of PromoteToEpic */
export type PromoteToEpicInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Group the promoted epic will belong to. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of PromoteToEpic */
export type PromoteToEpicPayload = {
  __typename?: 'PromoteToEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after issue promotion. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Protected Environments of the environment. */
export type ProtectedEnvironment = {
  __typename?: 'ProtectedEnvironment';
  /** Which group, user or role is allowed to approve deployments to the environment. */
  approvalRules?: Maybe<ProtectedEnvironmentApprovalRuleConnection>;
  /** Which group, user or role is allowed to execute deployments to the environment. */
  deployAccessLevels?: Maybe<ProtectedEnvironmentDeployAccessLevelConnection>;
  /** Group details. Present if it's group-level protected environment. */
  group?: Maybe<Group>;
  /**
   * Name of the environment if it's a project-level protected environment. Tier of
   * the environment if it's a group-level protected environment.
   */
  name?: Maybe<Scalars['String']>;
  /** Project details. Present if it's project-level protected environment. */
  project?: Maybe<Project>;
  /** Required approval count for Unified Approval Setting. */
  requiredApprovalCount?: Maybe<Scalars['Int']>;
};


/** Protected Environments of the environment. */
export type ProtectedEnvironmentApprovalRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Protected Environments of the environment. */
export type ProtectedEnvironmentDeployAccessLevelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Which group, user or role is allowed to approve deployments to the environment. */
export type ProtectedEnvironmentApprovalRule = {
  __typename?: 'ProtectedEnvironmentApprovalRule';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** Number of required approvals. */
  requiredApprovals?: Maybe<Scalars['Int']>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironmentApprovalRule. */
export type ProtectedEnvironmentApprovalRuleConnection = {
  __typename?: 'ProtectedEnvironmentApprovalRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentApprovalRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironmentApprovalRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProtectedEnvironmentApprovalRuleEdge = {
  __typename?: 'ProtectedEnvironmentApprovalRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironmentApprovalRule>;
};

/** Which group, user or role is allowed to approve deployments to the environment. */
export type ProtectedEnvironmentApprovalRuleForSummary = {
  __typename?: 'ProtectedEnvironmentApprovalRuleForSummary';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Current approvals of the deployment. */
  approvals?: Maybe<Array<DeploymentApproval>>;
  /** Approved count. */
  approvedCount?: Maybe<Scalars['Int']>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** Pending approval count. */
  pendingApprovalCount?: Maybe<Scalars['Int']>;
  /** Number of required approvals. */
  requiredApprovals?: Maybe<Scalars['Int']>;
  /** Status of the approval summary. */
  status?: Maybe<DeploymentApprovalSummaryStatus>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironment. */
export type ProtectedEnvironmentConnection = {
  __typename?: 'ProtectedEnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Which group, user or role is allowed to execute deployments to the environment. */
export type ProtectedEnvironmentDeployAccessLevel = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevel';
  /** Role details. Present if it's role specific access control. */
  accessLevel?: Maybe<AccessLevel>;
  /** Group details. Present if it's group specific access control. */
  group?: Maybe<Group>;
  /** User details. Present if it's user specific access control. */
  user?: Maybe<UserCore>;
};

/** The connection type for ProtectedEnvironmentDeployAccessLevel. */
export type ProtectedEnvironmentDeployAccessLevelConnection = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProtectedEnvironmentDeployAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProtectedEnvironmentDeployAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProtectedEnvironmentDeployAccessLevelEdge = {
  __typename?: 'ProtectedEnvironmentDeployAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironmentDeployAccessLevel>;
};

/** An edge in a connection. */
export type ProtectedEnvironmentEdge = {
  __typename?: 'ProtectedEnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProtectedEnvironment>;
};

/** Defines which user roles, users, or groups can push to a protected branch. */
export type PushAccessLevel = {
  __typename?: 'PushAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int'];
  /** Human readable representation for this access level. */
  accessLevelDescription: Scalars['String'];
  /** Group associated with this access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with this access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for PushAccessLevel. */
export type PushAccessLevelConnection = {
  __typename?: 'PushAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PushAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PushAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PushAccessLevelEdge = {
  __typename?: 'PushAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PushAccessLevel>;
};

/** Represents rules that commit pushes must follow. */
export type PushRules = {
  __typename?: 'PushRules';
  /** Indicates whether commits not signed through GPG will be rejected. */
  rejectUnsignedCommits: Scalars['Boolean'];
};

/** Pypi metadata */
export type PypiMetadata = {
  __typename?: 'PypiMetadata';
  /** ID of the metadatum. */
  id: Scalars['PackagesPypiMetadatumID'];
  /** Required Python version of the Pypi package. */
  requiredPython?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  /**
   * Find AI messages. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  aiMessages: AiCachedMessageTypeConnection;
  /** Definitions for all audit events available on the instance. */
  auditEventDefinitions: AuditEventDefinitionConnection;
  /** Find an issue board list. */
  boardList?: Maybe<BoardList>;
  /** CI related settings that apply to the entire instance. */
  ciApplicationSettings?: Maybe<CiApplicationSettings>;
  /**
   * A single CI/CD Catalog resource visible to an authorized user Introduced in
   * 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  ciCatalogResource?: Maybe<CiCatalogResource>;
  /**
   * All CI/CD Catalog resources under a common namespace, visible to an authorized
   * user Introduced in 15.11: This feature is an Experiment. It can be changed or
   * removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  ciCatalogResources?: Maybe<CiCatalogResourceConnection>;
  /**
   * Linted and processed contents of a CI config.
   * Should not be requested more than once per request.
   */
  ciConfig?: Maybe<CiConfig>;
  /** Compute usage data for a namespace. */
  ciMinutesUsage?: Maybe<CiMinutesNamespaceMonthlyUsageConnection>;
  /** Stage belonging to a CI pipeline. */
  ciPipelineStage?: Maybe<CiStage>;
  /** List of the instance's CI/CD variables. */
  ciVariables?: Maybe<CiInstanceVariableConnection>;
  /** Find a container repository. */
  containerRepository?: Maybe<ContainerRepositoryDetails>;
  /** Fields related to the current license. */
  currentLicense?: Maybe<CurrentLicense>;
  /** Get information about current user. */
  currentUser?: Maybe<UserCore>;
  /** Fields related to design management. */
  designManagement: DesignManagement;
  /** Get configured DevOps adoption namespaces. **BETA** This endpoint is subject to change without notice. */
  devopsAdoptionEnabledNamespaces?: Maybe<DevopsAdoptionEnabledNamespaceConnection>;
  /** Testing endpoint to validate the API with */
  echo: Scalars['String'];
  epicBoardList?: Maybe<EpicList>;
  /**
   * Explain This Vulnerability Prompt for a specified Vulnerability Introduced in
   * 16.2: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.
   */
  explainVulnerabilityPrompt?: Maybe<ExplainVulnerabilityPrompt>;
  /** Find a Geo node. */
  geoNode?: Maybe<GeoNode>;
  /** Whether Gitpod is enabled in application settings. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Find a group. */
  group?: Maybe<Group>;
  /** Find groups. */
  groups?: Maybe<GroupConnection>;
  /** Instance level external audit event destinations. */
  instanceExternalAuditEventDestinations?: Maybe<InstanceExternalAuditEventDestinationConnection>;
  /** Fields related to Instance Security Dashboard. */
  instanceSecurityDashboard?: Maybe<InstanceSecurityDashboard>;
  /** Find an issue. */
  issue?: Maybe<Issue>;
  /**
   * Find issues visible to the current user. At least one filter must be provided.
   * Introduced in 15.6: This feature is an Experiment. It can be changed or
   * removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.
   */
  issues?: Maybe<IssueConnection>;
  /** Find an iteration. */
  iteration?: Maybe<Iteration>;
  /** All jobs on this GitLab instance. */
  jobs?: Maybe<CiJobConnection>;
  /** Fields related to entries in the license history. */
  licenseHistoryEntries?: Maybe<LicenseHistoryEntryConnection>;
  /** Find a merge request. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Metadata about GitLab. */
  metadata?: Maybe<Metadata>;
  /** Find a milestone. */
  milestone?: Maybe<Milestone>;
  /** Find a namespace. */
  namespace?: Maybe<Namespace>;
  /**
   * Find a note. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  note?: Maybe<Note>;
  /**
   * Find a package. This field can only be resolved for one query in any single
   * request. Returns `null` if a package has no `default` status.
   */
  package?: Maybe<PackageDetailsType>;
  /** Find a project. */
  project?: Maybe<Project>;
  /** Find projects visible to the current user. */
  projects?: Maybe<ProjectConnection>;
  /** Information about the complexity of the GraphQL query. */
  queryComplexity?: Maybe<QueryComplexity>;
  /** Find a runner. */
  runner?: Maybe<CiRunner>;
  /**
   * Supported runner platforms. Deprecated in 15.9: No longer used, use
   * gitlab-runner documentation to learn about supported platforms.
   * @deprecated No longer used, use gitlab-runner documentation to learn about supported platforms. Deprecated in 15.9.
   */
  runnerPlatforms?: Maybe<RunnerPlatformConnection>;
  /**
   * Runner setup instructions. Deprecated in 15.9: No longer used, use
   * gitlab-runner documentation to learn about runner registration commands.
   * @deprecated No longer used, use gitlab-runner documentation to learn about runner registration commands. Deprecated in 15.9.
   */
  runnerSetup?: Maybe<RunnerSetup>;
  /** Find runners visible to the current user. */
  runners?: Maybe<CiRunnerConnection>;
  /** Find Snippets visible to the current user. */
  snippets?: Maybe<SnippetConnection>;
  /** Fields related to entries in future subscriptions. */
  subscriptionFutureEntries?: Maybe<SubscriptionFutureEntryConnection>;
  /**
   * Find a synthetic note Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  syntheticNote?: Maybe<Note>;
  /** Find timelogs visible to the current user. */
  timelogs?: Maybe<TimelogConnection>;
  /** Retrieve a single to-do item */
  todo?: Maybe<Todo>;
  /** Find project topics. */
  topics?: Maybe<TopicConnection>;
  /** Get statistics on the instance. */
  usageTrendsMeasurements?: Maybe<UsageTrendsMeasurementConnection>;
  /** Find a user. */
  user?: Maybe<UserCore>;
  /** Find users. */
  users?: Maybe<UserCoreConnection>;
  /** Vulnerabilities reported on projects on the current user's instance security dashboard. */
  vulnerabilities?: Maybe<VulnerabilityConnection>;
  /** The historical number of vulnerabilities per day for the projects on the current user's instance security dashboard. */
  vulnerabilitiesCountByDay?: Maybe<VulnerabilitiesCountByDayConnection>;
  /** Find a vulnerability. */
  vulnerability?: Maybe<Vulnerability>;
  /**
   * Find a work item. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.
   */
  workItem?: Maybe<WorkItem>;
  /**
   * Find a workspace. Introduced in 16.0: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  workspace?: Maybe<Workspace>;
  /**
   * Find workspaces owned by the current user by their IDs. Introduced in 16.0:
   * This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.
   */
  workspaces?: Maybe<WorkspaceConnection>;
};


export type QueryAiMessagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  requestIds?: InputMaybe<Array<Scalars['ID']>>;
  roles?: InputMaybe<Array<AiCachedMessageRole>>;
};


export type QueryAuditEventDefinitionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryBoardListArgs = {
  id: Scalars['ListID'];
  issueFilters?: InputMaybe<BoardIssueInput>;
};


export type QueryCiCatalogResourceArgs = {
  id: Scalars['CiCatalogResourceID'];
};


export type QueryCiCatalogResourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  projectPath?: InputMaybe<Scalars['ID']>;
  sort?: InputMaybe<CiCatalogResourceSort>;
};


export type QueryCiConfigArgs = {
  content: Scalars['String'];
  dryRun?: InputMaybe<Scalars['Boolean']>;
  projectPath: Scalars['ID'];
  sha?: InputMaybe<Scalars['String']>;
};


export type QueryCiMinutesUsageArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['Date']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  namespaceId?: InputMaybe<Scalars['NamespaceID']>;
};


export type QueryCiPipelineStageArgs = {
  id: Scalars['CiStageID'];
};


export type QueryCiVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<CiVariableSort>;
};


export type QueryContainerRepositoryArgs = {
  id: Scalars['ContainerRepositoryID'];
};


export type QueryDevopsAdoptionEnabledNamespacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  displayNamespaceId?: InputMaybe<Scalars['NamespaceID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryEchoArgs = {
  text: Scalars['String'];
};


export type QueryEpicBoardListArgs = {
  epicFilters?: InputMaybe<EpicFilters>;
  id: Scalars['BoardsEpicListID'];
};


export type QueryExplainVulnerabilityPromptArgs = {
  vulnerabilityId: Scalars['VulnerabilityID'];
};


export type QueryGeoNodeArgs = {
  name?: InputMaybe<Scalars['String']>;
};


export type QueryGroupArgs = {
  fullPath: Scalars['ID'];
};


export type QueryGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryInstanceExternalAuditEventDestinationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryIssueArgs = {
  id: Scalars['IssueID'];
};


export type QueryIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  assigneeId?: InputMaybe<Scalars['String']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  assigneeWildcardId?: InputMaybe<AssigneeWildcardId>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  closedAfter?: InputMaybe<Scalars['Time']>;
  closedBefore?: InputMaybe<Scalars['Time']>;
  confidential?: InputMaybe<Scalars['Boolean']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  crmContactId?: InputMaybe<Scalars['String']>;
  crmOrganizationId?: InputMaybe<Scalars['String']>;
  epicId?: InputMaybe<Scalars['String']>;
  epicWildcardId?: InputMaybe<EpicWildcardId>;
  first?: InputMaybe<Scalars['Int']>;
  healthStatusFilter?: InputMaybe<HealthStatusFilter>;
  iid?: InputMaybe<Scalars['String']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  in?: InputMaybe<Array<IssuableSearchableField>>;
  includeArchived?: InputMaybe<Scalars['Boolean']>;
  includeSubepics?: InputMaybe<Scalars['Boolean']>;
  iterationCadenceId?: InputMaybe<Array<Scalars['IterationsCadenceID']>>;
  iterationId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  iterationTitle?: InputMaybe<Scalars['String']>;
  iterationWildcardId?: InputMaybe<IterationWildcardId>;
  labelName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  last?: InputMaybe<Scalars['Int']>;
  milestoneTitle?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  milestoneWildcardId?: InputMaybe<MilestoneWildcardId>;
  myReactionEmoji?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NegatedIssueFilterInput>;
  or?: InputMaybe<UnionedIssueFilterInput>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<IssueSort>;
  state?: InputMaybe<IssuableState>;
  types?: InputMaybe<Array<IssueType>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
  weight?: InputMaybe<Scalars['String']>;
  weightWildcardId?: InputMaybe<WeightWildcardId>;
};


export type QueryIterationArgs = {
  id: Scalars['IterationID'];
};


export type QueryJobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  statuses?: InputMaybe<Array<CiJobStatus>>;
};


export type QueryLicenseHistoryEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMergeRequestArgs = {
  id: Scalars['MergeRequestID'];
};


export type QueryMilestoneArgs = {
  id: Scalars['MilestoneID'];
};


export type QueryNamespaceArgs = {
  fullPath: Scalars['ID'];
};


export type QueryNoteArgs = {
  id: Scalars['NoteID'];
};


export type QueryPackageArgs = {
  id: Scalars['PackagesPackageID'];
};


export type QueryProjectArgs = {
  fullPath: Scalars['ID'];
};


export type QueryProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  membership?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  searchNamespaces?: InputMaybe<Scalars['Boolean']>;
  sort?: InputMaybe<Scalars['String']>;
  topics?: InputMaybe<Array<Scalars['String']>>;
  withIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  withMergeRequestsEnabled?: InputMaybe<Scalars['Boolean']>;
};


export type QueryRunnerArgs = {
  id: Scalars['CiRunnerID'];
};


export type QueryRunnerPlatformsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryRunnerSetupArgs = {
  architecture: Scalars['String'];
  groupId?: InputMaybe<Scalars['GroupID']>;
  platform: Scalars['String'];
  projectId?: InputMaybe<Scalars['ProjectID']>;
};


export type QueryRunnersArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  paused?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<CiRunnerSort>;
  status?: InputMaybe<CiRunnerStatus>;
  tagList?: InputMaybe<Array<Scalars['String']>>;
  type?: InputMaybe<CiRunnerType>;
  upgradeStatus?: InputMaybe<CiRunnerUpgradeStatus>;
};


export type QuerySnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Scalars['UserID']>;
  before?: InputMaybe<Scalars['String']>;
  explore?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


export type QuerySubscriptionFutureEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QuerySyntheticNoteArgs = {
  noteableId: Scalars['NoteableID'];
  sha: Scalars['String'];
};


export type QueryTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


export type QueryTodoArgs = {
  id: Scalars['TodoID'];
};


export type QueryTopicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


export type QueryUsageTrendsMeasurementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  identifier: MeasurementIdentifier;
  last?: InputMaybe<Scalars['Int']>;
  recordedAfter?: InputMaybe<Scalars['Time']>;
  recordedBefore?: InputMaybe<Scalars['Time']>;
};


export type QueryUserArgs = {
  id?: InputMaybe<Scalars['UserID']>;
  username?: InputMaybe<Scalars['String']>;
};


export type QueryUsersArgs = {
  admins?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<Sort>;
  usernames?: InputMaybe<Array<Scalars['String']>>;
};


export type QueryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  clusterAgentId?: InputMaybe<Array<Scalars['ClustersAgentID']>>;
  clusterId?: InputMaybe<Array<Scalars['ClustersClusterID']>>;
  first?: InputMaybe<Scalars['Int']>;
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasResolution?: InputMaybe<Scalars['Boolean']>;
  image?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  reportType?: InputMaybe<Array<VulnerabilityReportType>>;
  scanner?: InputMaybe<Array<Scalars['String']>>;
  scannerId?: InputMaybe<Array<Scalars['VulnerabilitiesScannerID']>>;
  severity?: InputMaybe<Array<VulnerabilitySeverity>>;
  sort?: InputMaybe<VulnerabilitySort>;
  state?: InputMaybe<Array<VulnerabilityState>>;
};


export type QueryVulnerabilitiesCountByDayArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate: Scalars['ISO8601Date'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startDate: Scalars['ISO8601Date'];
};


export type QueryVulnerabilityArgs = {
  id: Scalars['VulnerabilityID'];
};


export type QueryWorkItemArgs = {
  id: Scalars['WorkItemID'];
};


export type QueryWorkspaceArgs = {
  id: Scalars['RemoteDevelopmentWorkspaceID'];
};


export type QueryWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

export type QueryComplexity = {
  __typename?: 'QueryComplexity';
  /** GraphQL query complexity limit. */
  limit?: Maybe<Scalars['Int']>;
  /** GraphQL query complexity score. */
  score?: Maybe<Scalars['Int']>;
};

/** Recent failure history of a test case. */
export type RecentFailures = {
  __typename?: 'RecentFailures';
  /** Name of the base branch of the project. */
  baseBranch?: Maybe<Scalars['String']>;
  /** Number of times the test case has failed in the past 14 days. */
  count?: Maybe<Scalars['Int']>;
};

/** Type of ref */
export type RefType =
  /** Ref type for branches. */
  | 'HEADS'
  /** Ref type for tags. */
  | 'TAGS';

export type Registrable = CiSecureFileRegistry | ContainerRepositoryRegistry | DependencyProxyBlobRegistry | DependencyProxyManifestRegistry | DesignManagementRepositoryRegistry | JobArtifactRegistry | LfsObjectRegistry | MergeRequestDiffRegistry | PackageFileRegistry | PagesDeploymentRegistry | PipelineArtifactRegistry | ProjectWikiRepositoryRegistry | SnippetRepositoryRegistry | TerraformStateVersionRegistry | UploadRegistry;

/** State of a Geo registry */
export type RegistryState =
  /** Registry that failed to sync. */
  | 'FAILED'
  /** Registry waiting to be synced. */
  | 'PENDING'
  /** Registry currently syncing. */
  | 'STARTED'
  /** Registry that is synced. */
  | 'SYNCED';

/** The position to which the object should be moved */
export type RelativePositionType =
  /** Object is moved after an adjacent object. */
  | 'AFTER'
  /** Object is moved before an adjacent object. */
  | 'BEFORE';

/** Represents a release */
export type Release = {
  __typename?: 'Release';
  /** Assets of the release. */
  assets?: Maybe<ReleaseAssets>;
  /** User that created the release. */
  author?: Maybe<UserCore>;
  /** Commit associated with the release. */
  commit?: Maybe<Commit>;
  /** Timestamp of when the release was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Description (also known as "release notes") of the release. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Evidence for the release. */
  evidences?: Maybe<ReleaseEvidenceConnection>;
  /** Indicates the release is an historical release. */
  historicalRelease?: Maybe<Scalars['Boolean']>;
  /** Global ID of the release. */
  id: Scalars['ReleaseID'];
  /** Links of the release. */
  links?: Maybe<ReleaseLinks>;
  /** Milestones associated to the release. */
  milestones?: Maybe<MilestoneConnection>;
  /** Name of the release. */
  name?: Maybe<Scalars['String']>;
  /** Timestamp of when the release was released. */
  releasedAt?: Maybe<Scalars['Time']>;
  /** Name of the tag associated with the release. */
  tagName?: Maybe<Scalars['String']>;
  /** Relative web path to the tag associated with the release. */
  tagPath?: Maybe<Scalars['String']>;
  /** Indicates the release is an upcoming release. */
  upcomingRelease?: Maybe<Scalars['Boolean']>;
};


/** Represents a release */
export type ReleaseEvidencesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a release */
export type ReleaseMilestonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an asset link associated with a release */
export type ReleaseAssetLink = {
  __typename?: 'ReleaseAssetLink';
  /** Relative path for the direct asset link. */
  directAssetPath?: Maybe<Scalars['String']>;
  /** Direct asset URL of the link. */
  directAssetUrl?: Maybe<Scalars['String']>;
  /** ID of the link. */
  id: Scalars['ID'];
  /** Type of the link: `other`, `runbook`, `image`, `package`; defaults to `other`. */
  linkType?: Maybe<ReleaseAssetLinkType>;
  /** Name of the link. */
  name?: Maybe<Scalars['String']>;
  /** URL of the link. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for ReleaseAssetLink. */
export type ReleaseAssetLinkConnection = {
  __typename?: 'ReleaseAssetLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseAssetLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseAssetLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ReleaseAssetLinkCreate */
export type ReleaseAssetLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Name of the asset link. */
  name: Scalars['String'];
  /** Full path of the project the asset link is associated with. */
  projectPath: Scalars['ID'];
  /** Name of the associated release's tag. */
  tagName: Scalars['String'];
  /** URL of the asset link. */
  url: Scalars['String'];
};

/** Autogenerated return type of ReleaseAssetLinkCreate */
export type ReleaseAssetLinkCreatePayload = {
  __typename?: 'ReleaseAssetLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Asset link after mutation. */
  link?: Maybe<ReleaseAssetLink>;
};

/** Autogenerated input type of ReleaseAssetLinkDelete */
export type ReleaseAssetLinkDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the release asset link to delete. */
  id: Scalars['ReleasesLinkID'];
};

/** Autogenerated return type of ReleaseAssetLinkDelete */
export type ReleaseAssetLinkDeletePayload = {
  __typename?: 'ReleaseAssetLinkDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted release asset link. */
  link?: Maybe<ReleaseAssetLink>;
};

/** An edge in a connection. */
export type ReleaseAssetLinkEdge = {
  __typename?: 'ReleaseAssetLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseAssetLink>;
};

/** Fields that are available when modifying a release asset link */
export type ReleaseAssetLinkInput = {
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']>;
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Name of the asset link. */
  name: Scalars['String'];
  /** URL of the asset link. */
  url: Scalars['String'];
};

/** Type of the link: `other`, `runbook`, `image`, `package` */
export type ReleaseAssetLinkType =
  /** Image link type */
  | 'IMAGE'
  /** Other link type */
  | 'OTHER'
  /** Package link type */
  | 'PACKAGE'
  /** Runbook link type */
  | 'RUNBOOK';

/** Autogenerated input type of ReleaseAssetLinkUpdate */
export type ReleaseAssetLinkUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Relative path for a direct asset link. */
  directAssetPath?: InputMaybe<Scalars['String']>;
  /** ID of the release asset link to update. */
  id: Scalars['ReleasesLinkID'];
  /** Type of the asset link. */
  linkType?: InputMaybe<ReleaseAssetLinkType>;
  /** Name of the asset link. */
  name?: InputMaybe<Scalars['String']>;
  /** URL of the asset link. */
  url?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ReleaseAssetLinkUpdate */
export type ReleaseAssetLinkUpdatePayload = {
  __typename?: 'ReleaseAssetLinkUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Asset link after mutation. */
  link?: Maybe<ReleaseAssetLink>;
};

/** A container for all assets associated with a release */
export type ReleaseAssets = {
  __typename?: 'ReleaseAssets';
  /** Number of assets of the release. */
  count?: Maybe<Scalars['Int']>;
  /** Asset links of the release. */
  links?: Maybe<ReleaseAssetLinkConnection>;
  /** Sources of the release. */
  sources?: Maybe<ReleaseSourceConnection>;
};


/** A container for all assets associated with a release */
export type ReleaseAssetsLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A container for all assets associated with a release */
export type ReleaseAssetsSourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Fields that are available when modifying release assets */
export type ReleaseAssetsInput = {
  /** List of asset links to associate to the release. */
  links?: InputMaybe<Array<ReleaseAssetLinkInput>>;
};

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: 'ReleaseConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of ReleaseCreate */
export type ReleaseCreateInput = {
  /** Assets associated to the release. */
  assets?: InputMaybe<ReleaseAssetsInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description (also known as "release notes") of the release. */
  description?: InputMaybe<Scalars['String']>;
  /** Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones. */
  milestones?: InputMaybe<Array<Scalars['String']>>;
  /** Name of the release. */
  name?: InputMaybe<Scalars['String']>;
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID'];
  /** Commit SHA or branch name to use if creating a new tag. */
  ref?: InputMaybe<Scalars['String']>;
  /**
   * Date and time for the release. Defaults to the current time. Expected in ISO
   * 8601 format (`2019-03-15T08:00:00Z`). Only provide this field if creating an
   * upcoming or historical release.
   */
  releasedAt?: InputMaybe<Scalars['Time']>;
  /** Message to use if creating a new annotated tag. */
  tagMessage?: InputMaybe<Scalars['String']>;
  /** Name of the tag to associate with the release. */
  tagName: Scalars['String'];
};

/** Autogenerated return type of ReleaseCreate */
export type ReleaseCreatePayload = {
  __typename?: 'ReleaseCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Release after mutation. */
  release?: Maybe<Release>;
};

/** Autogenerated input type of ReleaseDelete */
export type ReleaseDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID'];
  /** Name of the tag associated with the release to delete. */
  tagName: Scalars['String'];
};

/** Autogenerated return type of ReleaseDelete */
export type ReleaseDeletePayload = {
  __typename?: 'ReleaseDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted release. */
  release?: Maybe<Release>;
};

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: 'ReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Release>;
};

/** Evidence for a release */
export type ReleaseEvidence = {
  __typename?: 'ReleaseEvidence';
  /** Timestamp when the evidence was collected. */
  collectedAt?: Maybe<Scalars['Time']>;
  /** URL from where the evidence can be downloaded. */
  filepath?: Maybe<Scalars['String']>;
  /** ID of the evidence. */
  id: Scalars['ID'];
  /** SHA1 ID of the evidence hash. */
  sha?: Maybe<Scalars['String']>;
};

/** The connection type for ReleaseEvidence. */
export type ReleaseEvidenceConnection = {
  __typename?: 'ReleaseEvidenceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEvidenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseEvidence>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ReleaseEvidenceEdge = {
  __typename?: 'ReleaseEvidenceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseEvidence>;
};

export type ReleaseLinks = {
  __typename?: 'ReleaseLinks';
  /** HTTP URL of the issues page, filtered by this release and `state=closed`. */
  closedIssuesUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the merge request page , filtered by this release and `state=closed`. */
  closedMergeRequestsUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the release's edit page. */
  editUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the merge request page , filtered by this release and `state=merged`. */
  mergedMergeRequestsUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the issues page, filtered by this release and `state=open`. */
  openedIssuesUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the merge request page, filtered by this release and `state=open`. */
  openedMergeRequestsUrl?: Maybe<Scalars['String']>;
  /** HTTP URL of the release. */
  selfUrl?: Maybe<Scalars['String']>;
};

/** Values for sorting releases */
export type ReleaseSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Released at by ascending order. */
  | 'RELEASED_AT_ASC'
  /** Released at by descending order. */
  | 'RELEASED_AT_DESC';

/** Represents the source code attached to a release in a particular format */
export type ReleaseSource = {
  __typename?: 'ReleaseSource';
  /** Format of the source. */
  format?: Maybe<Scalars['String']>;
  /** Download URL of the source. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for ReleaseSource. */
export type ReleaseSourceConnection = {
  __typename?: 'ReleaseSourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseSourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseSource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ReleaseSourceEdge = {
  __typename?: 'ReleaseSourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseSource>;
};

/** Release tag ID wildcard values */
export type ReleaseTagWildcardId =
  /** Release tag is assigned. */
  | 'ANY'
  /** No release tag is assigned. */
  | 'NONE';

/** Autogenerated input type of ReleaseUpdate */
export type ReleaseUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description (release notes) of the release. */
  description?: InputMaybe<Scalars['String']>;
  /** Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones. */
  milestones?: InputMaybe<Array<Scalars['String']>>;
  /** Name of the release. */
  name?: InputMaybe<Scalars['String']>;
  /** Full path of the project the release is associated with. */
  projectPath: Scalars['ID'];
  /** Release date. */
  releasedAt?: InputMaybe<Scalars['Time']>;
  /** Name of the tag associated with the release. */
  tagName: Scalars['String'];
};

/** Autogenerated return type of ReleaseUpdate */
export type ReleaseUpdatePayload = {
  __typename?: 'ReleaseUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Release after mutation. */
  release?: Maybe<Release>;
};

/** Autogenerated input type of RemoveProjectFromSecurityDashboard */
export type RemoveProjectFromSecurityDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to remove from the Instance Security Dashboard. */
  id: Scalars['ProjectID'];
};

/** Autogenerated return type of RemoveProjectFromSecurityDashboard */
export type RemoveProjectFromSecurityDashboardPayload = {
  __typename?: 'RemoveProjectFromSecurityDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type ReplicationStateEnum =
  /** Replication process finished but failed. */
  | 'FAILED'
  /** Replication process has not started. */
  | 'PENDING'
  /** Replication process is in progress. */
  | 'STARTED'
  /** Replication process finished successfully. */
  | 'SYNCED';

/** Autogenerated input type of RepositionImageDiffNote */
export type RepositionImageDiffNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the DiffNote to update. */
  id: Scalars['DiffNoteID'];
  /** Position of this note on a diff. */
  position: UpdateDiffImagePositionInput;
};

/** Autogenerated return type of RepositionImageDiffNote */
export type RepositionImageDiffNotePayload = {
  __typename?: 'RepositionImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

export type Repository = {
  __typename?: 'Repository';
  /** Blobs contained within the repository */
  blobs?: Maybe<RepositoryBlobConnection>;
  /** Names of branches available in this repository that match the search pattern. */
  branchNames?: Maybe<Array<Scalars['String']>>;
  /** Path to CODEOWNERS file in a ref. */
  codeOwnersPath?: Maybe<Scalars['String']>;
  /** Shows a disk path of the repository. */
  diskPath?: Maybe<Scalars['String']>;
  /** Indicates repository has no visible content. */
  empty: Scalars['Boolean'];
  /** Indicates a corresponding Git repository exists on disk. */
  exists: Scalars['Boolean'];
  /** Paginated tree of the repository. */
  paginatedTree?: Maybe<TreeConnection>;
  /** Default branch of the repository. */
  rootRef?: Maybe<Scalars['String']>;
  /** Tree of the repository. */
  tree?: Maybe<Tree>;
};


export type RepositoryBlobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  paths: Array<Scalars['String']>;
  ref?: InputMaybe<Scalars['String']>;
  refType?: InputMaybe<RefType>;
};


export type RepositoryBranchNamesArgs = {
  limit: Scalars['Int'];
  offset: Scalars['Int'];
  searchPattern: Scalars['String'];
};


export type RepositoryCodeOwnersPathArgs = {
  ref?: InputMaybe<Scalars['String']>;
};


export type RepositoryPaginatedTreeArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  path?: InputMaybe<Scalars['String']>;
  recursive?: InputMaybe<Scalars['Boolean']>;
  ref?: InputMaybe<Scalars['String']>;
  refType?: InputMaybe<RefType>;
};


export type RepositoryTreeArgs = {
  path?: InputMaybe<Scalars['String']>;
  recursive?: InputMaybe<Scalars['Boolean']>;
  ref?: InputMaybe<Scalars['String']>;
  refType?: InputMaybe<RefType>;
};

export type RepositoryBlob = {
  __typename?: 'RepositoryBlob';
  /** Whether the current project is archived. */
  archived?: Maybe<Scalars['Boolean']>;
  /** Web path to blob blame page. */
  blamePath?: Maybe<Scalars['String']>;
  /** Whether the current user can push to the branch. */
  canCurrentUserPushToBranch?: Maybe<Scalars['Boolean']>;
  /** Whether the current user can modify the blob. */
  canModifyBlob?: Maybe<Scalars['Boolean']>;
  /** Web path for code navigation. */
  codeNavigationPath?: Maybe<Scalars['String']>;
  /** List of code owners for the blob. */
  codeOwners?: Maybe<Array<UserCore>>;
  /** Web path to edit the blob in the old-style editor. */
  editBlobPath?: Maybe<Scalars['String']>;
  /** Web path to blob on an environment. */
  environmentExternalUrlForRouteMap?: Maybe<Scalars['String']>;
  /** Environment on which the blob is available. */
  environmentFormattedExternalUrl?: Maybe<Scalars['String']>;
  /** External storage being used, if enabled (for instance, 'LFS'). */
  externalStorage?: Maybe<Scalars['String']>;
  /** Web path to download the raw blob via external storage, if enabled. */
  externalStorageUrl?: Maybe<Scalars['String']>;
  /** Expected format of the blob based on the extension. */
  fileType?: Maybe<Scalars['String']>;
  /** Web path to find file. */
  findFilePath?: Maybe<Scalars['String']>;
  /** Web path to edit this blob using a forked project. */
  forkAndEditPath?: Maybe<Scalars['String']>;
  /** Web path to view this blob using a forked project. */
  forkAndViewPath?: Maybe<Scalars['String']>;
  /** URL to the blob within Gitpod. */
  gitpodBlobUrl?: Maybe<Scalars['String']>;
  /** Web path to blob history page. */
  historyPath?: Maybe<Scalars['String']>;
  /** ID of the blob. */
  id: Scalars['ID'];
  /** Web path to edit this blob in the Web IDE. */
  ideEditPath?: Maybe<Scalars['String']>;
  /** Web path to edit this blob in the Web IDE using a forked project. */
  ideForkAndEditPath?: Maybe<Scalars['String']>;
  /** Blob language. */
  language?: Maybe<Scalars['String']>;
  /** LFS OID of the blob. */
  lfsOid?: Maybe<Scalars['String']>;
  /** Blob mode. */
  mode?: Maybe<Scalars['String']>;
  /** Blob name. */
  name?: Maybe<Scalars['String']>;
  /** OID of the blob. */
  oid: Scalars['String'];
  /** Path of the blob. */
  path: Scalars['String'];
  /** Web path to blob permalink. */
  permalinkPath?: Maybe<Scalars['String']>;
  /** Web path to edit .gitlab-ci.yml file. */
  pipelineEditorPath?: Maybe<Scalars['String']>;
  /** Blob plain highlighted data. */
  plainData?: Maybe<Scalars['String']>;
  /** Web path for the root of the blob. */
  projectBlobPathRoot?: Maybe<Scalars['String']>;
  /** Raw content of the blob. */
  rawBlob?: Maybe<Scalars['String']>;
  /** Web path to download the raw blob. */
  rawPath?: Maybe<Scalars['String']>;
  /** Size (in bytes) of the blob, or the blob target if stored externally. */
  rawSize?: Maybe<Scalars['BigInt']>;
  /** Raw content of the blob, if the blob is text data. */
  rawTextBlob?: Maybe<Scalars['String']>;
  /** Web path to replace the blob content. */
  replacePath?: Maybe<Scalars['String']>;
  /** Blob content rich viewer. */
  richViewer?: Maybe<BlobViewer>;
  /** Blob content simple viewer. */
  simpleViewer: BlobViewer;
  /** Size (in bytes) of the blob. */
  size?: Maybe<Scalars['BigInt']>;
  /** Whether the blob's content is stored externally (for instance, in LFS). */
  storedExternally?: Maybe<Scalars['Boolean']>;
  /** Web path of the blob. */
  webPath?: Maybe<Scalars['String']>;
};

/** The connection type for RepositoryBlob. */
export type RepositoryBlobConnection = {
  __typename?: 'RepositoryBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RepositoryBlobEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RepositoryBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RepositoryBlobEdge = {
  __typename?: 'RepositoryBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RepositoryBlob>;
};

export type RepositoryLanguage = {
  __typename?: 'RepositoryLanguage';
  /** Color to visualize the repository language. */
  color?: Maybe<Scalars['Color']>;
  /** Name of the repository language. */
  name: Scalars['String'];
  /** Percentage of the repository's languages. */
  share?: Maybe<Scalars['Float']>;
};

/** Represents a requirement */
export type Requirement = {
  __typename?: 'Requirement';
  /** Author of the requirement. */
  author: UserCore;
  /** Timestamp of when the requirement was created. */
  createdAt: Scalars['Time'];
  /** Description of the requirement. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description`. */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** ID of the requirement. */
  id: Scalars['ID'];
  /**
   * Internal ID of the requirement. Deprecated in 15.8: Use work_item_iid instead.
   * @deprecated Use work_item_iid instead. Deprecated in 15.8.
   */
  iid: Scalars['ID'];
  /** Indicates if latest test report was created by user. */
  lastTestReportManuallyCreated?: Maybe<Scalars['Boolean']>;
  /** Latest requirement test report state. */
  lastTestReportState?: Maybe<TestReportState>;
  /** Project to which the requirement belongs. */
  project: Project;
  /** State of the requirement. */
  state: RequirementState;
  /** Test reports of the requirement. */
  testReports?: Maybe<TestReportConnection>;
  /** Title of the requirement. */
  title?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `title`. */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the requirement was last updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: RequirementPermissions;
  /** Work item IID of the requirement, will replace current IID as identifier soon. */
  workItemIid: Scalars['ID'];
};


/** Represents a requirement */
export type RequirementTestReportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<Sort>;
};

/** The connection type for Requirement. */
export type RequirementConnection = {
  __typename?: 'RequirementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RequirementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Requirement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RequirementEdge = {
  __typename?: 'RequirementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Requirement>;
};

export type RequirementLegacyFilterInput = {
  /** List of legacy requirement IIDs of work items. or example `["1", "2"]`. */
  legacyIids: Array<Scalars['String']>;
};

/** Check permissions for the current user on a requirement */
export type RequirementPermissions = {
  __typename?: 'RequirementPermissions';
  /** Indicates the user can perform `admin_requirement` on this resource */
  adminRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `create_requirement` on this resource */
  createRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_requirement` on this resource */
  destroyRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `read_requirement` on this resource */
  readRequirement: Scalars['Boolean'];
  /** Indicates the user can perform `update_requirement` on this resource */
  updateRequirement: Scalars['Boolean'];
};

/** State of a requirement */
export type RequirementState =
  /** Archived requirement. */
  | 'ARCHIVED'
  /** Open requirement. */
  | 'OPENED';

/** Counts of requirements by their state */
export type RequirementStatesCount = {
  __typename?: 'RequirementStatesCount';
  /** Number of archived requirements. */
  archived?: Maybe<Scalars['Int']>;
  /** Number of opened requirements. */
  opened?: Maybe<Scalars['Int']>;
};

/** Status of a requirement based on last test report */
export type RequirementStatusFilter =
  /** Failed test report. */
  | 'FAILED'
  /** Requirements without any test report. */
  | 'MISSING'
  /** Passed test report. */
  | 'PASSED';

export type ResolvableInterface = {
  /** Indicates if the object can be resolved. */
  resolvable: Scalars['Boolean'];
  /** Indicates if the object is resolved. */
  resolved: Scalars['Boolean'];
  /** Timestamp of when the object was resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User who resolved the object. */
  resolvedBy?: Maybe<UserCore>;
};

export type RootStorageStatistics = {
  __typename?: 'RootStorageStatistics';
  /** CI artifacts size in bytes. */
  buildArtifactsSize: Scalars['Float'];
  /** Container Registry size in bytes. */
  containerRegistrySize: Scalars['Float'];
  /** Dependency Proxy sizes in bytes. */
  dependencyProxySize: Scalars['Float'];
  /** LFS objects size in bytes. */
  lfsObjectsSize: Scalars['Float'];
  /** Packages size in bytes. */
  packagesSize: Scalars['Float'];
  /** CI pipeline artifacts size in bytes. */
  pipelineArtifactsSize: Scalars['Float'];
  /** Indicates whether the deduplicated Container Registry size for the namespace is an estimated value or not. */
  registrySizeEstimated: Scalars['Boolean'];
  /** Git repository size in bytes. */
  repositorySize: Scalars['Float'];
  /** Snippets size in bytes. */
  snippetsSize: Scalars['Float'];
  /** Total storage in bytes. */
  storageSize: Scalars['Float'];
  /** Uploads size in bytes. */
  uploadsSize: Scalars['Float'];
  /** Wiki size in bytes. */
  wikiSize: Scalars['Float'];
};

export type RunnerArchitecture = {
  __typename?: 'RunnerArchitecture';
  /** Download location for the runner for the platform architecture. */
  downloadLocation: Scalars['String'];
  /** Name of the runner platform architecture. */
  name: Scalars['String'];
};

/** The connection type for RunnerArchitecture. */
export type RunnerArchitectureConnection = {
  __typename?: 'RunnerArchitectureConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RunnerArchitectureEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RunnerArchitecture>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RunnerArchitectureEdge = {
  __typename?: 'RunnerArchitectureEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RunnerArchitecture>;
};

/** Autogenerated input type of RunnerCreate */
export type RunnerCreateInput = {
  /** Access level of the runner. */
  accessLevel?: InputMaybe<CiRunnerAccessLevel>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the runner. */
  description?: InputMaybe<Scalars['String']>;
  /** Global ID of the group that the runner is created in (valid only for group runner). */
  groupId?: InputMaybe<Scalars['GroupID']>;
  /** Indicates the runner is locked. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: InputMaybe<Scalars['String']>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: InputMaybe<Scalars['Int']>;
  /** Indicates the runner is not allowed to receive jobs. */
  paused?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the project that the runner is created in (valid only for project runner). */
  projectId?: InputMaybe<Scalars['ProjectID']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged?: InputMaybe<Scalars['Boolean']>;
  /** Type of the runner to create. */
  runnerType: CiRunnerType;
  /** Tags associated with the runner. */
  tagList?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of RunnerCreate */
export type RunnerCreatePayload = {
  __typename?: 'RunnerCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Runner after mutation. */
  runner?: Maybe<CiRunner>;
};

/** Autogenerated input type of RunnerDelete */
export type RunnerDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the runner to delete. */
  id: Scalars['CiRunnerID'];
};

/** Autogenerated return type of RunnerDelete */
export type RunnerDeletePayload = {
  __typename?: 'RunnerDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type RunnerPermissions = {
  __typename?: 'RunnerPermissions';
  /** Indicates the user can perform `assign_runner` on this resource */
  assignRunner: Scalars['Boolean'];
  /** Indicates the user can perform `delete_runner` on this resource */
  deleteRunner: Scalars['Boolean'];
  /** Indicates the user can perform `read_runner` on this resource */
  readRunner: Scalars['Boolean'];
  /** Indicates the user can perform `update_runner` on this resource */
  updateRunner: Scalars['Boolean'];
};

export type RunnerPlatform = {
  __typename?: 'RunnerPlatform';
  /** Runner architectures supported for the platform. */
  architectures?: Maybe<RunnerArchitectureConnection>;
  /** Human readable name of the runner platform. */
  humanReadableName: Scalars['String'];
  /** Name slug of the runner platform. */
  name: Scalars['String'];
};


export type RunnerPlatformArchitecturesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for RunnerPlatform. */
export type RunnerPlatformConnection = {
  __typename?: 'RunnerPlatformConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RunnerPlatformEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RunnerPlatform>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RunnerPlatformEdge = {
  __typename?: 'RunnerPlatformEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RunnerPlatform>;
};

export type RunnerSetup = {
  __typename?: 'RunnerSetup';
  /** Instructions for installing the runner on the specified architecture. */
  installInstructions: Scalars['String'];
  /**
   * Instructions for registering the runner. The actual registration tokens are
   * not included in the commands. Instead, a placeholder `$REGISTRATION_TOKEN` is shown.
   */
  registerInstructions?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RunnerUpdate */
export type RunnerUpdateInput = {
  /** Access level of the runner. */
  accessLevel?: InputMaybe<CiRunnerAccessLevel>;
  /**
   * Indicates the runner is allowed to receive jobs. Deprecated in 14.8: This was renamed.
   * @deprecated This was renamed. Please use `paused`. Deprecated in 14.8.
   */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Projects associated with the runner. Available only for project runners. */
  associatedProjects?: InputMaybe<Array<Scalars['ProjectID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the runner. */
  description?: InputMaybe<Scalars['String']>;
  /** ID of the runner to update. */
  id: Scalars['CiRunnerID'];
  /** Indicates the runner is locked. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** Runner's maintenance notes. */
  maintenanceNote?: InputMaybe<Scalars['String']>;
  /** Maximum timeout (in seconds) for jobs processed by the runner. */
  maximumTimeout?: InputMaybe<Scalars['Int']>;
  /** Indicates the runner is not allowed to receive jobs. */
  paused?: InputMaybe<Scalars['Boolean']>;
  /** Private projects' "compute cost factor" associated with the runner (GitLab.com only). */
  privateProjectsMinutesCostFactor?: InputMaybe<Scalars['Float']>;
  /** Public projects' "compute cost factor" associated with the runner (GitLab.com only). */
  publicProjectsMinutesCostFactor?: InputMaybe<Scalars['Float']>;
  /** Indicates the runner is able to run untagged jobs. */
  runUntagged?: InputMaybe<Scalars['Boolean']>;
  /** Tags associated with the runner. */
  tagList?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of RunnerUpdate */
export type RunnerUpdatePayload = {
  __typename?: 'RunnerUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Runner after mutation. */
  runner?: Maybe<CiRunner>;
};

/** Autogenerated input type of RunnersRegistrationTokenReset */
export type RunnersRegistrationTokenResetInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project or group to reset the token for. Omit if resetting instance runner token. */
  id?: InputMaybe<Scalars['ID']>;
  /** Scope of the object to reset the token for. */
  type: CiRunnerType;
};

/** Autogenerated return type of RunnersRegistrationTokenReset */
export type RunnersRegistrationTokenResetPayload = {
  __typename?: 'RunnersRegistrationTokenResetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Runner token after mutation. */
  token?: Maybe<Scalars['String']>;
};

/** Represents a CI configuration of SAST */
export type SastCiConfiguration = {
  __typename?: 'SastCiConfiguration';
  /** List of analyzers entities attached to SAST configuration. */
  analyzers?: Maybe<SastCiConfigurationAnalyzersEntityConnection>;
  /** List of global entities related to SAST configuration. */
  global?: Maybe<SastCiConfigurationEntityConnection>;
  /** List of pipeline entities related to SAST configuration. */
  pipeline?: Maybe<SastCiConfigurationEntityConnection>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationAnalyzersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationGlobalArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a CI configuration of SAST */
export type SastCiConfigurationPipelineArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an analyzer entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntity = {
  __typename?: 'SastCiConfigurationAnalyzersEntity';
  /** Analyzer description that is displayed on the form. */
  description?: Maybe<Scalars['String']>;
  /** Indicates whether an analyzer is enabled. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Analyzer label used in the config UI. */
  label?: Maybe<Scalars['String']>;
  /** Name of the analyzer. */
  name?: Maybe<Scalars['String']>;
  /** List of supported variables. */
  variables?: Maybe<SastCiConfigurationEntityConnection>;
};


/** Represents an analyzer entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntityVariablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for SastCiConfigurationAnalyzersEntity. */
export type SastCiConfigurationAnalyzersEntityConnection = {
  __typename?: 'SastCiConfigurationAnalyzersEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationAnalyzersEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationAnalyzersEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationAnalyzersEntityEdge = {
  __typename?: 'SastCiConfigurationAnalyzersEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationAnalyzersEntity>;
};

/** Represents the analyzers entity in SAST CI configuration */
export type SastCiConfigurationAnalyzersEntityInput = {
  /** State of the analyzer. */
  enabled: Scalars['Boolean'];
  /** Name of analyzer. */
  name: Scalars['String'];
  /** List of variables for the analyzer. */
  variables?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
};

/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntity = {
  __typename?: 'SastCiConfigurationEntity';
  /** Default value that is used if value is empty. */
  defaultValue?: Maybe<Scalars['String']>;
  /** Entity description that is displayed on the form. */
  description?: Maybe<Scalars['String']>;
  /** CI keyword of entity. */
  field?: Maybe<Scalars['String']>;
  /** Label for entity used in the form. */
  label?: Maybe<Scalars['String']>;
  /** Different possible values of the field. */
  options?: Maybe<SastCiConfigurationOptionsEntityConnection>;
  /** Size of the UI component. */
  size?: Maybe<SastUiComponentSize>;
  /** Type of the field value. */
  type?: Maybe<Scalars['String']>;
  /** Current value of the entity. */
  value?: Maybe<Scalars['String']>;
};


/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntityOptionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for SastCiConfigurationEntity. */
export type SastCiConfigurationEntityConnection = {
  __typename?: 'SastCiConfigurationEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationEntityEdge = {
  __typename?: 'SastCiConfigurationEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationEntity>;
};

/** Represents an entity in SAST CI configuration */
export type SastCiConfigurationEntityInput = {
  /** Default value that is used if value is empty. */
  defaultValue: Scalars['String'];
  /** CI keyword of entity. */
  field: Scalars['String'];
  /** Current value of the entity. */
  value: Scalars['String'];
};

/** Represents a CI configuration of SAST */
export type SastCiConfigurationInput = {
  /** List of analyzers and related variables for the SAST configuration. */
  analyzers?: InputMaybe<Array<SastCiConfigurationAnalyzersEntityInput>>;
  /** List of global entities related to SAST configuration. */
  global?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
  /** List of pipeline entities related to SAST configuration. */
  pipeline?: InputMaybe<Array<SastCiConfigurationEntityInput>>;
};

/** Represents an entity for options in SAST CI configuration */
export type SastCiConfigurationOptionsEntity = {
  __typename?: 'SastCiConfigurationOptionsEntity';
  /** Label of option entity. */
  label?: Maybe<Scalars['String']>;
  /** Value of option entity. */
  value?: Maybe<Scalars['String']>;
};

/** The connection type for SastCiConfigurationOptionsEntity. */
export type SastCiConfigurationOptionsEntityConnection = {
  __typename?: 'SastCiConfigurationOptionsEntityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SastCiConfigurationOptionsEntityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SastCiConfigurationOptionsEntity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SastCiConfigurationOptionsEntityEdge = {
  __typename?: 'SastCiConfigurationOptionsEntityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SastCiConfigurationOptionsEntity>;
};

/** Size of UI component in SAST configuration page */
export type SastUiComponentSize =
  /** Size of UI component in SAST configuration page is large. */
  | 'LARGE'
  /** Size of UI component in SAST configuration page is medium. */
  | 'MEDIUM'
  /** Size of UI component in SAST configuration page is small. */
  | 'SMALL';

export type SavedReply = {
  __typename?: 'SavedReply';
  /** Content of the saved reply. */
  content: Scalars['String'];
  /** Global ID of the saved reply. */
  id: Scalars['UsersSavedReplyID'];
  /** Name of the saved reply. */
  name: Scalars['String'];
};

/** The connection type for SavedReply. */
export type SavedReplyConnection = {
  __typename?: 'SavedReplyConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of SavedReplyCreate */
export type SavedReplyCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Content of the saved reply. */
  content: Scalars['String'];
  /** Name of the saved reply. */
  name: Scalars['String'];
};

/** Autogenerated return type of SavedReplyCreate */
export type SavedReplyCreatePayload = {
  __typename?: 'SavedReplyCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** Autogenerated input type of SavedReplyDestroy */
export type SavedReplyDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the saved reply. */
  id: Scalars['UsersSavedReplyID'];
};

/** Autogenerated return type of SavedReplyDestroy */
export type SavedReplyDestroyPayload = {
  __typename?: 'SavedReplyDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** An edge in a connection. */
export type SavedReplyEdge = {
  __typename?: 'SavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SavedReply>;
};

/** Autogenerated input type of SavedReplyUpdate */
export type SavedReplyUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Content of the saved reply. */
  content: Scalars['String'];
  /** Global ID of the saved reply. */
  id: Scalars['UsersSavedReplyID'];
  /** Name of the saved reply. */
  name: Scalars['String'];
};

/** Autogenerated return type of SavedReplyUpdate */
export type SavedReplyUpdatePayload = {
  __typename?: 'SavedReplyUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Saved reply after mutation. */
  savedReply?: Maybe<SavedReply>;
};

/** Represents the security scan information */
export type Scan = {
  __typename?: 'Scan';
  /** List of errors. */
  errors: Array<Scalars['String']>;
  /** Name of the scan. */
  name: Scalars['String'];
  /** Indicates the status of the scan. */
  status: ScanStatus;
  /** List of warnings. */
  warnings: Array<Scalars['String']>;
};

/** The connection type for Scan. */
export type ScanConnection = {
  __typename?: 'ScanConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Scan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanEdge = {
  __typename?: 'ScanEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Scan>;
};

/** Represents the scan execution policy */
export type ScanExecutionPolicy = OrchestrationPolicy & {
  __typename?: 'ScanExecutionPolicy';
  /** Description of the policy. */
  description: Scalars['String'];
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Name of the policy. */
  name: Scalars['String'];
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};

/** Autogenerated input type of ScanExecutionPolicyCommit */
export type ScanExecutionPolicyCommitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project. */
  fullPath?: InputMaybe<Scalars['String']>;
  /** Name of the policy. If the name is null, the `name` field from `policy_yaml` is used. */
  name: Scalars['String'];
  /** Changes the operation mode. */
  operationMode: MutationOperationMode;
  /** YAML snippet of the policy. */
  policyYaml: Scalars['String'];
  /**
   * Full path of the project. Deprecated in 14.10: Use `fullPath`.
   * @deprecated Use `fullPath`. Deprecated in 14.10.
   */
  projectPath?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of ScanExecutionPolicyCommit */
export type ScanExecutionPolicyCommitPayload = {
  __typename?: 'ScanExecutionPolicyCommitPayload';
  /** Name of the branch to which the policy changes are committed. */
  branch?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Validation errors encountered during execution of the mutation. */
  validationErrors?: Maybe<Array<SecurityPolicyValidationError>>;
};

/** The connection type for ScanExecutionPolicy. */
export type ScanExecutionPolicyConnection = {
  __typename?: 'ScanExecutionPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanExecutionPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScanExecutionPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanExecutionPolicyEdge = {
  __typename?: 'ScanExecutionPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ScanExecutionPolicy>;
};

/** Represents the scan result policy */
export type ScanResultPolicy = OrchestrationPolicy & {
  __typename?: 'ScanResultPolicy';
  /** Description of the policy. */
  description: Scalars['String'];
  /** Indicates whether this policy is enabled. */
  enabled: Scalars['Boolean'];
  /** Approvers of the group type. */
  groupApprovers?: Maybe<Array<Group>>;
  /** Name of the policy. */
  name: Scalars['String'];
  /** Approvers of the role type. Users belonging to these role(s) alone will be approvers. */
  roleApprovers?: Maybe<Array<MemberAccessLevelName>>;
  /** Source of the policy. Its fields depend on the source type. */
  source: SecurityPolicySource;
  /** Timestamp of when the policy YAML was last updated. */
  updatedAt: Scalars['Time'];
  /** Approvers of the user type. */
  userApprovers?: Maybe<Array<UserCore>>;
  /** YAML definition of the policy. */
  yaml: Scalars['String'];
};

/** The connection type for ScanResultPolicy. */
export type ScanResultPolicyConnection = {
  __typename?: 'ScanResultPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScanResultPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScanResultPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScanResultPolicyEdge = {
  __typename?: 'ScanResultPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ScanResultPolicy>;
};

/** The status of the security scan */
export type ScanStatus =
  /** The scan has been created. */
  | 'CREATED'
  /** The related CI build failed. */
  | 'JOB_FAILED'
  /** Report couldn't be prepared. */
  | 'PREPARATION_FAILED'
  /** Preparing the report for the scan. */
  | 'PREPARING'
  /** Report for the scan has been removed from the database. */
  | 'PURGED'
  /** The report artifact provided by the CI build couldn't be parsed. */
  | 'REPORT_ERROR'
  /** The report has been successfully prepared. */
  | 'SUCCEEDED';

/** Represents a resource scanned by a security scan */
export type ScannedResource = {
  __typename?: 'ScannedResource';
  /** HTTP request method used to access the URL. */
  requestMethod?: Maybe<Scalars['String']>;
  /** URL scanned by the scanner. */
  url?: Maybe<Scalars['String']>;
};

/** The connection type for ScannedResource. */
export type ScannedResourceConnection = {
  __typename?: 'ScannedResourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ScannedResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ScannedResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ScannedResourceEdge = {
  __typename?: 'ScannedResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ScannedResource>;
};

/** Autogenerated input type of SecurityFindingCreateIssue */
export type SecurityFindingCreateIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the project to attach the issue to. */
  project: Scalars['ProjectID'];
  /** UUID of the security finding to be used to create an issue. */
  uuid: Scalars['String'];
};

/** Autogenerated return type of SecurityFindingCreateIssue */
export type SecurityFindingCreateIssuePayload = {
  __typename?: 'SecurityFindingCreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of SecurityFindingCreateMergeRequest */
export type SecurityFindingCreateMergeRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** UUID of the security finding to be used to create a merge request. */
  uuid: Scalars['String'];
};

/** Autogenerated return type of SecurityFindingCreateMergeRequest */
export type SecurityFindingCreateMergeRequestPayload = {
  __typename?: 'SecurityFindingCreateMergeRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Merge Request created after mutation. */
  mergeRequest?: Maybe<MergeRequest>;
};

/** Autogenerated input type of SecurityFindingDismiss */
export type SecurityFindingDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Comment why finding should be dismissed. */
  comment?: InputMaybe<Scalars['String']>;
  /** Reason why finding should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
  /** UUID of the finding to be dismissed. */
  uuid: Scalars['String'];
};

/** Autogenerated return type of SecurityFindingDismiss */
export type SecurityFindingDismissPayload = {
  __typename?: 'SecurityFindingDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Dismissed finding. */
  securityFinding?: Maybe<PipelineSecurityReportFinding>;
  /** UUID of dismissed finding. */
  uuid?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SecurityFindingRevertToDetected */
export type SecurityFindingRevertToDetectedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** UUID of the finding to be dismissed. */
  uuid: Scalars['String'];
};

/** Autogenerated return type of SecurityFindingRevertToDetected */
export type SecurityFindingRevertToDetectedPayload = {
  __typename?: 'SecurityFindingRevertToDetectedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Finding reverted to detected. */
  securityFinding?: Maybe<PipelineSecurityReportFinding>;
};

/** Autogenerated input type of SecurityPolicyProjectAssign */
export type SecurityPolicyProjectAssignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']>;
  /**
   * Full path of the project. Deprecated in 14.10: Use `fullPath`.
   * @deprecated Use `fullPath`. Deprecated in 14.10.
   */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** ID of the security policy project. */
  securityPolicyProjectId: Scalars['ProjectID'];
};

/** Autogenerated return type of SecurityPolicyProjectAssign */
export type SecurityPolicyProjectAssignPayload = {
  __typename?: 'SecurityPolicyProjectAssignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of SecurityPolicyProjectCreate */
export type SecurityPolicyProjectCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']>;
  /**
   * Full path of the project. Deprecated in 14.10: Use `fullPath`.
   * @deprecated Use `fullPath`. Deprecated in 14.10.
   */
  projectPath?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of SecurityPolicyProjectCreate */
export type SecurityPolicyProjectCreatePayload = {
  __typename?: 'SecurityPolicyProjectCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Security Policy Project that was created. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of SecurityPolicyProjectUnassign */
export type SecurityPolicyProjectUnassignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Full path of the project or group. */
  fullPath?: InputMaybe<Scalars['String']>;
  /**
   * Full path of the project. Deprecated in 14.10: Use `fullPath`.
   * @deprecated Use `fullPath`. Deprecated in 14.10.
   */
  projectPath?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of SecurityPolicyProjectUnassign */
export type SecurityPolicyProjectUnassignPayload = {
  __typename?: 'SecurityPolicyProjectUnassignPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type SecurityPolicyRelationType =
  /** Policies defined for the project/group only. */
  | 'DIRECT'
  /** Policies defined for the project/group and ancestor groups. */
  | 'INHERITED'
  /** Policies defined for the project/group's ancestor groups only. */
  | 'INHERITED_ONLY';

/** Represents a policy source. Its fields depend on the source type. */
export type SecurityPolicySource = GroupSecurityPolicySource | ProjectSecurityPolicySource;

/** Security policy validation error */
export type SecurityPolicyValidationError = {
  __typename?: 'SecurityPolicyValidationError';
  /** Error field. */
  field: Scalars['String'];
  /** Error level. */
  level: Scalars['String'];
  /** Error message. */
  message: Scalars['String'];
  /** Error title. */
  title?: Maybe<Scalars['String']>;
};

/** Represents summary of a security report */
export type SecurityReportSummary = {
  __typename?: 'SecurityReportSummary';
  /** Aggregated counts for the `api_fuzzing` scan */
  apiFuzzing?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `cluster_image_scanning` scan */
  clusterImageScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `container_scanning` scan */
  containerScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `coverage_fuzzing` scan */
  coverageFuzzing?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `dast` scan */
  dast?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `dependency_scanning` scan */
  dependencyScanning?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `generic` scan */
  generic?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `sast` scan */
  sast?: Maybe<SecurityReportSummarySection>;
  /** Aggregated counts for the `secret_detection` scan */
  secretDetection?: Maybe<SecurityReportSummarySection>;
};

/** Represents a section of a summary of a security report */
export type SecurityReportSummarySection = {
  __typename?: 'SecurityReportSummarySection';
  /** List of the first 20 scanned resources. */
  scannedResources?: Maybe<ScannedResourceConnection>;
  /** Total number of scanned resources. */
  scannedResourcesCount?: Maybe<Scalars['Int']>;
  /** Path to download all the scanned resources in CSV format. */
  scannedResourcesCsvPath?: Maybe<Scalars['String']>;
  /** List of security scans ran for the type. */
  scans: ScanConnection;
  /** Total number of vulnerabilities. */
  vulnerabilitiesCount?: Maybe<Scalars['Int']>;
};


/** Represents a section of a summary of a security report */
export type SecurityReportSummarySectionScannedResourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a section of a summary of a security report */
export type SecurityReportSummarySectionScansArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type SecurityReportTypeEnum =
  /** API FUZZING scan report */
  | 'API_FUZZING'
  /** BREACH AND ATTACK SIMULATION scan report */
  | 'BREACH_AND_ATTACK_SIMULATION'
  /** CLUSTER IMAGE SCANNING scan report */
  | 'CLUSTER_IMAGE_SCANNING'
  /** CONTAINER SCANNING scan report */
  | 'CONTAINER_SCANNING'
  /** COVERAGE FUZZING scan report */
  | 'COVERAGE_FUZZING'
  /** DAST scan report */
  | 'DAST'
  /** DEPENDENCY SCANNING scan report */
  | 'DEPENDENCY_SCANNING'
  /** SAST scan report */
  | 'SAST'
  /** SAST IAC scan report */
  | 'SAST_IAC'
  /** SECRET DETECTION scan report */
  | 'SECRET_DETECTION';

/** The type of the security scanner */
export type SecurityScannerType =
  /** API Fuzzing scanner */
  | 'API_FUZZING'
  /** Breach And Attack Simulation scanner */
  | 'BREACH_AND_ATTACK_SIMULATION'
  /** Cluster Image Scanning scanner */
  | 'CLUSTER_IMAGE_SCANNING'
  /** Container Scanning scanner */
  | 'CONTAINER_SCANNING'
  /** Coverage Fuzzing scanner */
  | 'COVERAGE_FUZZING'
  /** DAST scanner */
  | 'DAST'
  /** Dependency Scanning scanner */
  | 'DEPENDENCY_SCANNING'
  /** SAST scanner */
  | 'SAST'
  /** Sast Iac scanner */
  | 'SAST_IAC'
  /** Secret Detection scanner */
  | 'SECRET_DETECTION';

/** Represents a list of security scanners */
export type SecurityScanners = {
  __typename?: 'SecurityScanners';
  /** List of analyzers which are available for the project. */
  available?: Maybe<Array<SecurityScannerType>>;
  /** List of analyzers which are enabled for the project. */
  enabled?: Maybe<Array<SecurityScannerType>>;
  /** List of analyzers which ran successfully in the latest pipeline. */
  pipelineRun?: Maybe<Array<SecurityScannerType>>;
};

/** Autogenerated input type of SecurityTrainingUpdate */
export type SecurityTrainingUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Sets the training provider as enabled for the project. */
  isEnabled: Scalars['Boolean'];
  /** Sets the training provider as primary for the project. */
  isPrimary?: InputMaybe<Scalars['Boolean']>;
  /** Full path of the project. */
  projectPath: Scalars['ID'];
  /** ID of the provider. */
  providerId: Scalars['SecurityTrainingProviderID'];
};

/** Autogenerated return type of SecurityTrainingUpdate */
export type SecurityTrainingUpdatePayload = {
  __typename?: 'SecurityTrainingUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Represents the training entity subject to mutation. */
  training?: Maybe<ProjectSecurityTraining>;
};

/** Represents a URL related to a security training */
export type SecurityTrainingUrl = {
  __typename?: 'SecurityTrainingUrl';
  /** Name of the vulnerability identifier. */
  identifier?: Maybe<Scalars['String']>;
  /** Name of the training provider. */
  name?: Maybe<Scalars['String']>;
  /** Status of the request to training provider. */
  status?: Maybe<TrainingUrlRequestStatus>;
  /** URL of the link for security training content. */
  url?: Maybe<Scalars['String']>;
};

/** A Sentry error */
export type SentryDetailedError = {
  __typename?: 'SentryDetailedError';
  /** Count of occurrences. */
  count: Scalars['Int'];
  /** Culprit of the error. */
  culprit: Scalars['String'];
  /** External Base URL of the Sentry Instance. */
  externalBaseUrl: Scalars['String'];
  /** External URL of the error. */
  externalUrl: Scalars['String'];
  /** Commit the error was first seen. */
  firstReleaseLastCommit?: Maybe<Scalars['String']>;
  /** Release short version the error was first seen. */
  firstReleaseShortVersion?: Maybe<Scalars['String']>;
  /** Release version the error was first seen. */
  firstReleaseVersion?: Maybe<Scalars['String']>;
  /** Timestamp when the error was first seen. */
  firstSeen: Scalars['Time'];
  /** Last 24hr stats of the error. */
  frequency: Array<SentryErrorFrequency>;
  /** GitLab commit SHA attributed to the Error based on the release version. */
  gitlabCommit?: Maybe<Scalars['String']>;
  /** Path to the GitLab page for the GitLab commit attributed to the error. */
  gitlabCommitPath?: Maybe<Scalars['String']>;
  /** URL of GitLab Issue. */
  gitlabIssuePath?: Maybe<Scalars['String']>;
  /** ID (global ID) of the error. */
  id: Scalars['ID'];
  /** Error tracking backend. */
  integrated?: Maybe<Scalars['Boolean']>;
  /** Commit the error was last seen. */
  lastReleaseLastCommit?: Maybe<Scalars['String']>;
  /** Release short version the error was last seen. */
  lastReleaseShortVersion?: Maybe<Scalars['String']>;
  /** Release version the error was last seen. */
  lastReleaseVersion?: Maybe<Scalars['String']>;
  /** Timestamp when the error was last seen. */
  lastSeen: Scalars['Time'];
  /** Sentry metadata message of the error. */
  message?: Maybe<Scalars['String']>;
  /** ID (Sentry ID) of the error. */
  sentryId: Scalars['String'];
  /** ID of the project (Sentry project). */
  sentryProjectId: Scalars['ID'];
  /** Name of the project affected by the error. */
  sentryProjectName: Scalars['String'];
  /** Slug of the project affected by the error. */
  sentryProjectSlug: Scalars['String'];
  /** Short ID (Sentry ID) of the error. */
  shortId: Scalars['String'];
  /** Status of the error. */
  status: SentryErrorStatus;
  /** Tags associated with the Sentry Error. */
  tags: SentryErrorTags;
  /** Title of the error. */
  title: Scalars['String'];
  /** Type of the error. */
  type: Scalars['String'];
  /** Count of users affected by the error. */
  userCount: Scalars['Int'];
};

/** A Sentry error. A simplified version of SentryDetailedError */
export type SentryError = {
  __typename?: 'SentryError';
  /** Count of occurrences. */
  count: Scalars['Int'];
  /** Culprit of the error. */
  culprit: Scalars['String'];
  /** External URL of the error. */
  externalUrl: Scalars['String'];
  /** Timestamp when the error was first seen. */
  firstSeen: Scalars['Time'];
  /** Last 24hr stats of the error. */
  frequency: Array<SentryErrorFrequency>;
  /** ID (global ID) of the error. */
  id: Scalars['ID'];
  /** Timestamp when the error was last seen. */
  lastSeen: Scalars['Time'];
  /** Sentry metadata message of the error. */
  message?: Maybe<Scalars['String']>;
  /** ID (Sentry ID) of the error. */
  sentryId: Scalars['String'];
  /** ID of the project (Sentry project). */
  sentryProjectId: Scalars['ID'];
  /** Name of the project affected by the error. */
  sentryProjectName: Scalars['String'];
  /** Slug of the project affected by the error. */
  sentryProjectSlug: Scalars['String'];
  /** Short ID (Sentry ID) of the error. */
  shortId: Scalars['String'];
  /** Status of the error. */
  status: SentryErrorStatus;
  /** Title of the error. */
  title: Scalars['String'];
  /** Type of the error. */
  type: Scalars['String'];
  /** Count of users affected by the error. */
  userCount: Scalars['Int'];
};

/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollection = {
  __typename?: 'SentryErrorCollection';
  /** Detailed version of a Sentry error on the project. */
  detailedError?: Maybe<SentryDetailedError>;
  /** Stack Trace of Sentry Error. */
  errorStackTrace?: Maybe<SentryErrorStackTrace>;
  /** Collection of Sentry Errors. */
  errors?: Maybe<SentryErrorConnection>;
  /** External URL for Sentry. */
  externalUrl?: Maybe<Scalars['String']>;
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionDetailedErrorArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID'];
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionErrorStackTraceArgs = {
  id: Scalars['GitlabErrorTrackingDetailedErrorID'];
};


/** An object containing a collection of Sentry errors, and a detailed error */
export type SentryErrorCollectionErrorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  searchTerm?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<Scalars['String']>;
};

/** The connection type for SentryError. */
export type SentryErrorConnection = {
  __typename?: 'SentryErrorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SentryErrorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SentryError>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SentryErrorEdge = {
  __typename?: 'SentryErrorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SentryError>;
};

export type SentryErrorFrequency = {
  __typename?: 'SentryErrorFrequency';
  /** Count of errors received since the previously recorded time. */
  count: Scalars['Int'];
  /** Time the error frequency stats were recorded. */
  time: Scalars['Time'];
};

/** An object containing a stack trace entry for a Sentry error */
export type SentryErrorStackTrace = {
  __typename?: 'SentryErrorStackTrace';
  /** Time the stack trace was received by Sentry. */
  dateReceived: Scalars['String'];
  /** ID of the Sentry error. */
  issueId: Scalars['String'];
  /** Stack trace entries for the Sentry error. */
  stackTraceEntries: Array<SentryErrorStackTraceEntry>;
};

/** An object context for a Sentry error stack trace */
export type SentryErrorStackTraceContext = {
  __typename?: 'SentryErrorStackTraceContext';
  /** Code number of the context. */
  code: Scalars['String'];
  /** Line number of the context. */
  line: Scalars['Int'];
};

/** An object containing a stack trace entry for a Sentry error */
export type SentryErrorStackTraceEntry = {
  __typename?: 'SentryErrorStackTraceEntry';
  /** Function in which the Sentry error occurred. */
  col?: Maybe<Scalars['String']>;
  /** File in which the Sentry error occurred. */
  fileName?: Maybe<Scalars['String']>;
  /** Function in which the Sentry error occurred. */
  function?: Maybe<Scalars['String']>;
  /** Function in which the Sentry error occurred. */
  line?: Maybe<Scalars['String']>;
  /** Context of the Sentry error. */
  traceContext?: Maybe<Array<SentryErrorStackTraceContext>>;
};

/** State of a Sentry error */
export type SentryErrorStatus =
  /** Error has been ignored. */
  | 'IGNORED'
  /** Error has been resolved. */
  | 'RESOLVED'
  /** Error has been ignored until next release. */
  | 'RESOLVED_IN_NEXT_RELEASE'
  /** Error is unresolved. */
  | 'UNRESOLVED';

/** State of a Sentry error */
export type SentryErrorTags = {
  __typename?: 'SentryErrorTags';
  /** Severity level of the Sentry Error. */
  level?: Maybe<Scalars['String']>;
  /** Logger of the Sentry Error. */
  logger?: Maybe<Scalars['String']>;
};

export type Service = {
  /** Indicates if the service is active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Type of the service. */
  serviceType?: Maybe<ServiceType>;
  /** Class name of the service. */
  type?: Maybe<Scalars['String']>;
};

/** The connection type for Service. */
export type ServiceConnection = {
  __typename?: 'ServiceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ServiceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Service>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ServiceEdge = {
  __typename?: 'ServiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Service>;
};

export type ServiceType =
  /** AppleAppStoreService type */
  | 'APPLE_APP_STORE_SERVICE'
  /** AsanaService type */
  | 'ASANA_SERVICE'
  /** AssemblaService type */
  | 'ASSEMBLA_SERVICE'
  /** BambooService type */
  | 'BAMBOO_SERVICE'
  /** BugzillaService type */
  | 'BUGZILLA_SERVICE'
  /** BuildkiteService type */
  | 'BUILDKITE_SERVICE'
  /** CampfireService type */
  | 'CAMPFIRE_SERVICE'
  /** ClickupService type */
  | 'CLICKUP_SERVICE'
  /** ConfluenceService type */
  | 'CONFLUENCE_SERVICE'
  /** CustomIssueTrackerService type */
  | 'CUSTOM_ISSUE_TRACKER_SERVICE'
  /** DatadogService type */
  | 'DATADOG_SERVICE'
  /** DiscordService type */
  | 'DISCORD_SERVICE'
  /** DroneCiService type */
  | 'DRONE_CI_SERVICE'
  /** EmailsOnPushService type */
  | 'EMAILS_ON_PUSH_SERVICE'
  /** EwmService type */
  | 'EWM_SERVICE'
  /** ExternalWikiService type */
  | 'EXTERNAL_WIKI_SERVICE'
  /** GithubService type */
  | 'GITHUB_SERVICE'
  /** GitlabSlackApplicationService type */
  | 'GITLAB_SLACK_APPLICATION_SERVICE'
  /** GooglePlayService type */
  | 'GOOGLE_PLAY_SERVICE'
  /** HangoutsChatService type */
  | 'HANGOUTS_CHAT_SERVICE'
  /** HarborService type */
  | 'HARBOR_SERVICE'
  /** IrkerService type */
  | 'IRKER_SERVICE'
  /** JenkinsService type */
  | 'JENKINS_SERVICE'
  /** JiraService type */
  | 'JIRA_SERVICE'
  /** MattermostService type */
  | 'MATTERMOST_SERVICE'
  /** MattermostSlashCommandsService type */
  | 'MATTERMOST_SLASH_COMMANDS_SERVICE'
  /** MicrosoftTeamsService type */
  | 'MICROSOFT_TEAMS_SERVICE'
  /** PackagistService type */
  | 'PACKAGIST_SERVICE'
  /** PipelinesEmailService type */
  | 'PIPELINES_EMAIL_SERVICE'
  /** PivotaltrackerService type */
  | 'PIVOTALTRACKER_SERVICE'
  /** PrometheusService type */
  | 'PROMETHEUS_SERVICE'
  /** PumbleService type */
  | 'PUMBLE_SERVICE'
  /** PushoverService type */
  | 'PUSHOVER_SERVICE'
  /** RedmineService type */
  | 'REDMINE_SERVICE'
  /** ShimoService type */
  | 'SHIMO_SERVICE'
  /** SlackService type */
  | 'SLACK_SERVICE'
  /** SlackSlashCommandsService type */
  | 'SLACK_SLASH_COMMANDS_SERVICE'
  /** SquashTmService type */
  | 'SQUASH_TM_SERVICE'
  /** TeamcityService type */
  | 'TEAMCITY_SERVICE'
  /** TelegramService type */
  | 'TELEGRAM_SERVICE'
  /** UnifyCircuitService type */
  | 'UNIFY_CIRCUIT_SERVICE'
  /** WebexTeamsService type */
  | 'WEBEX_TEAMS_SERVICE'
  /** YoutrackService type */
  | 'YOUTRACK_SERVICE'
  /** ZentaoService type */
  | 'ZENTAO_SERVICE';

/** How to format SHA strings. */
export type ShaFormat =
  /** Unabbreviated format. */
  | 'LONG'
  /** Abbreviated format. Short SHAs are typically eight characters long. */
  | 'SHORT';

export type SharedRunnersSetting =
  /** Sharing of runners is disabled and overridable. */
  | 'DISABLED_AND_OVERRIDABLE'
  /** Sharing of runners is disabled and unoverridable. */
  | 'DISABLED_AND_UNOVERRIDABLE'
  /** Sharing of runners is disabled and overridable. Deprecated in 17.0: This was renamed. */
  | 'DISABLED_WITH_OVERRIDE'
  /** Sharing of runners is enabled. */
  | 'ENABLED';

/** Represents a snippet entry */
export type Snippet = NoteableInterface & {
  __typename?: 'Snippet';
  /** Owner of the snippet. */
  author?: Maybe<UserCore>;
  /** Snippet blobs. */
  blobs?: Maybe<SnippetBlobConnection>;
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Timestamp this snippet was created. */
  createdAt: Scalars['Time'];
  /** Description of the snippet. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** File Name of the snippet. */
  fileName?: Maybe<Scalars['String']>;
  /** HTTP URL to the snippet repository. */
  httpUrlToRepo?: Maybe<Scalars['String']>;
  /** ID of the snippet. */
  id: Scalars['SnippetID'];
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Project the snippet is associated with. */
  project?: Maybe<Project>;
  /** Raw URL of the snippet. */
  rawUrl: Scalars['String'];
  /** SSH URL to the snippet repository. */
  sshUrlToRepo?: Maybe<Scalars['String']>;
  /** Title of the snippet. */
  title: Scalars['String'];
  /** Timestamp this snippet was updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: SnippetPermissions;
  /** Visibility Level of the snippet. */
  visibilityLevel: VisibilityLevelsEnum;
  /** Web URL of the snippet. */
  webUrl: Scalars['String'];
};


/** Represents a snippet entry */
export type SnippetBlobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  paths?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a snippet entry */
export type SnippetCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a snippet entry */
export type SnippetDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a snippet entry */
export type SnippetNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents the snippet blob */
export type SnippetBlob = {
  __typename?: 'SnippetBlob';
  /** Shows whether the blob is binary. */
  binary: Scalars['Boolean'];
  /** Blob external storage. */
  externalStorage?: Maybe<Scalars['String']>;
  /** Blob mode. */
  mode?: Maybe<Scalars['String']>;
  /** Blob name. */
  name?: Maybe<Scalars['String']>;
  /** Blob path. */
  path?: Maybe<Scalars['String']>;
  /** Blob plain highlighted data. */
  plainData?: Maybe<Scalars['String']>;
  /** Blob raw content endpoint path. */
  rawPath: Scalars['String'];
  /** Raw content of the blob, if the blob is text data. */
  rawPlainData?: Maybe<Scalars['String']>;
  /** Shows whether the blob is rendered as text. */
  renderedAsText: Scalars['Boolean'];
  /** Blob highlighted data. */
  richData?: Maybe<Scalars['String']>;
  /** Blob content rich viewer. */
  richViewer?: Maybe<SnippetBlobViewer>;
  /** Blob content simple viewer. */
  simpleViewer: SnippetBlobViewer;
  /** Blob size. */
  size: Scalars['Int'];
};

/** Type of a snippet blob input action */
export type SnippetBlobActionEnum =
  /** Create a snippet blob. */
  | 'create'
  /** Delete a snippet blob. */
  | 'delete'
  /** Move a snippet blob. */
  | 'move'
  /** Update a snippet blob. */
  | 'update';

/** Represents an action to perform over a snippet file */
export type SnippetBlobActionInputType = {
  /** Type of input action. */
  action: SnippetBlobActionEnum;
  /** Snippet file content. */
  content?: InputMaybe<Scalars['String']>;
  /** Path of the snippet file. */
  filePath: Scalars['String'];
  /** Previous path of the snippet file. */
  previousPath?: InputMaybe<Scalars['String']>;
};

/** The connection type for SnippetBlob. */
export type SnippetBlobConnection = {
  __typename?: 'SnippetBlobConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetBlobEdge>>>;
  /** Indicates if the snippet has unretrievable blobs. */
  hasUnretrievableBlobs: Scalars['Boolean'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SnippetBlob>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetBlobEdge = {
  __typename?: 'SnippetBlobEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SnippetBlob>;
};

/** Represents how the blob content should be displayed */
export type SnippetBlobViewer = {
  __typename?: 'SnippetBlobViewer';
  /** Shows whether the blob should be displayed collapsed. */
  collapsed: Scalars['Boolean'];
  /** Content file type. */
  fileType: Scalars['String'];
  /** Shows whether the blob content is loaded asynchronously. */
  loadAsync: Scalars['Boolean'];
  /** Loading partial name. */
  loadingPartialName: Scalars['String'];
  /** Error rendering the blob content. */
  renderError?: Maybe<Scalars['String']>;
  /** Shows whether the blob is too large to be displayed. */
  tooLarge: Scalars['Boolean'];
  /** Type of blob viewer. */
  type: BlobViewersType;
};

/** The connection type for Snippet. */
export type SnippetConnection = {
  __typename?: 'SnippetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Snippet>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetEdge = {
  __typename?: 'SnippetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Snippet>;
};

export type SnippetPermissions = {
  __typename?: 'SnippetPermissions';
  /** Indicates the user can perform `admin_snippet` on this resource */
  adminSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `award_emoji` on this resource */
  awardEmoji: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `read_snippet` on this resource */
  readSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `report_snippet` on this resource */
  reportSnippet: Scalars['Boolean'];
  /** Indicates the user can perform `update_snippet` on this resource */
  updateSnippet: Scalars['Boolean'];
};

/** Represents the Geo sync and verification state of a snippet repository */
export type SnippetRepositoryRegistry = {
  __typename?: 'SnippetRepositoryRegistry';
  /** Timestamp when the SnippetRepositoryRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the SnippetRepositoryRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the SnippetRepositoryRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the SnippetRepositoryRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the SnippetRepositoryRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the SnippetRepositoryRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** ID of the Snippet Repository. */
  snippetRepositoryId: Scalars['ID'];
  /** Sync state of the SnippetRepositoryRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the SnippetRepositoryRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the SnippetRepositoryRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for SnippetRepositoryRegistry. */
export type SnippetRepositoryRegistryConnection = {
  __typename?: 'SnippetRepositoryRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SnippetRepositoryRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SnippetRepositoryRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SnippetRepositoryRegistryEdge = {
  __typename?: 'SnippetRepositoryRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SnippetRepositoryRegistry>;
};

/** Common sort values */
export type Sort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Values for sort direction */
export type SortDirectionEnum =
  /** Ascending order. */
  | 'ASC'
  /** Descending order. */
  | 'DESC';

/** SSH signature for a signed commit */
export type SshSignature = CommitSignature & {
  __typename?: 'SshSignature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** SSH key used for the signature. */
  key?: Maybe<Key>;
  /** Fingerprint of the key. */
  keyFingerprintSha256?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
};

export type StatusAction = {
  __typename?: 'StatusAction';
  /** Title for the button, for example: Retry this job. */
  buttonTitle?: Maybe<Scalars['String']>;
  /** Icon used in the action button. */
  icon?: Maybe<Scalars['String']>;
  /** ID for a status action. */
  id: Scalars['String'];
  /** Method for the action, for example: :post. */
  method?: Maybe<Scalars['String']>;
  /** Path for the action. */
  path?: Maybe<Scalars['String']>;
  /** Title for the action, for example: Retry. */
  title?: Maybe<Scalars['String']>;
};

export type StatusFilterInput = {
  /** Status of the work item. */
  status: RequirementStatusFilter;
};

export type StatusInput = {
  /** Status to assign to the work item. */
  status: TestReportState;
};

export type Submodule = Entry & {
  __typename?: 'Submodule';
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Tree URL for the sub-module. */
  treeUrl?: Maybe<Scalars['String']>;
  /** Type of tree entry. */
  type: EntryType;
  /** Web URL for the sub-module. */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for Submodule. */
export type SubmoduleConnection = {
  __typename?: 'SubmoduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubmoduleEdge = {
  __typename?: 'SubmoduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Submodule>;
};

export type Subscription = {
  __typename?: 'Subscription';
  /**
   * Triggered when a response from AI integration is received. Introduced in
   * 15.11: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.
   */
  aiCompletionResponse?: Maybe<AiResponse>;
  /** Triggered when the assignees of an issuable are updated. */
  issuableAssigneesUpdated?: Maybe<Issuable>;
  /** Triggered when the due date or start date of an issuable is updated. */
  issuableDatesUpdated?: Maybe<Issuable>;
  /** Triggered when the description of an issuable is updated. */
  issuableDescriptionUpdated?: Maybe<Issuable>;
  /** Triggered when the epic of an issuable is updated. */
  issuableEpicUpdated?: Maybe<Issuable>;
  /** Triggered when the health status of an issuable is updated. */
  issuableHealthStatusUpdated?: Maybe<Issuable>;
  /** Triggered when the iteration of an issuable is updated. */
  issuableIterationUpdated?: Maybe<Issuable>;
  /** Triggered when the labels of an issuable are updated. */
  issuableLabelsUpdated?: Maybe<Issuable>;
  /** Triggered when the milestone of an issuable is updated. */
  issuableMilestoneUpdated?: Maybe<Issuable>;
  /** Triggered when the title of an issuable is updated. */
  issuableTitleUpdated?: Maybe<Issuable>;
  /** Triggered when the weight of an issuable is updated. */
  issuableWeightUpdated?: Maybe<Issuable>;
  /** Triggered when the crm contacts of an issuable are updated. */
  issueCrmContactsUpdated?: Maybe<Issuable>;
  /** Triggered when approval state of a merge request is updated. */
  mergeRequestApprovalStateUpdated?: Maybe<Issuable>;
  /** Triggered when the merge status of a merge request is updated. */
  mergeRequestMergeStatusUpdated?: Maybe<Issuable>;
  /** Triggered when the reviewers of a merge request are updated. */
  mergeRequestReviewersUpdated?: Maybe<Issuable>;
  /**
   * Triggered when a note is created. Introduced in 15.9: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  workItemNoteCreated?: Maybe<Note>;
  /**
   * Triggered when a note is deleted. Introduced in 15.9: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  workItemNoteDeleted?: Maybe<DeletedNote>;
  /**
   * Triggered when a note is updated. Introduced in 15.9: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  workItemNoteUpdated?: Maybe<Note>;
  /** Triggered when a work item is updated. */
  workItemUpdated?: Maybe<WorkItem>;
};


export type SubscriptionAiCompletionResponseArgs = {
  resourceId: Scalars['AiModelID'];
  userId?: InputMaybe<Scalars['UserID']>;
};


export type SubscriptionIssuableAssigneesUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableDatesUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableDescriptionUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableEpicUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableHealthStatusUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableIterationUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableLabelsUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableMilestoneUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableTitleUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssuableWeightUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionIssueCrmContactsUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionMergeRequestApprovalStateUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionMergeRequestMergeStatusUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionMergeRequestReviewersUpdatedArgs = {
  issuableId: Scalars['IssuableID'];
};


export type SubscriptionWorkItemNoteCreatedArgs = {
  noteableId?: InputMaybe<Scalars['NoteableID']>;
};


export type SubscriptionWorkItemNoteDeletedArgs = {
  noteableId?: InputMaybe<Scalars['NoteableID']>;
};


export type SubscriptionWorkItemNoteUpdatedArgs = {
  noteableId?: InputMaybe<Scalars['NoteableID']>;
};


export type SubscriptionWorkItemUpdatedArgs = {
  workItemId: Scalars['WorkItemID'];
};

/** Represents an entry from the future subscriptions */
export type SubscriptionFutureEntry = {
  __typename?: 'SubscriptionFutureEntry';
  /** Company of the licensee. */
  company?: Maybe<Scalars['String']>;
  /** Email of the licensee. */
  email?: Maybe<Scalars['String']>;
  /** Date when the license expires. */
  expiresAt?: Maybe<Scalars['Date']>;
  /** Name of the licensee. */
  name?: Maybe<Scalars['String']>;
  /** Name of the subscription plan. */
  plan: Scalars['String'];
  /** Date when the license started. */
  startsAt?: Maybe<Scalars['Date']>;
  /** Type of license the subscription will yield. */
  type: Scalars['String'];
  /** Number of paid user seats. */
  usersInLicenseCount?: Maybe<Scalars['Int']>;
};

/** The connection type for SubscriptionFutureEntry. */
export type SubscriptionFutureEntryConnection = {
  __typename?: 'SubscriptionFutureEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubscriptionFutureEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SubscriptionFutureEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubscriptionFutureEntryEdge = {
  __typename?: 'SubscriptionFutureEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SubscriptionFutureEntry>;
};

/** Represents a Suggested Reviewers result set */
export type SuggestedReviewersType = {
  __typename?: 'SuggestedReviewersType';
  /** List of accepted reviewer usernames. */
  accepted?: Maybe<Array<Scalars['String']>>;
  /** Timestamp of when the suggestions were created. */
  createdAt: Scalars['Time'];
  /** List of suggested reviewer usernames. */
  suggested: Array<Scalars['String']>;
  /** Timestamp of when the suggestions were updated. */
  updatedAt: Scalars['Time'];
};

export type SystemNoteMetadata = {
  __typename?: 'SystemNoteMetadata';
  /** System note metadata action. */
  action?: Maybe<Scalars['String']>;
  /** Version of the changed description. */
  descriptionVersion?: Maybe<DescriptionVersion>;
  /** Global ID of the specific system note metadata. */
  id: Scalars['SystemNoteMetadataID'];
};

/** Completion status of tasks */
export type TaskCompletionStatus = {
  __typename?: 'TaskCompletionStatus';
  /** Number of completed tasks. */
  completedCount: Scalars['Int'];
  /** Number of total tasks. */
  count: Scalars['Int'];
};

export type TerraformState = {
  __typename?: 'TerraformState';
  /** Timestamp the Terraform state was created. */
  createdAt: Scalars['Time'];
  /** Timestamp the Terraform state was deleted. */
  deletedAt?: Maybe<Scalars['Time']>;
  /** ID of the Terraform state. */
  id: Scalars['ID'];
  /** Latest version of the Terraform state. */
  latestVersion?: Maybe<TerraformStateVersion>;
  /** Timestamp the Terraform state was locked. */
  lockedAt?: Maybe<Scalars['Time']>;
  /** User currently holding a lock on the Terraform state. */
  lockedByUser?: Maybe<UserCore>;
  /** Name of the Terraform state. */
  name: Scalars['String'];
  /** Timestamp the Terraform state was updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for TerraformState. */
export type TerraformStateConnection = {
  __typename?: 'TerraformStateConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TerraformStateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TerraformState>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TerraformStateDelete */
export type TerraformStateDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID'];
};

/** Autogenerated return type of TerraformStateDelete */
export type TerraformStateDeletePayload = {
  __typename?: 'TerraformStateDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type TerraformStateEdge = {
  __typename?: 'TerraformStateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TerraformState>;
};

/** Autogenerated input type of TerraformStateLock */
export type TerraformStateLockInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID'];
};

/** Autogenerated return type of TerraformStateLock */
export type TerraformStateLockPayload = {
  __typename?: 'TerraformStateLockPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of TerraformStateUnlock */
export type TerraformStateUnlockInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the Terraform state. */
  id: Scalars['TerraformStateID'];
};

/** Autogenerated return type of TerraformStateUnlock */
export type TerraformStateUnlockPayload = {
  __typename?: 'TerraformStateUnlockPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type TerraformStateVersion = {
  __typename?: 'TerraformStateVersion';
  /** Timestamp the version was created. */
  createdAt: Scalars['Time'];
  /** User that created this version. */
  createdByUser?: Maybe<UserCore>;
  /** URL for downloading the version's JSON file. */
  downloadPath?: Maybe<Scalars['String']>;
  /** ID of the Terraform state version. */
  id: Scalars['ID'];
  /** Job that created this version. */
  job?: Maybe<CiJob>;
  /** Serial number of the version. */
  serial?: Maybe<Scalars['Int']>;
  /** Timestamp the version was updated. */
  updatedAt: Scalars['Time'];
};

/** Represents the Geo sync and verification state of a terraform state version */
export type TerraformStateVersionRegistry = {
  __typename?: 'TerraformStateVersionRegistry';
  /** Timestamp when the TerraformStateVersionRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the TerraformStateVersionRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the TerraformStateVersionRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the TerraformStateVersionRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the TerraformStateVersionRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the TerraformStateVersionRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the TerraformStateVersionRegistry */
  state?: Maybe<RegistryState>;
  /** ID of the terraform state version. */
  terraformStateVersionId: Scalars['ID'];
  /** Timestamp after which the TerraformStateVersionRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the TerraformStateVersionRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for TerraformStateVersionRegistry. */
export type TerraformStateVersionRegistryConnection = {
  __typename?: 'TerraformStateVersionRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TerraformStateVersionRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TerraformStateVersionRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TerraformStateVersionRegistryEdge = {
  __typename?: 'TerraformStateVersionRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TerraformStateVersionRegistry>;
};

/** Test case in pipeline test report. */
export type TestCase = {
  __typename?: 'TestCase';
  /** URL of the test case attachment file. */
  attachmentUrl?: Maybe<Scalars['String']>;
  /** Classname of the test case. */
  classname?: Maybe<Scalars['String']>;
  /** Test case execution time in seconds. */
  executionTime?: Maybe<Scalars['Float']>;
  /** Path to the file of the test case. */
  file?: Maybe<Scalars['String']>;
  /** Name of the test case. */
  name?: Maybe<Scalars['String']>;
  /** Recent failure history of the test case on the base branch. */
  recentFailures?: Maybe<RecentFailures>;
  /** Stack trace of the test case. */
  stackTrace?: Maybe<Scalars['String']>;
  /** Status of the test case (error, failed, success, skipped). */
  status?: Maybe<TestCaseStatus>;
  /** System output of the test case. */
  systemOutput?: Maybe<Scalars['String']>;
};

/** The connection type for TestCase. */
export type TestCaseConnection = {
  __typename?: 'TestCaseConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestCaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestCase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestCaseEdge = {
  __typename?: 'TestCaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TestCase>;
};

export type TestCaseStatus =
  /** Test case that has a status of error. */
  | 'error'
  /** Test case that has a status of failed. */
  | 'failed'
  /** Test case that has a status of skipped. */
  | 'skipped'
  /** Test case that has a status of success. */
  | 'success';

/** Represents a requirement test report */
export type TestReport = {
  __typename?: 'TestReport';
  /** Author of the test report. */
  author?: Maybe<UserCore>;
  /** Timestamp of when the test report was created. */
  createdAt: Scalars['Time'];
  /** ID of the test report. */
  id: Scalars['ID'];
  /** State of the test report. */
  state: TestReportState;
  /** Indicates whether the test report was generated with references to legacy requirement IIDs. */
  usesLegacyIid?: Maybe<Scalars['Boolean']>;
};

/** The connection type for TestReport. */
export type TestReportConnection = {
  __typename?: 'TestReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestReportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestReport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestReportEdge = {
  __typename?: 'TestReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TestReport>;
};

/** State of a test report */
export type TestReportState =
  /** Failed test report. */
  | 'FAILED'
  /** Passed test report. */
  | 'PASSED';

/** Test report for a pipeline */
export type TestReportSummary = {
  __typename?: 'TestReportSummary';
  /** Test suites belonging to a pipeline test report. */
  testSuites: TestSuiteSummaryConnection;
  /** Total report statistics for a pipeline test report. */
  total: TestReportTotal;
};


/** Test report for a pipeline */
export type TestReportSummaryTestSuitesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Total test report statistics. */
export type TestReportTotal = {
  __typename?: 'TestReportTotal';
  /** Total number of the test cases. */
  count?: Maybe<Scalars['Int']>;
  /** Total number of test cases that had an error. */
  error?: Maybe<Scalars['Int']>;
  /** Total number of test cases that failed. */
  failed?: Maybe<Scalars['Int']>;
  /** Total number of test cases that were skipped. */
  skipped?: Maybe<Scalars['Int']>;
  /** Total number of test cases that succeeded. */
  success?: Maybe<Scalars['Int']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']>;
  /** Total duration of the tests. */
  time?: Maybe<Scalars['Float']>;
};

/** Test suite in a pipeline test report. */
export type TestSuite = {
  __typename?: 'TestSuite';
  /** Total number of test cases that had an error. */
  errorCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that failed in the test suite. */
  failedCount?: Maybe<Scalars['Int']>;
  /** Name of the test suite. */
  name?: Maybe<Scalars['String']>;
  /** Total number of test cases that were skipped in the test suite. */
  skippedCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that succeeded in the test suite. */
  successCount?: Maybe<Scalars['Int']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']>;
  /** Test cases in the test suite. */
  testCases?: Maybe<TestCaseConnection>;
  /** Total number of the test cases in the test suite. */
  totalCount?: Maybe<Scalars['Int']>;
  /** Total duration of the tests in the test suite. */
  totalTime?: Maybe<Scalars['Float']>;
};


/** Test suite in a pipeline test report. */
export type TestSuiteTestCasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Test suite summary in a pipeline test report. */
export type TestSuiteSummary = {
  __typename?: 'TestSuiteSummary';
  /** IDs of the builds used to run the test suite. */
  buildIds?: Maybe<Array<Scalars['ID']>>;
  /** Total number of test cases that had an error. */
  errorCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that failed in the test suite. */
  failedCount?: Maybe<Scalars['Int']>;
  /** Name of the test suite. */
  name?: Maybe<Scalars['String']>;
  /** Total number of test cases that were skipped in the test suite. */
  skippedCount?: Maybe<Scalars['Int']>;
  /** Total number of test cases that succeeded in the test suite. */
  successCount?: Maybe<Scalars['Int']>;
  /** Test suite error message. */
  suiteError?: Maybe<Scalars['String']>;
  /** Total number of the test cases in the test suite. */
  totalCount?: Maybe<Scalars['Int']>;
  /** Total duration of the tests in the test suite. */
  totalTime?: Maybe<Scalars['Float']>;
};

/** The connection type for TestSuiteSummary. */
export type TestSuiteSummaryConnection = {
  __typename?: 'TestSuiteSummaryConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TestSuiteSummaryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TestSuiteSummary>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TestSuiteSummaryEdge = {
  __typename?: 'TestSuiteSummaryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TestSuiteSummary>;
};

/** Represents the time report stats for timeboxes */
export type TimeReportStats = {
  __typename?: 'TimeReportStats';
  /** Completed issues metrics. */
  complete?: Maybe<TimeboxMetrics>;
  /** Incomplete issues metrics. */
  incomplete?: Maybe<TimeboxMetrics>;
  /** Total issues metrics. */
  total?: Maybe<TimeboxMetrics>;
};

export type TimeTrackingTimelogCategory = {
  __typename?: 'TimeTrackingTimelogCategory';
  /** Whether the category is billable or not. */
  billable?: Maybe<Scalars['Boolean']>;
  /** Billing rate for the category. */
  billingRate?: Maybe<Scalars['Float']>;
  /** Color assigned to the category. */
  color?: Maybe<Scalars['Color']>;
  /** When the category was created. */
  createdAt: Scalars['Time'];
  /** Description of the category. */
  description?: Maybe<Scalars['String']>;
  /** Internal ID of the timelog category. */
  id: Scalars['ID'];
  /** Name of the category. */
  name: Scalars['String'];
  /** When the category was last updated. */
  updatedAt: Scalars['Time'];
};

/** The connection type for TimeTrackingTimelogCategory. */
export type TimeTrackingTimelogCategoryConnection = {
  __typename?: 'TimeTrackingTimelogCategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimeTrackingTimelogCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimeTrackingTimelogCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimeTrackingTimelogCategoryEdge = {
  __typename?: 'TimeTrackingTimelogCategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimeTrackingTimelogCategory>;
};

/** Represents measured stats metrics for timeboxes */
export type TimeboxMetrics = {
  __typename?: 'TimeboxMetrics';
  /** Count metric. */
  count: Scalars['Int'];
  /** Weight metric. */
  weight: Scalars['Int'];
};

/** Represents a historically accurate report about the timebox */
export type TimeboxReport = {
  __typename?: 'TimeboxReport';
  /** Daily scope and completed totals for burnup charts. */
  burnupTimeSeries?: Maybe<Array<BurnupChartDailyTotals>>;
  /** If the report cannot be generated, information about why. */
  error?: Maybe<TimeboxReportError>;
  /** Represents the time report stats for the timebox. */
  stats?: Maybe<TimeReportStats>;
};

/** Explains why we could not generate a timebox report. */
export type TimeboxReportError = {
  __typename?: 'TimeboxReportError';
  /** Machine readable code, categorizing the error. */
  code?: Maybe<TimeboxReportErrorReason>;
  /** Human readable message explaining what happened. */
  message?: Maybe<Scalars['String']>;
};

/** Category of error. */
export type TimeboxReportErrorReason =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Label priority by ascending order. */
  | 'LABEL_PRIORITY_ASC'
  /** Label priority by descending order. */
  | 'LABEL_PRIORITY_DESC'
  /** Milestone due date by ascending order. */
  | 'MILESTONE_DUE_ASC'
  /** Milestone due date by descending order. */
  | 'MILESTONE_DUE_DESC'
  /** One or both of start_date and due_date is missing. */
  | 'MISSING_DATES'
  /** Priority by ascending order. */
  | 'PRIORITY_ASC'
  /** Priority by descending order. */
  | 'PRIORITY_DESC'
  /** There are too many events. */
  | 'TOO_MANY_EVENTS'
  /** This type does not support timebox reports. */
  | 'UNSUPPORTED'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

export type TimeboxReportInterface = {
  /** Historically accurate report about the timebox. */
  report?: Maybe<TimeboxReport>;
};


export type TimeboxReportInterfaceReportArgs = {
  fullPath?: InputMaybe<Scalars['String']>;
};

/** A time-frame defined as a closed inclusive range of two dates */
export type Timeframe = {
  /** End of the range. */
  end: Scalars['Date'];
  /** Start of the range. */
  start: Scalars['Date'];
};

/** Autogenerated input type of TimelineEventCreate */
export type TimelineEventCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Incident ID of the timeline event. */
  incidentId: Scalars['IssueID'];
  /** Text note of the timeline event. */
  note: Scalars['String'];
  /** Timestamp of when the event occurred. */
  occurredAt: Scalars['Time'];
  /** Tags for the incident timeline event. */
  timelineEventTagNames?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of TimelineEventCreate */
export type TimelineEventCreatePayload = {
  __typename?: 'TimelineEventCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventDestroy */
export type TimelineEventDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Timeline event ID to remove. */
  id: Scalars['IncidentManagementTimelineEventID'];
};

/** Autogenerated return type of TimelineEventDestroy */
export type TimelineEventDestroyPayload = {
  __typename?: 'TimelineEventDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventPromoteFromNote */
export type TimelineEventPromoteFromNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Note ID from which the timeline event promoted. */
  noteId: Scalars['NoteID'];
};

/** Autogenerated return type of TimelineEventPromoteFromNote */
export type TimelineEventPromoteFromNotePayload = {
  __typename?: 'TimelineEventPromoteFromNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventTagCreate */
export type TimelineEventTagCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Name of the tag. */
  name: Scalars['String'];
  /** Project to create the timeline event tag in. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of TimelineEventTagCreate */
export type TimelineEventTagCreatePayload = {
  __typename?: 'TimelineEventTagCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event tag. */
  timelineEventTag?: Maybe<TimelineEventTagType>;
};

/** Describes a tag on an incident management timeline event. */
export type TimelineEventTagType = {
  __typename?: 'TimelineEventTagType';
  /** ID of the timeline event tag. */
  id: Scalars['IncidentManagementTimelineEventTagID'];
  /** Name of the timeline event tag. */
  name: Scalars['String'];
};

/** The connection type for TimelineEventTagType. */
export type TimelineEventTagTypeConnection = {
  __typename?: 'TimelineEventTagTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelineEventTagTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimelineEventTagType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimelineEventTagTypeEdge = {
  __typename?: 'TimelineEventTagTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimelineEventTagType>;
};

/** Describes an incident management timeline event */
export type TimelineEventType = {
  __typename?: 'TimelineEventType';
  /** Indicates the timeline event icon. */
  action: Scalars['String'];
  /** User that created the timeline event. */
  author?: Maybe<UserCore>;
  /** Timestamp when the event created. */
  createdAt: Scalars['Time'];
  /** Indicates the timeline event is editable. */
  editable: Scalars['Boolean'];
  /** ID of the timeline event. */
  id: Scalars['IncidentManagementTimelineEventID'];
  /** Incident of the timeline event. */
  incident: Issue;
  /** Text note of the timeline event. */
  note?: Maybe<Scalars['String']>;
  /** HTML note of the timeline event. */
  noteHtml?: Maybe<Scalars['String']>;
  /** Timestamp when the event occurred. */
  occurredAt: Scalars['Time'];
  /** Note from which the timeline event was created. */
  promotedFromNote?: Maybe<Note>;
  /** Tags for the incident timeline event. */
  timelineEventTags?: Maybe<TimelineEventTagTypeConnection>;
  /** Timestamp when the event updated. */
  updatedAt: Scalars['Time'];
  /** User that updated the timeline event. */
  updatedByUser?: Maybe<UserCore>;
};


/** Describes an incident management timeline event */
export type TimelineEventTypeTimelineEventTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for TimelineEventType. */
export type TimelineEventTypeConnection = {
  __typename?: 'TimelineEventTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelineEventTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TimelineEventType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TimelineEventTypeEdge = {
  __typename?: 'TimelineEventTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TimelineEventType>;
};

/** Autogenerated input type of TimelineEventUpdate */
export type TimelineEventUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the timeline event to update. */
  id: Scalars['IncidentManagementTimelineEventID'];
  /** Text note of the timeline event. */
  note?: InputMaybe<Scalars['String']>;
  /** Timestamp when the event occurred. */
  occurredAt?: InputMaybe<Scalars['Time']>;
  /** Tags for the incident timeline event. */
  timelineEventTagNames?: InputMaybe<Array<Scalars['String']>>;
};

/** Autogenerated return type of TimelineEventUpdate */
export type TimelineEventUpdatePayload = {
  __typename?: 'TimelineEventUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timeline event. */
  timelineEvent?: Maybe<TimelineEventType>;
};

export type Timelog = {
  __typename?: 'Timelog';
  /** Internal ID of the timelog. */
  id: Scalars['ID'];
  /** Issue that logged time was added to. */
  issue?: Maybe<Issue>;
  /** Merge request that logged time was added to. */
  mergeRequest?: Maybe<MergeRequest>;
  /** Note where the quick action was executed to add the logged time. */
  note?: Maybe<Note>;
  /** Target project of the timelog merge request or issue. */
  project: Project;
  /** Timestamp of when the time tracked was spent at. */
  spentAt?: Maybe<Scalars['Time']>;
  /** Summary of how the time was spent. */
  summary?: Maybe<Scalars['String']>;
  /** Time spent displayed in seconds. */
  timeSpent: Scalars['Int'];
  /** User that logged the time. */
  user: UserCore;
  /** Permissions for the current user on the resource */
  userPermissions: TimelogPermissions;
};

/** The connection type for Timelog. */
export type TimelogConnection = {
  __typename?: 'TimelogConnection';
  /** Total count of collection. */
  count: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TimelogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Timelog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Total time spent in seconds. */
  totalSpentTime: Scalars['BigInt'];
};

/** Autogenerated input type of TimelogCreate */
export type TimelogCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the issuable (Issue, WorkItem or MergeRequest). */
  issuableId: Scalars['IssuableID'];
  /** When the time was spent. */
  spentAt: Scalars['Time'];
  /** Summary of time spent. */
  summary: Scalars['String'];
  /** Amount of time spent. */
  timeSpent: Scalars['String'];
};

/** Autogenerated return type of TimelogCreate */
export type TimelogCreatePayload = {
  __typename?: 'TimelogCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timelog. */
  timelog?: Maybe<Timelog>;
};

/** Autogenerated input type of TimelogDelete */
export type TimelogDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the timelog. */
  id: Scalars['TimelogID'];
};

/** Autogenerated return type of TimelogDelete */
export type TimelogDeletePayload = {
  __typename?: 'TimelogDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Timelog. */
  timelog?: Maybe<Timelog>;
};

/** An edge in a connection. */
export type TimelogEdge = {
  __typename?: 'TimelogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Timelog>;
};

export type TimelogPermissions = {
  __typename?: 'TimelogPermissions';
  /** Indicates the user can perform `admin_timelog` on this resource */
  adminTimelog: Scalars['Boolean'];
};

/** Values for sorting timelogs */
export type TimelogSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Spent at ascending order. */
  | 'SPENT_AT_ASC'
  /** Spent at descending order. */
  | 'SPENT_AT_DESC'
  /** Time spent ascending order. */
  | 'TIME_SPENT_ASC'
  /** Time spent descending order. */
  | 'TIME_SPENT_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** Representing a to-do entry */
export type Todo = {
  __typename?: 'Todo';
  /** Action of the to-do item. */
  action: TodoActionEnum;
  /** Author of this to-do item. */
  author: UserCore;
  /** Body of the to-do item. */
  body: Scalars['String'];
  /** Timestamp this to-do item was created. */
  createdAt: Scalars['Time'];
  /** Group this to-do item is associated with. */
  group?: Maybe<Group>;
  /** ID of the to-do item. */
  id: Scalars['ID'];
  /** Note which created this to-do item. */
  note?: Maybe<Note>;
  /** Project this to-do item is associated with. */
  project?: Maybe<Project>;
  /** State of the to-do item. */
  state: TodoStateEnum;
  /** Target of the to-do item. */
  target: Todoable;
  /** Target type of the to-do item. */
  targetType: TodoTargetEnum;
};

export type TodoActionEnum =
  /** User was set as an approver. */
  | 'approval_required'
  /** User was assigned. */
  | 'assigned'
  /** Build triggered by the user failed. */
  | 'build_failed'
  /** User was directly addressed. */
  | 'directly_addressed'
  /** User added a to-do item. */
  | 'marked'
  /** Group or project access requested from the user. */
  | 'member_access_requested'
  /** User was mentioned. */
  | 'mentioned'
  /** Merge request authored by the user was removed from the merge train. */
  | 'merge_train_removed'
  /** Review was requested from the user. */
  | 'review_requested'
  /** Merge request authored by the user could not be merged. */
  | 'unmergeable';

/** The connection type for Todo. */
export type TodoConnection = {
  __typename?: 'TodoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TodoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Todo>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of TodoCreate */
export type TodoCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. */
  targetId: Scalars['TodoableID'];
};

/** Autogenerated return type of TodoCreate */
export type TodoCreatePayload = {
  __typename?: 'TodoCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** To-do item created. */
  todo?: Maybe<Todo>;
};

/** An edge in a connection. */
export type TodoEdge = {
  __typename?: 'TodoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Todo>;
};

/** Autogenerated input type of TodoMarkDone */
export type TodoMarkDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the to-do item to mark as done. */
  id: Scalars['TodoID'];
};

/** Autogenerated return type of TodoMarkDone */
export type TodoMarkDonePayload = {
  __typename?: 'TodoMarkDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requested to-do item. */
  todo: Todo;
};

/** Autogenerated input type of TodoRestore */
export type TodoRestoreInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the to-do item to restore. */
  id: Scalars['TodoID'];
};

/** Autogenerated input type of TodoRestoreMany */
export type TodoRestoreManyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global IDs of the to-do items to restore (a maximum of 50 is supported at once). */
  ids: Array<Scalars['TodoID']>;
};

/** Autogenerated return type of TodoRestoreMany */
export type TodoRestoreManyPayload = {
  __typename?: 'TodoRestoreManyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated to-do items. */
  todos: Array<Todo>;
};

/** Autogenerated return type of TodoRestore */
export type TodoRestorePayload = {
  __typename?: 'TodoRestorePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requested to-do item. */
  todo: Todo;
};

export type TodoStateEnum =
  /** State of the todo is done. */
  | 'done'
  /** State of the todo is pending. */
  | 'pending';

export type TodoTargetEnum =
  /** Alert. */
  | 'ALERT'
  /** Commit. */
  | 'COMMIT'
  /** Design. */
  | 'DESIGN'
  /** An Epic. */
  | 'EPIC'
  /** Issue. */
  | 'ISSUE'
  /** Merge request. */
  | 'MERGEREQUEST'
  /** Work item. */
  | 'WORKITEM';

export type Todoable = {
  /** URL of this object. */
  webUrl?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of TodosMarkAllDone */
export type TodosMarkAllDoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Global ID of the to-do item's parent. Issues, merge requests, designs, and
   * epics are supported. If argument is omitted, all pending to-do items of the
   * current user are marked as done.
   */
  targetId?: InputMaybe<Scalars['TodoableID']>;
};

/** Autogenerated return type of TodosMarkAllDone */
export type TodosMarkAllDonePayload = {
  __typename?: 'TodosMarkAllDonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated to-do items. */
  todos: Array<Todo>;
};

export type Topic = {
  __typename?: 'Topic';
  /** URL to avatar image file of the topic. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Description of the topic. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** ID of the topic. */
  id: Scalars['ID'];
  /** Name of the topic. */
  name: Scalars['String'];
  /** Title of the topic. */
  title: Scalars['String'];
};

/** The connection type for Topic. */
export type TopicConnection = {
  __typename?: 'TopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Topic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TopicEdge = {
  __typename?: 'TopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Topic>;
};

/**
 * Status of the request to the training provider. The URL of a TrainingUrl is
 * calculated asynchronously. When PENDING, the URL of the TrainingUrl will be
 * null. When COMPLETED, the URL of the TrainingUrl will be available.
 */
export type TrainingUrlRequestStatus =
  /** Completed request. */
  | 'COMPLETED'
  /** Pending request. */
  | 'PENDING';

export type Tree = {
  __typename?: 'Tree';
  /** Blobs of the tree. */
  blobs: BlobConnection;
  /** Last commit for the tree. */
  lastCommit?: Maybe<Commit>;
  /** Sub-modules of the tree. */
  submodules: SubmoduleConnection;
  /** Trees of the tree. */
  trees: TreeEntryConnection;
};


export type TreeBlobsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type TreeSubmodulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type TreeTreesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Tree. */
export type TreeConnection = {
  __typename?: 'TreeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TreeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Tree>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TreeEdge = {
  __typename?: 'TreeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Tree>;
};

/** Represents a directory */
export type TreeEntry = Entry & {
  __typename?: 'TreeEntry';
  /** Flat path of the entry. */
  flatPath: Scalars['String'];
  /** ID of the entry. */
  id: Scalars['ID'];
  /** Name of the entry. */
  name: Scalars['String'];
  /** Path of the entry. */
  path: Scalars['String'];
  /** Last commit SHA for the entry. */
  sha: Scalars['String'];
  /** Type of tree entry. */
  type: EntryType;
  /** Web path for the tree entry (directory). */
  webPath?: Maybe<Scalars['String']>;
  /** Web URL for the tree entry (directory). */
  webUrl?: Maybe<Scalars['String']>;
};

/** The connection type for TreeEntry. */
export type TreeEntryConnection = {
  __typename?: 'TreeEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TreeEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TreeEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TreeEntryEdge = {
  __typename?: 'TreeEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<TreeEntry>;
};

export type TypeEnum =
  /** Snippet created independent of any project. */
  | 'personal'
  /** Snippet related to a specific project. */
  | 'project';

export type UnionedEpicFilterInput = {
  /** Filters epics that are authored by one of the given users. */
  authorUsername?: InputMaybe<Array<Scalars['String']>>;
  /** Filters epics that have at least one of the given labels. */
  labelName?: InputMaybe<Array<Scalars['String']>>;
};

export type UnionedIssueFilterInput = {
  /** Filters issues that are assigned to at least one of the given users. */
  assigneeUsernames?: InputMaybe<Array<Scalars['String']>>;
  /** Filters issues that are authored by one of the given users. */
  authorUsernames?: InputMaybe<Array<Scalars['String']>>;
  /** Filters issues that have at least one of the given labels. */
  labelNames?: InputMaybe<Array<Scalars['String']>>;
};

/** Defines which user roles, users, or groups can unprotect a protected branch. */
export type UnprotectAccessLevel = {
  __typename?: 'UnprotectAccessLevel';
  /** GitLab::Access level. */
  accessLevel: Scalars['Int'];
  /** Human readable representation for this access level. */
  accessLevelDescription: Scalars['String'];
  /** Group associated with this access level. */
  group?: Maybe<AccessLevelGroup>;
  /** User associated with this access level. */
  user?: Maybe<AccessLevelUser>;
};

/** The connection type for UnprotectAccessLevel. */
export type UnprotectAccessLevelConnection = {
  __typename?: 'UnprotectAccessLevelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UnprotectAccessLevelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UnprotectAccessLevel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UnprotectAccessLevelEdge = {
  __typename?: 'UnprotectAccessLevelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UnprotectAccessLevel>;
};

/** Autogenerated input type of UpdateAlertStatus */
export type UpdateAlertStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** IID of the alert to mutate. */
  iid: Scalars['String'];
  /** Project the alert to mutate is in. */
  projectPath: Scalars['ID'];
  /** Status to set the alert. */
  status: AlertManagementStatus;
};

/** Autogenerated return type of UpdateAlertStatus */
export type UpdateAlertStatusPayload = {
  __typename?: 'UpdateAlertStatusPayload';
  /** Alert after mutation. */
  alert?: Maybe<AlertManagementAlert>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue created after mutation. */
  issue?: Maybe<Issue>;
  /** To-do item after mutation. */
  todo?: Maybe<Todo>;
};

/** Autogenerated input type of UpdateBoardEpicUserPreferences */
export type UpdateBoardEpicUserPreferencesInput = {
  /** Board global ID. */
  boardId: Scalars['BoardID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the epic should be collapsed in the board. */
  collapsed: Scalars['Boolean'];
  /** ID of an epic to set preferences for. */
  epicId: Scalars['EpicID'];
};

/** Autogenerated return type of UpdateBoardEpicUserPreferences */
export type UpdateBoardEpicUserPreferencesPayload = {
  __typename?: 'UpdateBoardEpicUserPreferencesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** User preferences for the epic in the board after mutation. */
  epicUserPreferences?: Maybe<BoardEpicUserPreferences>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateBoard */
export type UpdateBoardInput = {
  /** ID of user to be assigned to the board. */
  assigneeId?: InputMaybe<Scalars['UserID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not backlog list is hidden. */
  hideBacklogList?: InputMaybe<Scalars['Boolean']>;
  /** Whether or not closed list is hidden. */
  hideClosedList?: InputMaybe<Scalars['Boolean']>;
  /** Board global ID. */
  id: Scalars['BoardID'];
  /** ID of iteration cadence to be assigned to the board. */
  iterationCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** ID of iteration to be assigned to the board. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
  /** IDs of labels to be added to the board. */
  labelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Labels of the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** ID of milestone to be assigned to the board. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
  /** Board name. */
  name?: InputMaybe<Scalars['String']>;
  /** Weight value to be assigned to the board. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of UpdateBoardList */
export type UpdateBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates if the list is collapsed for the user. */
  collapsed?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the list. */
  listId: Scalars['ListID'];
  /** Position of list within the board. */
  position?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateBoardList */
export type UpdateBoardListPayload = {
  __typename?: 'UpdateBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Mutated list. */
  list?: Maybe<BoardList>;
};

/** Autogenerated return type of UpdateBoard */
export type UpdateBoardPayload = {
  __typename?: 'UpdateBoardPayload';
  /** Board after mutation. */
  board?: Maybe<Board>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateComplianceFramework */
export type UpdateComplianceFrameworkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the compliance framework to update. */
  id: Scalars['ComplianceManagementFrameworkID'];
  /** Parameters to update the compliance framework with. */
  params: ComplianceFrameworkInput;
};

/** Autogenerated return type of UpdateComplianceFramework */
export type UpdateComplianceFrameworkPayload = {
  __typename?: 'UpdateComplianceFrameworkPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Compliance framework after mutation. */
  complianceFramework?: Maybe<ComplianceFramework>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateContainerExpirationPolicy */
export type UpdateContainerExpirationPolicyInput = {
  /** This container expiration policy schedule. */
  cadence?: InputMaybe<ContainerExpirationPolicyCadenceEnum>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates whether this container expiration policy is enabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Number of tags to retain. */
  keepN?: InputMaybe<ContainerExpirationPolicyKeepEnum>;
  /** Tags with names matching this regex pattern will expire. */
  nameRegex?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Tags with names matching this regex pattern will be preserved. */
  nameRegexKeep?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Tags older that this will expire. */
  olderThan?: InputMaybe<ContainerExpirationPolicyOlderThanEnum>;
  /** Project path where the container expiration policy is located. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of UpdateContainerExpirationPolicy */
export type UpdateContainerExpirationPolicyPayload = {
  __typename?: 'UpdateContainerExpirationPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Container expiration policy after mutation. */
  containerExpirationPolicy?: Maybe<ContainerExpirationPolicy>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateDependencyProxyImageTtlGroupPolicy */
export type UpdateDependencyProxyImageTtlGroupPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Group path for the group dependency proxy image TTL policy. */
  groupPath: Scalars['ID'];
  /** Number of days to retain a cached image file. */
  ttl?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateDependencyProxyImageTtlGroupPolicy */
export type UpdateDependencyProxyImageTtlGroupPolicyPayload = {
  __typename?: 'UpdateDependencyProxyImageTtlGroupPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Group image TTL policy after mutation. */
  dependencyProxyImageTtlPolicy?: Maybe<DependencyProxyImageTtlGroupPolicy>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateDependencyProxySettings */
export type UpdateDependencyProxySettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates whether the policy is enabled or disabled. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Group path for the group dependency proxy. */
  groupPath: Scalars['ID'];
};

/** Autogenerated return type of UpdateDependencyProxySettings */
export type UpdateDependencyProxySettingsPayload = {
  __typename?: 'UpdateDependencyProxySettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Group dependency proxy settings after mutation. */
  dependencyProxySetting?: Maybe<DependencyProxySetting>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

export type UpdateDiffImagePositionInput = {
  /** Total height of the image. */
  height?: InputMaybe<Scalars['Int']>;
  /** Total width of the image. */
  width?: InputMaybe<Scalars['Int']>;
  /** X position of the note. */
  x?: InputMaybe<Scalars['Int']>;
  /** Y position of the note. */
  y?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of UpdateEpicBoardList */
export type UpdateEpicBoardListInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates if the list is collapsed for the user. */
  collapsed?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the epic list. */
  listId: Scalars['BoardsEpicListID'];
  /** Position of list within the board. */
  position?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateEpicBoardList */
export type UpdateEpicBoardListPayload = {
  __typename?: 'UpdateEpicBoardListPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Mutated epic list. */
  list?: Maybe<EpicList>;
};

/** Autogenerated input type of UpdateEpic */
export type UpdateEpicInput = {
  /** IDs of labels to be added to the epic. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Array of labels to be added to the epic. */
  addLabels?: InputMaybe<Array<Scalars['String']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Color of the epic. Available only when feature flag `epic_color_highlight` is
   * enabled. This flag is disabled by default, because the feature is experimental
   * and is subject to change without notice.
   */
  color?: InputMaybe<Scalars['Color']>;
  /** Indicates if the epic is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Description of the epic. */
  description?: InputMaybe<Scalars['String']>;
  /** End date of the epic. */
  dueDateFixed?: InputMaybe<Scalars['String']>;
  /** Indicates end date should be sourced from due_date_fixed field not the issue milestones. */
  dueDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** Group the epic to mutate is in. */
  groupPath: Scalars['ID'];
  /** IID of the epic to mutate. */
  iid: Scalars['ID'];
  /** IDs of labels to be removed from the epic. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Array of labels to be removed from the epic. */
  removeLabels?: InputMaybe<Array<Scalars['String']>>;
  /** Start date of the epic. */
  startDateFixed?: InputMaybe<Scalars['String']>;
  /** Indicates start date should be sourced from start_date_fixed field not the issue milestones. */
  startDateIsFixed?: InputMaybe<Scalars['Boolean']>;
  /** State event for the epic. */
  stateEvent?: InputMaybe<EpicStateEvent>;
  /** Title of the epic. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateEpic */
export type UpdateEpicPayload = {
  __typename?: 'UpdateEpicPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Epic after mutation. */
  epic?: Maybe<Epic>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateImageDiffNote */
export type UpdateImageDiffNoteInput = {
  /** Content of the note. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the note to update. */
  id: Scalars['NoteID'];
  /** Position of this note on a diff. */
  position?: InputMaybe<UpdateDiffImagePositionInput>;
};

/** Autogenerated return type of UpdateImageDiffNote */
export type UpdateImageDiffNotePayload = {
  __typename?: 'UpdateImageDiffNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of UpdateIssue */
export type UpdateIssueInput = {
  /** IDs of labels to be added to the issue. */
  addLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates the issue is confidential. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Description of the issue. */
  description?: InputMaybe<Scalars['String']>;
  /** Due date of the issue. */
  dueDate?: InputMaybe<Scalars['ISO8601Date']>;
  /** ID of the parent epic. NULL when removing the association. */
  epicId?: InputMaybe<Scalars['EpicID']>;
  /** Desired health status. */
  healthStatus?: InputMaybe<HealthStatus>;
  /** IID of the issue to mutate. */
  iid: Scalars['String'];
  /** IDs of labels to be set. Replaces existing issue labels. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Indicates discussion is locked on the issue. */
  locked?: InputMaybe<Scalars['Boolean']>;
  /** ID of the milestone to assign to the issue. On update milestone will be removed if set to null. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** Project the issue to mutate is in. */
  projectPath: Scalars['ID'];
  /** IDs of labels to be removed from the issue. */
  removeLabelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Close or reopen an issue. */
  stateEvent?: InputMaybe<IssueStateEvent>;
  /** Estimated time to complete the issue, or `0` to remove the current estimate. */
  timeEstimate?: InputMaybe<Scalars['String']>;
  /** Title of the issue. */
  title?: InputMaybe<Scalars['String']>;
  /** Type of the issue. */
  type?: InputMaybe<IssueType>;
  /** Weight of the issue. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateIssue */
export type UpdateIssuePayload = {
  __typename?: 'UpdateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Issue after mutation. */
  issue?: Maybe<Issue>;
};

/** Autogenerated input type of UpdateIteration */
export type UpdateIterationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']>;
  /** Group of the iteration. */
  groupPath: Scalars['ID'];
  /** Global ID of the iteration. */
  id: Scalars['ID'];
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIteration */
export type UpdateIterationPayload = {
  __typename?: 'UpdateIterationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated iteration. */
  iteration?: Maybe<Iteration>;
};

/** Autogenerated input type of UpdateNamespacePackageSettings */
export type UpdateNamespacePackageSettingsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * When generic_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  genericDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate generic packages are allowed for this namespace. */
  genericDuplicatesAllowed?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether Maven package forwarding is locked for all descendent namespaces. */
  lockMavenPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether npm package forwarding is locked for all descendent namespaces. */
  lockNpmPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether PyPI package forwarding is locked for all descendent namespaces. */
  lockPypiPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /**
   * When maven_duplicates_allowed is false, you can publish duplicate packages
   * with names that match this regex. Otherwise, this setting has no effect.
   */
  mavenDuplicateExceptionRegex?: InputMaybe<Scalars['UntrustedRegexp']>;
  /** Indicates whether duplicate Maven packages are allowed for this namespace. */
  mavenDuplicatesAllowed?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether Maven package forwarding is allowed for this namespace. */
  mavenPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Namespace path where the namespace package setting is located. */
  namespacePath: Scalars['ID'];
  /** Indicates whether npm package forwarding is allowed for this namespace. */
  npmPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
  /** Indicates whether PyPI package forwarding is allowed for this namespace. */
  pypiPackageRequestsForwarding?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateNamespacePackageSettings */
export type UpdateNamespacePackageSettingsPayload = {
  __typename?: 'UpdateNamespacePackageSettingsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Namespace package setting after mutation. */
  packageSettings?: Maybe<PackageSettings>;
};

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  /** Content of the note. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Confidentiality flag of a note. Default is false. Deprecated in 14.10: No
   * longer allowed to update confidentiality of notes.
   * @deprecated No longer allowed to update confidentiality of notes. Deprecated in 14.10.
   */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Global ID of the note to update. */
  id: Scalars['NoteID'];
};

/** Autogenerated return type of UpdateNote */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Note after mutation. */
  note?: Maybe<Note>;
};

/** Autogenerated input type of UpdatePackagesCleanupPolicy */
export type UpdatePackagesCleanupPolicyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Number of duplicated package files to retain. */
  keepNDuplicatedPackageFiles?: InputMaybe<PackagesCleanupKeepDuplicatedPackageFilesEnum>;
  /** Project path where the packages cleanup policy is located. */
  projectPath: Scalars['ID'];
};

/** Autogenerated return type of UpdatePackagesCleanupPolicy */
export type UpdatePackagesCleanupPolicyPayload = {
  __typename?: 'UpdatePackagesCleanupPolicyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Packages cleanup policy after mutation. */
  packagesCleanupPolicy?: Maybe<PackagesCleanupPolicy>;
};

/** Autogenerated input type of UpdateRequirement */
export type UpdateRequirementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the requirement. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * IID of the requirement to update. Deprecated in 15.8: Use work_item_iid instead.
   * @deprecated Use work_item_iid instead. Deprecated in 15.8.
   */
  iid?: InputMaybe<Scalars['String']>;
  /** Creates a test report for the requirement with the given state. */
  lastTestReportState?: InputMaybe<TestReportState>;
  /** Full project path the requirement is associated with. */
  projectPath: Scalars['ID'];
  /** State of the requirement. */
  state?: InputMaybe<RequirementState>;
  /** Title of the requirement. */
  title?: InputMaybe<Scalars['String']>;
  /** IID of the requirement work item to update. */
  workItemIid?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateRequirement */
export type UpdateRequirementPayload = {
  __typename?: 'UpdateRequirementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Requirement after mutation. */
  requirement?: Maybe<Requirement>;
};

/** Autogenerated input type of UpdateSnippet */
export type UpdateSnippetInput = {
  /** Actions to perform over the snippet repository and blobs. */
  blobActions?: InputMaybe<Array<SnippetBlobActionInputType>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the snippet. */
  description?: InputMaybe<Scalars['String']>;
  /** Global ID of the snippet to update. */
  id: Scalars['SnippetID'];
  /** Title of the snippet. */
  title?: InputMaybe<Scalars['String']>;
  /** Visibility level of the snippet. */
  visibilityLevel?: InputMaybe<VisibilityLevelsEnum>;
};

/** Autogenerated return type of UpdateSnippet */
export type UpdateSnippetPayload = {
  __typename?: 'UpdateSnippetPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Snippet after mutation. */
  snippet?: Maybe<Snippet>;
};

/** Autogenerated input type of UploadDelete */
export type UploadDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Upload filename. */
  filename: Scalars['String'];
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Secret part of upload path. */
  secret: Scalars['String'];
};

/** Autogenerated return type of UploadDelete */
export type UploadDeletePayload = {
  __typename?: 'UploadDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted upload. */
  upload?: Maybe<FileUpload>;
};

/** Represents the Geo replication and verification state of an upload. */
export type UploadRegistry = {
  __typename?: 'UploadRegistry';
  /** Timestamp when the UploadRegistry was created */
  createdAt?: Maybe<Scalars['Time']>;
  /** ID of the Upload. */
  fileId: Scalars['ID'];
  /** ID of the UploadRegistry */
  id: Scalars['ID'];
  /** Error message during sync of the UploadRegistry */
  lastSyncFailure?: Maybe<Scalars['String']>;
  /** Timestamp of the most recent successful sync of the UploadRegistry */
  lastSyncedAt?: Maybe<Scalars['Time']>;
  /** Timestamp after which the UploadRegistry is resynced */
  retryAt?: Maybe<Scalars['Time']>;
  /** Number of consecutive failed sync attempts of the UploadRegistry */
  retryCount?: Maybe<Scalars['Int']>;
  /** Sync state of the UploadRegistry */
  state?: Maybe<RegistryState>;
  /** Timestamp after which the UploadRegistry is reverified */
  verificationRetryAt?: Maybe<Scalars['Time']>;
  /** Timestamp of the most recent successful verification of the UploadRegistry */
  verifiedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for UploadRegistry. */
export type UploadRegistryConnection = {
  __typename?: 'UploadRegistryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UploadRegistryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UploadRegistry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UploadRegistryEdge = {
  __typename?: 'UploadRegistryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UploadRegistry>;
};

/** Represents a recorded measurement (object count) for the Admins */
export type UsageTrendsMeasurement = {
  __typename?: 'UsageTrendsMeasurement';
  /** Object count. */
  count: Scalars['Int'];
  /** Type of objects being measured. */
  identifier: MeasurementIdentifier;
  /** Time the measurement was recorded. */
  recordedAt?: Maybe<Scalars['Time']>;
};

/** The connection type for UsageTrendsMeasurement. */
export type UsageTrendsMeasurementConnection = {
  __typename?: 'UsageTrendsMeasurementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UsageTrendsMeasurementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UsageTrendsMeasurement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UsageTrendsMeasurementEdge = {
  __typename?: 'UsageTrendsMeasurementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UsageTrendsMeasurement>;
};

/** Representation of a GitLab user. */
export type User = {
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. Will not return saved reply if `saved_replies` feature flag is disabled. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Twitter username of the user. */
  twitter?: Maybe<Scalars['String']>;
  /**
   * Achievements for the user. Only returns for namespaces where the
   * `achievements` feature flag is enabled. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** Representation of a GitLab user. */
export type UserAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Representation of a GitLab user. */
export type UserAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Representation of a GitLab user. */
export type UserCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
};


/** Representation of a GitLab user. */
export type UserNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Representation of a GitLab user. */
export type UserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID'];
};


/** Representation of a GitLab user. */
export type UserSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** Representation of a GitLab user. */
export type UserStarredProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** Representation of a GitLab user. */
export type UserTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


/** Representation of a GitLab user. */
export type UserTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** Representation of a GitLab user. */
export type UserUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Representation of a GitLab user. */
export type UserWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

export type UserAchievement = {
  __typename?: 'UserAchievement';
  /** Achievement awarded. */
  achievement: Achievement;
  /** Awarded by. */
  awardedByUser: UserCore;
  /** Timestamp the achievement was created. */
  createdAt: Scalars['Time'];
  /** ID of the user achievement. */
  id: Scalars['AchievementsUserAchievementID'];
  /** Timestamp the achievement was revoked. */
  revokedAt?: Maybe<Scalars['Time']>;
  /** Revoked by. */
  revokedByUser?: Maybe<UserCore>;
  /** Timestamp the achievement was last updated. */
  updatedAt: Scalars['Time'];
  /** Achievement recipient. */
  user: UserCore;
};

/** The connection type for UserAchievement. */
export type UserAchievementConnection = {
  __typename?: 'UserAchievementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserAchievementEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserAchievement>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserAchievementEdge = {
  __typename?: 'UserAchievementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UserAchievement>;
};

/** Autogenerated input type of UserAchievementsDelete */
export type UserAchievementsDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the user achievement being deleted. */
  userAchievementId: Scalars['AchievementsUserAchievementID'];
};

/** Autogenerated return type of UserAchievementsDelete */
export type UserAchievementsDeletePayload = {
  __typename?: 'UserAchievementsDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Deleted user achievement. */
  userAchievement?: Maybe<UserAchievement>;
};

export type UserCallout = {
  __typename?: 'UserCallout';
  /** Date when the callout was dismissed. */
  dismissedAt?: Maybe<Scalars['Time']>;
  /** Name of the feature that the callout is for. */
  featureName?: Maybe<UserCalloutFeatureNameEnum>;
};

/** The connection type for UserCallout. */
export type UserCalloutConnection = {
  __typename?: 'UserCalloutConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCalloutEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserCallout>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of UserCalloutCreate */
export type UserCalloutCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Feature name you want to dismiss the callout for. */
  featureName: Scalars['String'];
};

/** Autogenerated return type of UserCalloutCreate */
export type UserCalloutCreatePayload = {
  __typename?: 'UserCalloutCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** User callout dismissed. */
  userCallout: UserCallout;
};

/** An edge in a connection. */
export type UserCalloutEdge = {
  __typename?: 'UserCalloutEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCallout>;
};

/** Name of the feature that the callout is for. */
export type UserCalloutFeatureNameEnum =
  /** Callout feature name for active_user_count_threshold. */
  | 'ACTIVE_USER_COUNT_THRESHOLD'
  /** Callout feature name for artifacts_management_page_feedback_banner. */
  | 'ARTIFACTS_MANAGEMENT_PAGE_FEEDBACK_BANNER'
  /** Callout feature name for branch_rules_info_callout. */
  | 'BRANCH_RULES_INFO_CALLOUT'
  /** Callout feature name for buy_pipeline_minutes_notification_dot. */
  | 'BUY_PIPELINE_MINUTES_NOTIFICATION_DOT'
  /** Callout feature name for canary_deployment. */
  | 'CANARY_DEPLOYMENT'
  /** Callout feature name for ci_deprecation_warning_for_types_keyword. */
  | 'CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD'
  /** Callout feature name for cloud_licensing_subscription_activation_banner. */
  | 'CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER'
  /** Callout feature name for cluster_security_warning. */
  | 'CLUSTER_SECURITY_WARNING'
  /** Callout feature name for code_suggestions_third_party_callout. */
  | 'CODE_SUGGESTIONS_THIRD_PARTY_CALLOUT'
  /** Callout feature name for create_runner_workflow_banner. */
  | 'CREATE_RUNNER_WORKFLOW_BANNER'
  /** Callout feature name for eoa_bronze_plan_banner. */
  | 'EOA_BRONZE_PLAN_BANNER'
  /** Callout feature name for feature_flags_new_version. */
  | 'FEATURE_FLAGS_NEW_VERSION'
  /** Callout feature name for gcp_signup_offer. */
  | 'GCP_SIGNUP_OFFER'
  /** Callout feature name for geo_enable_hashed_storage. */
  | 'GEO_ENABLE_HASHED_STORAGE'
  /** Callout feature name for geo_migrate_hashed_storage. */
  | 'GEO_MIGRATE_HASHED_STORAGE'
  /** Callout feature name for gke_cluster_integration. */
  | 'GKE_CLUSTER_INTEGRATION'
  /** Callout feature name for gold_trial_billings. */
  | 'GOLD_TRIAL_BILLINGS'
  /** Callout feature name for merge_request_settings_moved_callout. */
  | 'MERGE_REQUEST_SETTINGS_MOVED_CALLOUT'
  /** Callout feature name for mr_experience_survey. */
  | 'MR_EXPERIENCE_SURVEY'
  /** Callout feature name for namespace_over_storage_users_combined_alert. */
  | 'NAMESPACE_OVER_STORAGE_USERS_COMBINED_ALERT'
  /** Callout feature name for namespace_storage_limit_alert_alert_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_ALERT_THRESHOLD'
  /** Callout feature name for namespace_storage_limit_alert_error_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_ERROR_THRESHOLD'
  /** Callout feature name for namespace_storage_limit_alert_warning_threshold. */
  | 'NAMESPACE_STORAGE_LIMIT_ALERT_WARNING_THRESHOLD'
  /** Callout feature name for namespace_storage_pre_enforcement_banner. */
  | 'NAMESPACE_STORAGE_PRE_ENFORCEMENT_BANNER'
  /** Callout feature name for new_navigation_callout. */
  | 'NEW_NAVIGATION_CALLOUT'
  /** Callout feature name for new_top_level_group_alert. */
  | 'NEW_TOP_LEVEL_GROUP_ALERT'
  /** Callout feature name for new_user_signups_cap_reached. */
  | 'NEW_USER_SIGNUPS_CAP_REACHED'
  /** Callout feature name for personal_access_token_expiry. */
  | 'PERSONAL_ACCESS_TOKEN_EXPIRY'
  /** Callout feature name for personal_project_limitations_banner. */
  | 'PERSONAL_PROJECT_LIMITATIONS_BANNER'
  /** Callout feature name for pipeline_needs_banner. */
  | 'PIPELINE_NEEDS_BANNER'
  /** Callout feature name for pipeline_needs_hover_tip. */
  | 'PIPELINE_NEEDS_HOVER_TIP'
  /** Callout feature name for preview_user_over_limit_free_plan_alert. */
  | 'PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT'
  /** Callout feature name for profile_personal_access_token_expiry. */
  | 'PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY'
  /** Callout feature name for project_quality_summary_feedback. */
  | 'PROJECT_QUALITY_SUMMARY_FEEDBACK'
  /** Callout feature name for project_repository_limit_alert_alert_threshold. */
  | 'PROJECT_REPOSITORY_LIMIT_ALERT_ALERT_THRESHOLD'
  /** Callout feature name for project_repository_limit_alert_error_threshold. */
  | 'PROJECT_REPOSITORY_LIMIT_ALERT_ERROR_THRESHOLD'
  /** Callout feature name for project_repository_limit_alert_warning_threshold. */
  | 'PROJECT_REPOSITORY_LIMIT_ALERT_WARNING_THRESHOLD'
  /** Callout feature name for registration_enabled_callout. */
  | 'REGISTRATION_ENABLED_CALLOUT'
  /** Callout feature name for security_configuration_devops_alert. */
  | 'SECURITY_CONFIGURATION_DEVOPS_ALERT'
  /** Callout feature name for security_configuration_upgrade_banner. */
  | 'SECURITY_CONFIGURATION_UPGRADE_BANNER'
  /** Callout feature name for security_newsletter_callout. */
  | 'SECURITY_NEWSLETTER_CALLOUT'
  /** Callout feature name for security_training_feature_promotion. */
  | 'SECURITY_TRAINING_FEATURE_PROMOTION'
  /** Callout feature name for submit_license_usage_data_banner. */
  | 'SUBMIT_LICENSE_USAGE_DATA_BANNER'
  /** Callout feature name for suggest_pipeline. */
  | 'SUGGEST_PIPELINE'
  /** Callout feature name for suggest_popover_dismissed. */
  | 'SUGGEST_POPOVER_DISMISSED'
  /** Callout feature name for tabs_position_highlight. */
  | 'TABS_POSITION_HIGHLIGHT'
  /** Callout feature name for terraform_notification_dismissed. */
  | 'TERRAFORM_NOTIFICATION_DISMISSED'
  /** Callout feature name for threat_monitoring_info. */
  | 'THREAT_MONITORING_INFO'
  /** Callout feature name for trial_status_reminder_d3. */
  | 'TRIAL_STATUS_REMINDER_D3'
  /** Callout feature name for trial_status_reminder_d14. */
  | 'TRIAL_STATUS_REMINDER_D14'
  /** Callout feature name for two_factor_auth_recovery_settings_check. */
  | 'TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK'
  /** Callout feature name for ultimate_trial. */
  | 'ULTIMATE_TRIAL'
  /** Callout feature name for unfinished_tag_cleanup_callout. */
  | 'UNFINISHED_TAG_CLEANUP_CALLOUT'
  /** Callout feature name for user_reached_limit_free_plan_alert. */
  | 'USER_REACHED_LIMIT_FREE_PLAN_ALERT'
  /** Callout feature name for verification_reminder. */
  | 'VERIFICATION_REMINDER'
  /** Callout feature name for web_ide_alert_dismissed. */
  | 'WEB_IDE_ALERT_DISMISSED'
  /** Callout feature name for web_ide_ci_environments_guidance. */
  | 'WEB_IDE_CI_ENVIRONMENTS_GUIDANCE';

/** Core represention of a GitLab user. */
export type UserCore = User & {
  __typename?: 'UserCore';
  /** Merge requests assigned to the user. */
  assignedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Merge requests authored by the user. */
  authoredMergeRequests?: Maybe<MergeRequestConnection>;
  /** URL of the user's avatar. */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Bio of the user. */
  bio?: Maybe<Scalars['String']>;
  /** Indicates if the user is a bot. */
  bot: Scalars['Boolean'];
  /** User callouts that belong to the user. */
  callouts?: Maybe<UserCalloutConnection>;
  /** User's default commit email. */
  commitEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the user was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Discord ID of the user. */
  discord?: Maybe<Scalars['String']>;
  /**
   * User email. Deprecated in 13.7: This was renamed.
   * @deprecated This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.
   */
  email?: Maybe<Scalars['String']>;
  /** User's email addresses. */
  emails?: Maybe<EmailConnection>;
  /** Whether Gitpod is enabled at the user level. */
  gitpodEnabled?: Maybe<Scalars['Boolean']>;
  /** Group count for the user. */
  groupCount?: Maybe<Scalars['Int']>;
  /** Group memberships of the user. */
  groupMemberships?: Maybe<GroupMemberConnection>;
  /** Groups where the user has access. */
  groups?: Maybe<GroupConnection>;
  /** ID of the user. */
  id: Scalars['ID'];
  /** Job title of the user. */
  jobTitle?: Maybe<Scalars['String']>;
  /** LinkedIn profile name of the user. */
  linkedin?: Maybe<Scalars['String']>;
  /** Location of the user. */
  location?: Maybe<Scalars['String']>;
  /**
   * Human-readable name of the user. Returns `****` if the user is a project bot
   * and the requester does not have permission to view the project.
   */
  name: Scalars['String'];
  /** Personal namespace of the user. */
  namespace?: Maybe<Namespace>;
  /** User's custom namespace commit emails. */
  namespaceCommitEmails?: Maybe<NamespaceCommitEmailConnection>;
  /** Who the user represents or works for. */
  organization?: Maybe<Scalars['String']>;
  /** Web path to the Gitpod section within user preferences. */
  preferencesGitpodPath?: Maybe<Scalars['String']>;
  /** Web path to enable Gitpod for the user. */
  profileEnableGitpodPath?: Maybe<Scalars['String']>;
  /** Project memberships of the user. */
  projectMemberships?: Maybe<ProjectMemberConnection>;
  /** User's public email. */
  publicEmail?: Maybe<Scalars['String']>;
  /** Merge requests assigned to the user for review. */
  reviewRequestedMergeRequests?: Maybe<MergeRequestConnection>;
  /** Saved replies authored by the user. Will not return saved replies if `saved_replies` feature flag is disabled. */
  savedReplies?: Maybe<SavedReplyConnection>;
  /** Saved reply authored by the user. Will not return saved reply if `saved_replies` feature flag is disabled. */
  savedReply?: Maybe<SavedReply>;
  /** Snippets authored by the user. */
  snippets?: Maybe<SnippetConnection>;
  /** Projects starred by the user. */
  starredProjects?: Maybe<ProjectConnection>;
  /** State of the user. */
  state: UserState;
  /** User status. */
  status?: Maybe<UserStatus>;
  /** Time logged by the user. */
  timelogs?: Maybe<TimelogConnection>;
  /** To-do items of the user. */
  todos?: Maybe<TodoConnection>;
  /** Twitter username of the user. */
  twitter?: Maybe<Scalars['String']>;
  /**
   * Achievements for the user. Only returns for namespaces where the
   * `achievements` feature flag is enabled. Introduced in 15.10: This feature is
   * an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  userAchievements?: Maybe<UserAchievementConnection>;
  /** Permissions for the current user on the resource. */
  userPermissions: UserPermissions;
  /** Username of the user. Unique within this instance of GitLab. */
  username: Scalars['String'];
  /** Web path of the user. */
  webPath: Scalars['String'];
  /** Web URL of the user. */
  webUrl: Scalars['String'];
  /** Workspaces owned by the current user. */
  workspaces?: Maybe<WorkspaceConnection>;
};


/** Core represention of a GitLab user. */
export type UserCoreAssignedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Core represention of a GitLab user. */
export type UserCoreAuthoredMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  reviewerUsername?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Core represention of a GitLab user. */
export type UserCoreCalloutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreGroupMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  permissionScope?: InputMaybe<GroupPermission>;
  search?: InputMaybe<Scalars['String']>;
};


/** Core represention of a GitLab user. */
export type UserCoreNamespaceCommitEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreProjectMembershipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreReviewRequestedMergeRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  approved?: InputMaybe<Scalars['Boolean']>;
  assigneeUsername?: InputMaybe<Scalars['String']>;
  authorUsername?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdAfter?: InputMaybe<Scalars['Time']>;
  createdBefore?: InputMaybe<Scalars['Time']>;
  draft?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  iids?: InputMaybe<Array<Scalars['String']>>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  mergedAfter?: InputMaybe<Scalars['Time']>;
  mergedBefore?: InputMaybe<Scalars['Time']>;
  milestoneTitle?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<MergeRequestsResolverNegatedParams>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  projectPath?: InputMaybe<Scalars['String']>;
  sort?: InputMaybe<MergeRequestSort>;
  sourceBranches?: InputMaybe<Array<Scalars['String']>>;
  state?: InputMaybe<MergeRequestState>;
  targetBranches?: InputMaybe<Array<Scalars['String']>>;
  updatedAfter?: InputMaybe<Scalars['Time']>;
  updatedBefore?: InputMaybe<Scalars['Time']>;
};


/** Core represention of a GitLab user. */
export type UserCoreSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreSavedReplyArgs = {
  id: Scalars['UsersSavedReplyID'];
};


/** Core represention of a GitLab user. */
export type UserCoreSnippetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['SnippetID']>>;
  last?: InputMaybe<Scalars['Int']>;
  type?: InputMaybe<TypeEnum>;
  visibility?: InputMaybe<VisibilityScopesEnum>;
};


/** Core represention of a GitLab user. */
export type UserCoreStarredProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  search?: InputMaybe<Scalars['String']>;
};


/** Core represention of a GitLab user. */
export type UserCoreTimelogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['Time']>;
  endTime?: InputMaybe<Scalars['Time']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['GroupID']>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Scalars['ProjectID']>;
  sort?: InputMaybe<TimelogSort>;
  startDate?: InputMaybe<Scalars['Time']>;
  startTime?: InputMaybe<Scalars['Time']>;
  username?: InputMaybe<Scalars['String']>;
};


/** Core represention of a GitLab user. */
export type UserCoreTodosArgs = {
  action?: InputMaybe<Array<TodoActionEnum>>;
  after?: InputMaybe<Scalars['String']>;
  authorId?: InputMaybe<Array<Scalars['ID']>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectId?: InputMaybe<Array<Scalars['ID']>>;
  state?: InputMaybe<Array<TodoStateEnum>>;
  type?: InputMaybe<Array<TodoTargetEnum>>;
};


/** Core represention of a GitLab user. */
export type UserCoreUserAchievementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Core represention of a GitLab user. */
export type UserCoreWorkspacesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['RemoteDevelopmentWorkspaceID']>>;
  includeActualStates?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  projectIds?: InputMaybe<Array<Scalars['ProjectID']>>;
};

/** The connection type for UserCore. */
export type UserCoreConnection = {
  __typename?: 'UserCoreConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCoreEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserCore>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserCoreEdge = {
  __typename?: 'UserCoreEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCore>;
};

/**
 * Information about a merge request given a specific user.
 *
 * This object has two parts to its state: a `User` and a `MergeRequest`. All
 * fields relate to interactions between the two entities.
 */
export type UserMergeRequestInteraction = {
  __typename?: 'UserMergeRequestInteraction';
  /** Approval rules that apply to this user for this merge request. */
  applicableApprovalRules?: Maybe<Array<ApprovalRule>>;
  /** Whether this user has approved this merge request. */
  approved: Scalars['Boolean'];
  /** Whether this user can merge this merge request. */
  canMerge: Scalars['Boolean'];
  /** Whether this user can update this merge request. */
  canUpdate: Scalars['Boolean'];
  /** State of the review by this user. */
  reviewState?: Maybe<MergeRequestReviewState>;
  /** Whether this user has provided a review for this merge request. */
  reviewed: Scalars['Boolean'];
};

export type UserPermissions = {
  __typename?: 'UserPermissions';
  /** Indicates the user can perform `create_snippet` on this resource */
  createSnippet: Scalars['Boolean'];
};

export type UserPreferences = {
  __typename?: 'UserPreferences';
  /** Sort order for issue lists. */
  issuesSort?: Maybe<IssueSort>;
  /** Determines whether the pipeline list shows ID or IID. */
  visibilityPipelineIdType?: Maybe<VisibilityPipelineIdType>;
};

/** Autogenerated input type of UserPreferencesUpdate */
export type UserPreferencesUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Sort order for issue lists. */
  issuesSort?: InputMaybe<IssueSort>;
  /** Determines whether the pipeline list shows ID or IID. */
  visibilityPipelineIdType?: InputMaybe<VisibilityPipelineIdType>;
};

/** Autogenerated return type of UserPreferencesUpdate */
export type UserPreferencesUpdatePayload = {
  __typename?: 'UserPreferencesUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** User preferences after mutation. */
  userPreferences?: Maybe<UserPreferences>;
};

/** Autogenerated input type of UserSetNamespaceCommitEmail */
export type UserSetNamespaceCommitEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the email to set. */
  emailId?: InputMaybe<Scalars['EmailID']>;
  /** ID of the namespace to set the namespace commit email for. */
  namespaceId: Scalars['NamespaceID'];
};

/** Autogenerated return type of UserSetNamespaceCommitEmail */
export type UserSetNamespaceCommitEmailPayload = {
  __typename?: 'UserSetNamespaceCommitEmailPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** User namespace commit email after mutation. */
  namespaceCommitEmail?: Maybe<NamespaceCommitEmail>;
};

/** Possible states of a user */
export type UserState =
  /** User is active and is able to use the system. */
  | 'active'
  /** User has been blocked and is prevented from using the system. */
  | 'blocked'
  /** User is no longer active and is unable to use the system. */
  | 'deactivated';

export type UserStatus = {
  __typename?: 'UserStatus';
  /** User availability status. */
  availability: AvailabilityEnum;
  /** String representation of emoji. */
  emoji?: Maybe<Scalars['String']>;
  /** User status message. */
  message?: Maybe<Scalars['String']>;
  /** HTML of the user status message */
  messageHtml?: Maybe<Scalars['String']>;
};

export type ValueStreamAnalyticsMetric = {
  __typename?: 'ValueStreamAnalyticsMetric';
  /** Identifier for the metric. */
  identifier: Scalars['String'];
  /** Optional links for drilling down. */
  links: Array<ValueStreamMetricLinkType>;
  /** Title for the metric. */
  title: Scalars['String'];
  /** Unit of measurement. */
  unit?: Maybe<Scalars['String']>;
  /** Value for the metric. */
  value?: Maybe<Scalars['Float']>;
};

export type ValueStreamMetricLinkType = {
  __typename?: 'ValueStreamMetricLinkType';
  /** Link to the metric documentation. */
  docsLink?: Maybe<Scalars['Boolean']>;
  /** Label for the link. */
  label: Scalars['String'];
  /** Name of the link group. */
  name: Scalars['String'];
  /** Drill-down URL. */
  url: Scalars['String'];
};

export type VerificationStateEnum =
  /** Verification process is disabled. */
  | 'DISABLED'
  /** Verification process finished but failed. */
  | 'FAILED'
  /** Verification process has not started. */
  | 'PENDING'
  /** Verification process is in progress. */
  | 'STARTED'
  /** Verification process finished successfully. */
  | 'SUCCEEDED';

/** Verification status of a GPG or X.509 signature for a commit. */
export type VerificationStatus =
  /** multiple_signatures verification status. */
  | 'MULTIPLE_SIGNATURES'
  /** other_user verification status. */
  | 'OTHER_USER'
  /** revoked_key verification status. */
  | 'REVOKED_KEY'
  /** same_user_different_email verification status. */
  | 'SAME_USER_DIFFERENT_EMAIL'
  /** unknown_key verification status. */
  | 'UNKNOWN_KEY'
  /** unverified verification status. */
  | 'UNVERIFIED'
  /** unverified_key verification status. */
  | 'UNVERIFIED_KEY'
  /** verified verification status. */
  | 'VERIFIED';

export type VisibilityLevelsEnum =
  /** Internal visibility level. */
  | 'internal'
  /** Private visibility level. */
  | 'private'
  /** Public visibility level. */
  | 'public';

/** Determines whether the pipeline list shows ID or IID */
export type VisibilityPipelineIdType =
  /** Display pipeline ID. */
  | 'ID'
  /** Display pipeline IID. */
  | 'IID';

export type VisibilityScopesEnum =
  /** Snippet is visible for any logged in user except external users. */
  | 'internal'
  /** Snippet is visible only to the snippet creator. */
  | 'private'
  /** Snippet can be accessed without any authentication. */
  | 'public';

/** Represents the count of vulnerabilities by severity on a particular day. This data is retained for 365 days */
export type VulnerabilitiesCountByDay = {
  __typename?: 'VulnerabilitiesCountByDay';
  /** Total number of vulnerabilities on a particular day with critical severity */
  critical: Scalars['Int'];
  /** Date for the count. */
  date: Scalars['ISO8601Date'];
  /** Total number of vulnerabilities on a particular day with high severity */
  high: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with info severity */
  info: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with low severity */
  low: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with medium severity */
  medium: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day. */
  total: Scalars['Int'];
  /** Total number of vulnerabilities on a particular day with unknown severity */
  unknown: Scalars['Int'];
};

/** The connection type for VulnerabilitiesCountByDay. */
export type VulnerabilitiesCountByDayConnection = {
  __typename?: 'VulnerabilitiesCountByDayConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilitiesCountByDayEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilitiesCountByDay>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilitiesCountByDayEdge = {
  __typename?: 'VulnerabilitiesCountByDayEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilitiesCountByDay>;
};

/** Represents a vulnerability */
export type Vulnerability = NoteableInterface & {
  __typename?: 'Vulnerability';
  /** All commenters on this noteable. */
  commenters: UserCoreConnection;
  /** Timestamp of when the vulnerability state was changed to confirmed. */
  confirmedAt?: Maybe<Scalars['Time']>;
  /** User that confirmed the vulnerability. */
  confirmedBy?: Maybe<UserCore>;
  /** Description of the vulnerability. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Details of the vulnerability. */
  details: Array<VulnerabilityDetail>;
  /** Timestamp of when the vulnerability was first detected. */
  detectedAt: Scalars['Time'];
  /** All discussions on this noteable. */
  discussions: DiscussionConnection;
  /** Reason for dismissal. Returns `null` if `expose_dismissal_reason`feature flag is disabled. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** Timestamp of when the vulnerability state was changed to dismissed. */
  dismissedAt?: Maybe<Scalars['Time']>;
  /** User that dismissed the vulnerability. */
  dismissedBy?: Maybe<UserCore>;
  /** List of external issue links related to the vulnerability. */
  externalIssueLinks: VulnerabilityExternalIssueLinkConnection;
  /** Indicates whether the vulnerability is a false positive. */
  falsePositive?: Maybe<Scalars['Boolean']>;
  /** Indicates whether there is a solution available for this vulnerability. */
  hasSolutions?: Maybe<Scalars['Boolean']>;
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID'];
  /** Identifiers of the vulnerability. */
  identifiers: Array<VulnerabilityIdentifier>;
  /** List of issue links related to the vulnerability. */
  issueLinks: VulnerabilityIssueLinkConnection;
  /** List of links associated with the vulnerability. */
  links: Array<VulnerabilityLink>;
  /** Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability. */
  location?: Maybe<VulnerabilityLocation>;
  /** Merge request that fixes the vulnerability. */
  mergeRequest?: Maybe<MergeRequest>;
  /**
   * From 16.1 this field always returns null. Deprecated in 16.1: message field has been removed from security reports schema.
   * @deprecated message field has been removed from security reports schema. Deprecated in 16.1.
   */
  message?: Maybe<Scalars['String']>;
  /** All notes on this noteable. */
  notes: NoteConnection;
  /** Primary identifier of the vulnerability. */
  primaryIdentifier?: Maybe<VulnerabilityIdentifier>;
  /** Project on which the vulnerability was found. */
  project?: Maybe<Project>;
  /**
   * Type of the security report that found the vulnerability (SAST,
   * DEPENDENCY_SCANNING, CONTAINER_SCANNING, DAST, SECRET_DETECTION,
   * COVERAGE_FUZZING, API_FUZZING, CLUSTER_IMAGE_SCANNING, GENERIC). `Scan Type` in the UI.
   */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Timestamp of when the vulnerability state was changed to resolved. */
  resolvedAt?: Maybe<Scalars['Time']>;
  /** User that resolved the vulnerability. */
  resolvedBy?: Maybe<UserCore>;
  /** Indicates whether the vulnerability is fixed on the default branch or not. */
  resolvedOnDefaultBranch: Scalars['Boolean'];
  /** Scanner metadata for the vulnerability. */
  scanner?: Maybe<VulnerabilityScanner>;
  /** Severity of the vulnerability (INFO, UNKNOWN, LOW, MEDIUM, HIGH, CRITICAL) */
  severity?: Maybe<VulnerabilitySeverity>;
  /** State of the vulnerability (DETECTED, CONFIRMED, RESOLVED, DISMISSED) */
  state?: Maybe<VulnerabilityState>;
  /** Comment given for the vulnerability state change. */
  stateComment?: Maybe<Scalars['String']>;
  /** List of state transitions related to the vulnerability. */
  stateTransitions?: Maybe<VulnerabilityStateTransitionTypeConnection>;
  /** Title of the vulnerability. */
  title?: Maybe<Scalars['String']>;
  /** Timestamp of when the vulnerability was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
  /** Number of user notes attached to the vulnerability. */
  userNotesCount: Scalars['Int'];
  /** Permissions for the current user on the resource */
  userPermissions: VulnerabilityPermissions;
  /** Path to the vulnerability's details page. */
  vulnerabilityPath?: Maybe<Scalars['String']>;
  /** URL to the vulnerability's details page. */
  webUrl?: Maybe<Scalars['String']>;
};


/** Represents a vulnerability */
export type VulnerabilityCommentersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityExternalIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityIssueLinksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  linkType?: InputMaybe<VulnerabilityIssueLinkType>;
};


/** Represents a vulnerability */
export type VulnerabilityNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a vulnerability */
export type VulnerabilityStateTransitionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Confidence that a given vulnerability is present in the codebase. */
export type VulnerabilityConfidence =
  /** Confirmed confidence */
  | 'CONFIRMED'
  /** Experimental confidence */
  | 'EXPERIMENTAL'
  /** High confidence */
  | 'HIGH'
  /** Ignore confidence */
  | 'IGNORE'
  /** Low confidence */
  | 'LOW'
  /** Medium confidence */
  | 'MEDIUM'
  /** Unknown confidence */
  | 'UNKNOWN';

/** Autogenerated input type of VulnerabilityConfirm */
export type VulnerabilityConfirmInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Comment why vulnerability was confirmed (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be confirmed. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityConfirm */
export type VulnerabilityConfirmPayload = {
  __typename?: 'VulnerabilityConfirmPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** The connection type for Vulnerability. */
export type VulnerabilityConnection = {
  __typename?: 'VulnerabilityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Vulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Represents a container image reported on the related vulnerability */
export type VulnerabilityContainerImage = {
  __typename?: 'VulnerabilityContainerImage';
  /** Name of the container image. */
  name?: Maybe<Scalars['String']>;
};

/** The connection type for VulnerabilityContainerImage. */
export type VulnerabilityContainerImageConnection = {
  __typename?: 'VulnerabilityContainerImageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityContainerImageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityContainerImage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityContainerImageEdge = {
  __typename?: 'VulnerabilityContainerImageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityContainerImage>;
};

/** Autogenerated input type of VulnerabilityCreate */
export type VulnerabilityCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Confidence of the vulnerability (defaults to `unknown`). Deprecated in 15.4:
   * This field will be removed from the Vulnerability domain model.
   * @deprecated This field will be removed from the Vulnerability domain model. Deprecated in 15.4.
   */
  confidence?: InputMaybe<VulnerabilityConfidence>;
  /** Timestamp of when the vulnerability state changed to confirmed (defaults to creation time if status is `confirmed`). */
  confirmedAt?: InputMaybe<Scalars['Time']>;
  /** Long text section that describes the vulnerability in more detail. */
  description: Scalars['String'];
  /** Timestamp of when the vulnerability was first detected (defaults to creation time). */
  detectedAt?: InputMaybe<Scalars['Time']>;
  /** Timestamp of when the vulnerability state changed to dismissed (defaults to creation time if status is `dismissed`). */
  dismissedAt?: InputMaybe<Scalars['Time']>;
  /** Array of CVE or CWE identifiers for the vulnerability. */
  identifiers: Array<VulnerabilityIdentifierInput>;
  /**
   * Short text section that describes the vulnerability. This may include the
   * finding's specific information. Deprecated in 16.1: message field has been
   * removed from security reports schema.
   * @deprecated message field has been removed from security reports schema. Deprecated in 16.1.
   */
  message?: InputMaybe<Scalars['String']>;
  /** Name of the vulnerability. */
  name: Scalars['String'];
  /** ID of the project to attach the vulnerability to. */
  project: Scalars['ProjectID'];
  /** Timestamp of when the vulnerability state changed to resolved (defaults to creation time if status is `resolved`). */
  resolvedAt?: InputMaybe<Scalars['Time']>;
  /** Information about the scanner used to discover the vulnerability. */
  scanner: VulnerabilityScannerInput;
  /** Severity of the vulnerability (defaults to `unknown`). */
  severity?: InputMaybe<VulnerabilitySeverity>;
  /** Instructions for how to fix the vulnerability. */
  solution?: InputMaybe<Scalars['String']>;
  /** State of the vulnerability (defaults to `detected`). */
  state?: InputMaybe<VulnerabilityState>;
};

/** Autogenerated return type of VulnerabilityCreate */
export type VulnerabilityCreatePayload = {
  __typename?: 'VulnerabilityCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability created. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability detail field. The fields with data will depend on the vulnerability detail type */
export type VulnerabilityDetail = VulnerabilityDetailBase | VulnerabilityDetailBoolean | VulnerabilityDetailCode | VulnerabilityDetailCommit | VulnerabilityDetailDiff | VulnerabilityDetailFileLocation | VulnerabilityDetailInt | VulnerabilityDetailList | VulnerabilityDetailMarkdown | VulnerabilityDetailModuleLocation | VulnerabilityDetailNamedList | VulnerabilityDetailTable | VulnerabilityDetailText | VulnerabilityDetailUrl;

/** Represents the vulnerability details base */
export type VulnerabilityDetailBase = {
  __typename?: 'VulnerabilityDetailBase';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details boolean value */
export type VulnerabilityDetailBoolean = {
  __typename?: 'VulnerabilityDetailBoolean';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the field. */
  value: Scalars['Boolean'];
};

/** Represents the vulnerability details code field */
export type VulnerabilityDetailCode = {
  __typename?: 'VulnerabilityDetailCode';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Language of the code. */
  lang?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Source code. */
  value: Scalars['String'];
};

/** Represents the vulnerability details commit field */
export type VulnerabilityDetailCommit = {
  __typename?: 'VulnerabilityDetailCommit';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Commit SHA value. */
  value: Scalars['String'];
};

/** Represents the vulnerability details diff field */
export type VulnerabilityDetailDiff = {
  __typename?: 'VulnerabilityDetailDiff';
  /** Value of the field after the change. */
  after: Scalars['String'];
  /** Value of the field before the change. */
  before: Scalars['String'];
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details location within a file in the project */
export type VulnerabilityDetailFileLocation = {
  __typename?: 'VulnerabilityDetailFileLocation';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** File name. */
  fileName: Scalars['String'];
  /** End line number of the file location. */
  lineEnd: Scalars['Int'];
  /** Start line number of the file location. */
  lineStart: Scalars['Int'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details integer value */
export type VulnerabilityDetailInt = {
  __typename?: 'VulnerabilityDetailInt';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the field. */
  value: Scalars['Int'];
};

/** Represents the vulnerability details list value */
export type VulnerabilityDetailList = {
  __typename?: 'VulnerabilityDetailList';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** List of details. */
  items: Array<VulnerabilityDetail>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details Markdown field */
export type VulnerabilityDetailMarkdown = {
  __typename?: 'VulnerabilityDetailMarkdown';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the Markdown field. */
  value: Scalars['String'];
};

/** Represents the vulnerability details location within a file in the project */
export type VulnerabilityDetailModuleLocation = {
  __typename?: 'VulnerabilityDetailModuleLocation';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Module name. */
  moduleName: Scalars['String'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Offset of the module location. */
  offset: Scalars['Int'];
};

/** Represents the vulnerability details named list */
export type VulnerabilityDetailNamedList = {
  __typename?: 'VulnerabilityDetailNamedList';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /**
   * Named list of details. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  items: Array<VulnerabilityDetailNamedListItem>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
};

/** Represents the vulnerability details named list item */
export type VulnerabilityDetailNamedListItem = {
  __typename?: 'VulnerabilityDetailNamedListItem';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /**
   * Value of the field. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.
   */
  value: VulnerabilityDetail;
};

/** Represents an individual row in a table */
export type VulnerabilityDetailRow = {
  __typename?: 'VulnerabilityDetailRow';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the field. */
  row: Array<VulnerabilityDetail>;
};

/** Represents the vulnerability details table value */
export type VulnerabilityDetailTable = {
  __typename?: 'VulnerabilityDetailTable';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Table headers. */
  headers: Array<VulnerabilityDetail>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Table rows. */
  rows: Array<VulnerabilityDetailRow>;
};

/** Represents the vulnerability details text field */
export type VulnerabilityDetailText = {
  __typename?: 'VulnerabilityDetailText';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Value of the text field. */
  value: Scalars['String'];
};

/** Represents the vulnerability details URL field */
export type VulnerabilityDetailUrl = {
  __typename?: 'VulnerabilityDetailUrl';
  /** Description of the field. */
  description?: Maybe<Scalars['String']>;
  /** Name of the field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Href of the URL. */
  href: Scalars['String'];
  /** Name of the field. */
  name?: Maybe<Scalars['String']>;
  /** Text of the URL. */
  text?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of VulnerabilityDismiss */
export type VulnerabilityDismissInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Comment why vulnerability was dismissed (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']>;
  /** Reason why vulnerability should be dismissed. */
  dismissalReason?: InputMaybe<VulnerabilityDismissalReason>;
  /** ID of the vulnerability to be dismissed. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityDismiss */
export type VulnerabilityDismissPayload = {
  __typename?: 'VulnerabilityDismissPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** The dismissal reason of the Vulnerability */
export type VulnerabilityDismissalReason =
  /** The vulnerability is known, and has not been remediated or mitigated, but is considered to be an acceptable business risk. */
  | 'ACCEPTABLE_RISK'
  /**
   * An error in reporting in which a test result incorrectly indicates the
   * presence of a vulnerability in a system when the vulnerability is not present.
   */
  | 'FALSE_POSITIVE'
  /**
   * A management, operational, or technical control (that is, safeguard or
   * countermeasure) employed by an organization that provides equivalent or
   * comparable protection for an information system.
   */
  | 'MITIGATING_CONTROL'
  /**
   * The vulnerability is known, and has not been remediated or mitigated, but is
   * considered to be in a part of the application that will not be updated.
   */
  | 'NOT_APPLICABLE'
  /** The finding is not a vulnerability because it is part of a test or is test data. */
  | 'USED_IN_TESTS';

/** An edge in a connection. */
export type VulnerabilityEdge = {
  __typename?: 'VulnerabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Vulnerability>;
};

/** Represents a Vulnerability Evidence */
export type VulnerabilityEvidence = {
  __typename?: 'VulnerabilityEvidence';
  /** HTTP request of the Vulnerability Evidence. */
  request?: Maybe<VulnerabilityRequest>;
  /** HTTP response of the Vulnerability Evidence. */
  response?: Maybe<VulnerabilityResponse>;
  /** Source of the Vulnerability Evidence. */
  source?: Maybe<VulnerabilityEvidenceSource>;
  /** Summary of the Vulnerability Evidence. */
  summary?: Maybe<Scalars['String']>;
  /** Supporting messages of the Vulnerability Evidence. */
  supportingMessages?: Maybe<Array<VulnerabilityEvidenceSupportingMessage>>;
};

/** Represents a vulnerability evidence */
export type VulnerabilityEvidenceSource = {
  __typename?: 'VulnerabilityEvidenceSource';
  /** ID of the Vulnerability Evidence Source. */
  identifier: Scalars['String'];
  /** Name of the Vulnerability Evidence Source. */
  name: Scalars['String'];
  /** URL of the Vulnerability Evidence Source. */
  url?: Maybe<Scalars['String']>;
};

/** Represents a vulnerability evidence supporting message */
export type VulnerabilityEvidenceSupportingMessage = {
  __typename?: 'VulnerabilityEvidenceSupportingMessage';
  /** Name of the vulnerability supporting message. */
  name: Scalars['String'];
  /** HTTP request of the vulnerability evidence supporting message. */
  request?: Maybe<VulnerabilityRequest>;
  /** HTTP response of the vulnerability evidence supporting message. */
  response?: Maybe<VulnerabilityResponse>;
};

/** Represents an external issue link of a vulnerability */
export type VulnerabilityExternalIssueLink = {
  __typename?: 'VulnerabilityExternalIssueLink';
  /** The external issue attached to the issue link. */
  externalIssue?: Maybe<ExternalIssue>;
  /** GraphQL ID of the external issue link. */
  id: Scalars['VulnerabilitiesExternalIssueLinkID'];
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
};

/** The connection type for VulnerabilityExternalIssueLink. */
export type VulnerabilityExternalIssueLinkConnection = {
  __typename?: 'VulnerabilityExternalIssueLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityExternalIssueLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityExternalIssueLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of VulnerabilityExternalIssueLinkCreate */
export type VulnerabilityExternalIssueLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** External tracker type of the external issue link. */
  externalTracker: VulnerabilityExternalIssueLinkExternalTracker;
  /** ID of the vulnerability. */
  id: Scalars['VulnerabilityID'];
  /** Type of the external issue link. */
  linkType: VulnerabilityExternalIssueLinkType;
};

/** Autogenerated return type of VulnerabilityExternalIssueLinkCreate */
export type VulnerabilityExternalIssueLinkCreatePayload = {
  __typename?: 'VulnerabilityExternalIssueLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created external issue link. */
  externalIssueLink?: Maybe<VulnerabilityExternalIssueLink>;
};

/** Autogenerated input type of VulnerabilityExternalIssueLinkDestroy */
export type VulnerabilityExternalIssueLinkDestroyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the vulnerability external issue link. */
  id: Scalars['VulnerabilitiesExternalIssueLinkID'];
};

/** Autogenerated return type of VulnerabilityExternalIssueLinkDestroy */
export type VulnerabilityExternalIssueLinkDestroyPayload = {
  __typename?: 'VulnerabilityExternalIssueLinkDestroyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
};

/** An edge in a connection. */
export type VulnerabilityExternalIssueLinkEdge = {
  __typename?: 'VulnerabilityExternalIssueLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityExternalIssueLink>;
};

/** The external tracker of the external issue link related to a vulnerability */
export type VulnerabilityExternalIssueLinkExternalTracker =
  /** Jira external tracker */
  | 'JIRA';

/** The type of the external issue link related to a vulnerability */
export type VulnerabilityExternalIssueLinkType =
  /** Created link type. */
  | 'CREATED';

/** The grade of the vulnerable project */
export type VulnerabilityGrade =
  /** A grade */
  | 'A'
  /** B grade */
  | 'B'
  /** C grade */
  | 'C'
  /** D grade */
  | 'D'
  /** F grade */
  | 'F';

/** Represents a vulnerability identifier */
export type VulnerabilityIdentifier = {
  __typename?: 'VulnerabilityIdentifier';
  /** External ID of the vulnerability identifier. */
  externalId?: Maybe<Scalars['String']>;
  /** External type of the vulnerability identifier. */
  externalType?: Maybe<Scalars['String']>;
  /** Name of the vulnerability identifier. */
  name?: Maybe<Scalars['String']>;
  /** URL of the vulnerability identifier. */
  url?: Maybe<Scalars['String']>;
};

export type VulnerabilityIdentifierInput = {
  /** External ID of the vulnerability identifier. */
  externalId?: InputMaybe<Scalars['String']>;
  /** External type of the vulnerability identifier. */
  externalType?: InputMaybe<Scalars['String']>;
  /** Name of the vulnerability identifier. */
  name: Scalars['String'];
  /** URL of the vulnerability identifier. */
  url: Scalars['String'];
};

/** Represents an issue link of a vulnerability */
export type VulnerabilityIssueLink = {
  __typename?: 'VulnerabilityIssueLink';
  /** GraphQL ID of the vulnerability. */
  id: Scalars['ID'];
  /** Issue attached to issue link. */
  issue?: Maybe<Issue>;
  /** Type of the issue link. */
  linkType: VulnerabilityIssueLinkType;
};

/** The connection type for VulnerabilityIssueLink. */
export type VulnerabilityIssueLinkConnection = {
  __typename?: 'VulnerabilityIssueLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityIssueLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityIssueLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of VulnerabilityIssueLinkCreate */
export type VulnerabilityIssueLinkCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue to link to. */
  issueId: Scalars['IssueID'];
  /** IDs of vulnerabilities to link to the given issue.  Up to 100 can be provided. */
  vulnerabilityIds: Array<Scalars['VulnerabilityID']>;
};

/** Autogenerated return type of VulnerabilityIssueLinkCreate */
export type VulnerabilityIssueLinkCreatePayload = {
  __typename?: 'VulnerabilityIssueLinkCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created issue links. */
  issueLinks?: Maybe<Array<VulnerabilityIssueLink>>;
};

/** An edge in a connection. */
export type VulnerabilityIssueLinkEdge = {
  __typename?: 'VulnerabilityIssueLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityIssueLink>;
};

/** The type of the issue link related to a vulnerability */
export type VulnerabilityIssueLinkType =
  /** Issue is created for the vulnerability */
  | 'CREATED'
  /** Has a related issue */
  | 'RELATED';

/** Represents a link related to a vulnerability */
export type VulnerabilityLink = {
  __typename?: 'VulnerabilityLink';
  /** Name of the link. */
  name?: Maybe<Scalars['String']>;
  /** URL of the link. */
  url: Scalars['String'];
};

/** Represents a vulnerability location. The fields with data will depend on the vulnerability report type */
export type VulnerabilityLocation = VulnerabilityLocationClusterImageScanning | VulnerabilityLocationContainerScanning | VulnerabilityLocationCoverageFuzzing | VulnerabilityLocationDast | VulnerabilityLocationDependencyScanning | VulnerabilityLocationGeneric | VulnerabilityLocationSast | VulnerabilityLocationSecretDetection;

/** Represents the location of a vulnerability found by a cluster image scan */
export type VulnerabilityLocationClusterImageScanning = {
  __typename?: 'VulnerabilityLocationClusterImageScanning';
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Name of the vulnerable container image. */
  image?: Maybe<Scalars['String']>;
  /** Kubernetes resource which uses the vulnerable container image. */
  kubernetesResource?: Maybe<VulnerableKubernetesResource>;
  /** Operating system that runs on the vulnerable container image. */
  operatingSystem?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a container security scan */
export type VulnerabilityLocationContainerScanning = {
  __typename?: 'VulnerabilityLocationContainerScanning';
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Name of the vulnerable container image. */
  image?: Maybe<Scalars['String']>;
  /** Operating system that runs on the vulnerable container image. */
  operatingSystem?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a Coverage Fuzzing scan */
export type VulnerabilityLocationCoverageFuzzing = {
  __typename?: 'VulnerabilityLocationCoverageFuzzing';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Relative address in memory were the crash occurred. */
  crashAddress?: Maybe<Scalars['String']>;
  /** Type of the crash. */
  crashType?: Maybe<Scalars['String']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
  /** Stack trace recorded during fuzzing resulting the crash. */
  stacktraceSnippet?: Maybe<Scalars['String']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a DAST scan */
export type VulnerabilityLocationDast = {
  __typename?: 'VulnerabilityLocationDast';
  /** Domain name of the vulnerable request. */
  hostname?: Maybe<Scalars['String']>;
  /** Query parameter for the URL on which the vulnerability occurred. */
  param?: Maybe<Scalars['String']>;
  /** URL path and query string of the vulnerable request. */
  path?: Maybe<Scalars['String']>;
  /** HTTP method of the vulnerable request. */
  requestMethod?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a dependency security scan */
export type VulnerabilityLocationDependencyScanning = {
  __typename?: 'VulnerabilityLocationDependencyScanning';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Dependency containing the vulnerability. */
  dependency?: Maybe<VulnerableDependency>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a generic scanner. */
export type VulnerabilityLocationGeneric = {
  __typename?: 'VulnerabilityLocationGeneric';
  /** Free-form description of where the vulnerability is located. */
  description?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a SAST scan */
export type VulnerabilityLocationSast = {
  __typename?: 'VulnerabilityLocationSast';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']>;
};

/** Represents the location of a vulnerability found by a secret detection scan */
export type VulnerabilityLocationSecretDetection = {
  __typename?: 'VulnerabilityLocationSecretDetection';
  /** Blob path to the vulnerable file. */
  blobPath?: Maybe<Scalars['String']>;
  /** Number of the last relevant line in the vulnerable file. */
  endLine?: Maybe<Scalars['String']>;
  /** Path to the vulnerable file. */
  file?: Maybe<Scalars['String']>;
  /** Number of the first relevant line in the vulnerable file. */
  startLine?: Maybe<Scalars['String']>;
  /** Class containing the vulnerability. */
  vulnerableClass?: Maybe<Scalars['String']>;
  /** Method containing the vulnerability. */
  vulnerableMethod?: Maybe<Scalars['String']>;
};

/** Check permissions for the current user on a vulnerability */
export type VulnerabilityPermissions = {
  __typename?: 'VulnerabilityPermissions';
  /** Indicates the user can perform `admin_vulnerability` on this resource */
  adminVulnerability: Scalars['Boolean'];
  /** Indicates the user can perform `admin_vulnerability_external_issue_link` on this resource */
  adminVulnerabilityExternalIssueLink: Scalars['Boolean'];
  /** Indicates the user can perform `admin_vulnerability_issue_link` on this resource */
  adminVulnerabilityIssueLink: Scalars['Boolean'];
  /** Indicates the user can perform `create_vulnerability_export` on this resource */
  createVulnerabilityExport: Scalars['Boolean'];
  /** Indicates the user can perform `create_vulnerability_feedback` on this resource */
  createVulnerabilityFeedback: Scalars['Boolean'];
  /** Indicates the user can perform `destroy_vulnerability_feedback` on this resource */
  destroyVulnerabilityFeedback: Scalars['Boolean'];
  /** Indicates the user can perform `read_vulnerability` on this resource */
  readVulnerability: Scalars['Boolean'];
  /** Indicates the user can perform `read_vulnerability_feedback` on this resource */
  readVulnerabilityFeedback: Scalars['Boolean'];
  /** Indicates the user can perform `update_vulnerability_feedback` on this resource */
  updateVulnerabilityFeedback: Scalars['Boolean'];
};

/** Represents a vulnerability remediation type. */
export type VulnerabilityRemediationType = {
  __typename?: 'VulnerabilityRemediationType';
  /** Diff of the remediation. */
  diff?: Maybe<Scalars['String']>;
  /** Summary of the remediation. */
  summary?: Maybe<Scalars['String']>;
};

/** The type of the security scan that found the vulnerability */
export type VulnerabilityReportType =
  /** API Fuzzing report */
  | 'API_FUZZING'
  /** Cluster Image Scanning report */
  | 'CLUSTER_IMAGE_SCANNING'
  /** Container Scanning report */
  | 'CONTAINER_SCANNING'
  /** Coverage Fuzzing report */
  | 'COVERAGE_FUZZING'
  /** DAST report */
  | 'DAST'
  /** Dependency Scanning report */
  | 'DEPENDENCY_SCANNING'
  /** Generic report */
  | 'GENERIC'
  /** SAST report */
  | 'SAST'
  /** Secret Detection report */
  | 'SECRET_DETECTION';

/** Represents a Vulnerability Request */
export type VulnerabilityRequest = {
  __typename?: 'VulnerabilityRequest';
  /** Body of the Vulnerability Request. */
  body?: Maybe<Scalars['String']>;
  /** HTTP headers of the Vulnerability Request. */
  headers: Array<VulnerabilityRequestResponseHeader>;
  /** Method of the Vulnerability Request. */
  method?: Maybe<Scalars['String']>;
  /** URL of the Vulnerability Request. */
  url?: Maybe<Scalars['String']>;
};

/** Represents a Vulnerability Request/Response Header */
export type VulnerabilityRequestResponseHeader = {
  __typename?: 'VulnerabilityRequestResponseHeader';
  /** Name of the Vulnerability Request/Response Header. */
  name?: Maybe<Scalars['String']>;
  /** Value of the Vulnerability Request/Response Header. */
  value?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of VulnerabilityResolve */
export type VulnerabilityResolveInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Comment why vulnerability was resolved (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be resolved. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityResolve */
export type VulnerabilityResolvePayload = {
  __typename?: 'VulnerabilityResolvePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a Vulnerability Response */
export type VulnerabilityResponse = {
  __typename?: 'VulnerabilityResponse';
  /** Body of the Vulnerability Response. */
  body?: Maybe<Scalars['String']>;
  /** HTTP headers of the Vulnerability Response. */
  headers: Array<VulnerabilityRequestResponseHeader>;
  /** Reason Phrase of the Vulnerability Response. */
  reasonPhrase?: Maybe<Scalars['String']>;
  /** Status Code of the Vulnerability Response. */
  statusCode?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of VulnerabilityRevertToDetected */
export type VulnerabilityRevertToDetectedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Comment why vulnerability was reverted to detected (maximum 50,000 characters). */
  comment?: InputMaybe<Scalars['String']>;
  /** ID of the vulnerability to be reverted to detected. */
  id: Scalars['VulnerabilityID'];
};

/** Autogenerated return type of VulnerabilityRevertToDetected */
export type VulnerabilityRevertToDetectedPayload = {
  __typename?: 'VulnerabilityRevertToDetectedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Vulnerability after state change. */
  vulnerability?: Maybe<Vulnerability>;
};

/** Represents a vulnerability scanner */
export type VulnerabilityScanner = {
  __typename?: 'VulnerabilityScanner';
  /** External ID of the vulnerability scanner. */
  externalId?: Maybe<Scalars['String']>;
  /** ID of the scanner. */
  id?: Maybe<Scalars['ID']>;
  /** Name of the vulnerability scanner. */
  name?: Maybe<Scalars['String']>;
  /** Type of the vulnerability report. */
  reportType?: Maybe<VulnerabilityReportType>;
  /** Humanized type of the vulnerability report. */
  reportTypeHumanized?: Maybe<Scalars['String']>;
  /** Vendor of the vulnerability scanner. */
  vendor?: Maybe<Scalars['String']>;
};

/** The connection type for VulnerabilityScanner. */
export type VulnerabilityScannerConnection = {
  __typename?: 'VulnerabilityScannerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityScannerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityScanner>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityScannerEdge = {
  __typename?: 'VulnerabilityScannerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityScanner>;
};

export type VulnerabilityScannerInput = {
  /** Unique ID that identifies the scanner. */
  id: Scalars['String'];
  /** Human readable value that identifies the analyzer, not required to be unique. */
  name: Scalars['String'];
  /** Link to more information about the analyzer. */
  url: Scalars['String'];
  /** Information about vendor/maintainer of the scanner. */
  vendor?: InputMaybe<VulnerabilityScannerVendorInput>;
  /** Version of the scanner. */
  version: Scalars['String'];
};

export type VulnerabilityScannerVendorInput = {
  /** Name of the vendor/maintainer. */
  name: Scalars['String'];
};

/** Represents vulnerability counts by severity */
export type VulnerabilitySeveritiesCount = {
  __typename?: 'VulnerabilitySeveritiesCount';
  /** Number of vulnerabilities of CRITICAL severity of the project */
  critical?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of HIGH severity of the project */
  high?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of INFO severity of the project */
  info?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of LOW severity of the project */
  low?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of MEDIUM severity of the project */
  medium?: Maybe<Scalars['Int']>;
  /** Number of vulnerabilities of UNKNOWN severity of the project */
  unknown?: Maybe<Scalars['Int']>;
};

/** The severity of the vulnerability */
export type VulnerabilitySeverity =
  /** Critical severity */
  | 'CRITICAL'
  /** High severity */
  | 'HIGH'
  /** Info severity */
  | 'INFO'
  /** Low severity */
  | 'LOW'
  /** Medium severity */
  | 'MEDIUM'
  /** Unknown severity */
  | 'UNKNOWN';

/** Vulnerability sort values */
export type VulnerabilitySort =
  /** Detection timestamp in ascending order. */
  | 'detected_asc'
  /** Detection timestamp in descending order. */
  | 'detected_desc'
  /** Severity in ascending order. */
  | 'severity_asc'
  /** Severity in descending order. */
  | 'severity_desc';

/** The state of the vulnerability */
export type VulnerabilityState =
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  | 'CONFIRMED'
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  | 'DETECTED'
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  | 'DISMISSED'
  /** For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values). */
  | 'RESOLVED';

/** Represents a state transition of a vulnerability */
export type VulnerabilityStateTransitionType = {
  __typename?: 'VulnerabilityStateTransitionType';
  /** User who changed the state of the vulnerability. */
  author?: Maybe<UserCore>;
  /** Comment for the state change. */
  comment?: Maybe<Scalars['String']>;
  /** Time of the state change of the vulnerability. */
  createdAt: Scalars['Time'];
  /** Reason for the dismissal. */
  dismissalReason?: Maybe<VulnerabilityDismissalReason>;
  /** State of the vulnerability before transition. */
  fromState: VulnerabilityState;
  /** State of the vulnerability after transition. */
  toState: VulnerabilityState;
};

/** The connection type for VulnerabilityStateTransitionType. */
export type VulnerabilityStateTransitionTypeConnection = {
  __typename?: 'VulnerabilityStateTransitionTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VulnerabilityStateTransitionTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VulnerabilityStateTransitionType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type VulnerabilityStateTransitionTypeEdge = {
  __typename?: 'VulnerabilityStateTransitionTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<VulnerabilityStateTransitionType>;
};

/** Represents a vulnerable dependency. Used in vulnerability location data */
export type VulnerableDependency = {
  __typename?: 'VulnerableDependency';
  /** Package associated with the vulnerable dependency. */
  package?: Maybe<VulnerablePackage>;
  /** Version of the vulnerable dependency. */
  version?: Maybe<Scalars['String']>;
};

/** Represents a vulnerable Kubernetes resource. Used in vulnerability location data */
export type VulnerableKubernetesResource = {
  __typename?: 'VulnerableKubernetesResource';
  /** Kubernetes Agent which performed the scan. */
  agent?: Maybe<ClusterAgent>;
  /** ID of the Cluster integration which was used to perform the scan. */
  clusterId?: Maybe<Scalars['ClustersClusterID']>;
  /** Name of the container that had its image scanned. */
  containerName: Scalars['String'];
  /** Kind of the Kubernetes resource. */
  kind: Scalars['String'];
  /** Name of the Kubernetes resource. */
  name: Scalars['String'];
  /** Kubernetes namespace which the resource resides in. */
  namespace: Scalars['String'];
};

/** Represents a vulnerable package. Used in vulnerability dependency data */
export type VulnerablePackage = {
  __typename?: 'VulnerablePackage';
  /** Name of the vulnerable package. */
  name?: Maybe<Scalars['String']>;
};

/** Represents vulnerability letter grades with associated projects */
export type VulnerableProjectsByGrade = {
  __typename?: 'VulnerableProjectsByGrade';
  /** Number of projects within this grade. */
  count: Scalars['Int'];
  /** Grade based on the highest severity vulnerability present. */
  grade: VulnerabilityGrade;
  /** Projects within this grade. */
  projects: ProjectConnection;
};


/** Represents vulnerability letter grades with associated projects */
export type VulnerableProjectsByGradeProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Weight ID wildcard values */
export type WeightWildcardId =
  /** Weight is assigned. */
  | 'ANY'
  /** No weight is assigned. */
  | 'NONE';

export type WorkItem = Todoable & {
  __typename?: 'WorkItem';
  /**
   * User that created the work item. Introduced in 15.9: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  author?: Maybe<UserCore>;
  /** Timestamp of when the work item was closed. */
  closedAt?: Maybe<Scalars['Time']>;
  /** Indicates the work item is confidential. */
  confidential: Scalars['Boolean'];
  /** User specific email address for the work item. */
  createNoteEmail?: Maybe<Scalars['String']>;
  /** Timestamp of when the work item was created. */
  createdAt: Scalars['Time'];
  /** Description of the work item. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Internal ID of the work item. */
  iid: Scalars['ID'];
  /** Lock version of the work item. Incremented each time the work item is updated. */
  lockVersion: Scalars['Int'];
  /**
   * Namespace the work item belongs to. Introduced in 15.10: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.
   */
  namespace?: Maybe<Namespace>;
  /**
   * Project the work item belongs to. Introduced in 15.3: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.
   */
  project?: Maybe<Project>;
  /** Internal reference of the work item. Returned in shortened format by default. */
  reference: Scalars['String'];
  /** State of the work item. */
  state: WorkItemState;
  /** Title of the work item. */
  title: Scalars['String'];
  /** GitLab Flavored Markdown rendering of `title` */
  titleHtml?: Maybe<Scalars['String']>;
  /** Timestamp of when the work item was last updated. */
  updatedAt: Scalars['Time'];
  /** Permissions for the current user on the resource */
  userPermissions: WorkItemPermissions;
  /** URL of this object. */
  webUrl?: Maybe<Scalars['String']>;
  /** Collection of widgets that belong to the work item. */
  widgets?: Maybe<Array<WorkItemWidget>>;
  /** Type assigned to the work item. */
  workItemType: WorkItemType;
};


export type WorkItemReferenceArgs = {
  full?: InputMaybe<Scalars['Boolean']>;
};

/** Values for work item award emoji update enum */
export type WorkItemAwardEmojiUpdateAction =
  /** Adds the emoji. */
  | 'ADD'
  /** Removes the emoji. */
  | 'REMOVE';

/** The connection type for WorkItem. */
export type WorkItemConnection = {
  __typename?: 'WorkItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of WorkItemConvert */
export type WorkItemConvertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Global ID of the new work item type. */
  workItemTypeId: Scalars['WorkItemsTypeID'];
};

/** Autogenerated return type of WorkItemConvert */
export type WorkItemConvertPayload = {
  __typename?: 'WorkItemConvertPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemConvertTaskInput = {
  /** Last line in the Markdown source that defines the list item task. */
  lineNumberEnd: Scalars['Int'];
  /** First line in the Markdown source that defines the list item task. */
  lineNumberStart: Scalars['Int'];
  /** Current lock version of the work item containing the task in the description. */
  lockVersion: Scalars['Int'];
  /** Full string of the task to be replaced. New title for the created work item. */
  title: Scalars['String'];
  /** Global ID of the work item type used to create the new work item. */
  workItemTypeId: Scalars['WorkItemsTypeID'];
};

/** Autogenerated input type of WorkItemCreateFromTask */
export type WorkItemCreateFromTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Arguments necessary to convert a task into a work item. */
  workItemData: WorkItemConvertTaskInput;
};

/** Autogenerated return type of WorkItemCreateFromTask */
export type WorkItemCreateFromTaskPayload = {
  __typename?: 'WorkItemCreateFromTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** New work item created from task. */
  newWorkItem?: Maybe<WorkItem>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemCreate */
export type WorkItemCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Description of the work item. */
  description?: InputMaybe<Scalars['String']>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyCreateInput>;
  /** Iteration widget of the work item. */
  iterationWidget?: InputMaybe<WorkItemWidgetIterationInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Full path of the namespace(project or group) the work item is created in. */
  namespacePath?: InputMaybe<Scalars['ID']>;
  /**
   * Full path of the project the work item is associated with. Deprecated in
   * 15.10: Please use namespace_path instead. That will cover for both projects and groups.
   * @deprecated Please use namespace_path instead. That will cover for both projects and groups. Deprecated in 15.10.
   */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Title of the work item. */
  title: Scalars['String'];
  /** Global ID of a work item type. */
  workItemTypeId: Scalars['WorkItemsTypeID'];
};

/** Autogenerated return type of WorkItemCreate */
export type WorkItemCreatePayload = {
  __typename?: 'WorkItemCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemDelete */
export type WorkItemDeleteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
};

/** Autogenerated return type of WorkItemDelete */
export type WorkItemDeletePayload = {
  __typename?: 'WorkItemDeletePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Project the deleted work item belonged to. */
  project?: Maybe<Project>;
};

/** Autogenerated input type of WorkItemDeleteTask */
export type WorkItemDeleteTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Current lock version of the work item containing the task in the description. */
  lockVersion: Scalars['Int'];
  /** Arguments necessary to delete a task from a work item's description. */
  taskData: WorkItemDeletedTaskInput;
};

/** Autogenerated return type of WorkItemDeleteTask */
export type WorkItemDeleteTaskPayload = {
  __typename?: 'WorkItemDeleteTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemDeletedTaskInput = {
  /** Global ID of the task referenced in the work item's description. */
  id: Scalars['WorkItemID'];
  /** Last line in the Markdown source that defines the list item task. */
  lineNumberEnd: Scalars['Int'];
  /** First line in the Markdown source that defines the list item task. */
  lineNumberStart: Scalars['Int'];
};

/** An edge in a connection. */
export type WorkItemEdge = {
  __typename?: 'WorkItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemExport */
export type WorkItemExportInput = {
  /**
   * Filter work items by author username. Introduced in 15.9: This feature is an
   * Experiment. It can be changed or removed at any time.
   * @deprecated This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.
   */
  authorUsername?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** List of IIDs of work items. For example, `["1", "2"]`. */
  iids?: InputMaybe<Array<Scalars['String']>>;
  /**
   * Specify the fields to perform the search in.
   * Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
   */
  in?: InputMaybe<Array<IssuableSearchableField>>;
  /** Full project path. */
  projectPath: Scalars['ID'];
  /** Search query for title or description. */
  search?: InputMaybe<Scalars['String']>;
  /** List of selected fields to be exported. Omit to export all available fields. */
  selectedFields?: InputMaybe<Array<AvailableExportFields>>;
  /** Current state of the work item. */
  state?: InputMaybe<IssuableState>;
  /** Filter work items by the given work item types. */
  types?: InputMaybe<Array<IssueType>>;
};

/** Autogenerated return type of WorkItemExport */
export type WorkItemExportPayload = {
  __typename?: 'WorkItemExportPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Export request result message. */
  message?: Maybe<Scalars['String']>;
};

/** Check permissions for the current user on a work item */
export type WorkItemPermissions = {
  __typename?: 'WorkItemPermissions';
  /** Indicates the user can perform `admin_parent_link` on this resource */
  adminParentLink: Scalars['Boolean'];
  /** Indicates the user can perform `admin_work_item` on this resource */
  adminWorkItem: Scalars['Boolean'];
  /** Indicates the user can perform `create_note` on this resource */
  createNote: Scalars['Boolean'];
  /** Indicates the user can perform `delete_work_item` on this resource */
  deleteWorkItem: Scalars['Boolean'];
  /** Indicates the user can perform `read_work_item` on this resource */
  readWorkItem: Scalars['Boolean'];
  /** Indicates the user can perform `set_work_item_metadata` on this resource */
  setWorkItemMetadata: Scalars['Boolean'];
  /** Indicates the user can perform `update_work_item` on this resource */
  updateWorkItem: Scalars['Boolean'];
};

/** Values for sorting work items */
export type WorkItemSort =
  /** Created at ascending order. */
  | 'CREATED_ASC'
  /** Created at descending order. */
  | 'CREATED_DESC'
  /** Title by ascending order. */
  | 'TITLE_ASC'
  /** Title by descending order. */
  | 'TITLE_DESC'
  /** Updated at ascending order. */
  | 'UPDATED_ASC'
  /** Updated at descending order. */
  | 'UPDATED_DESC'
  /** Created at ascending order. */
  | 'created_asc'
  /** Created at descending order. */
  | 'created_desc'
  /** Updated at ascending order. */
  | 'updated_asc'
  /** Updated at descending order. */
  | 'updated_desc';

/** State of a GitLab work item */
export type WorkItemState =
  /** In closed state. */
  | 'CLOSED'
  /** In open state. */
  | 'OPEN';

/** Values for work item state events */
export type WorkItemStateEvent =
  /** Closes the work item. */
  | 'CLOSE'
  /** Reopens the work item. */
  | 'REOPEN';

/** Values for work item to-do update enum */
export type WorkItemTodoUpdateAction =
  /** Adds the to-do. */
  | 'ADD'
  /** Marks the to-do as done. */
  | 'MARK_AS_DONE';

export type WorkItemType = {
  __typename?: 'WorkItemType';
  /** Icon name of the work item type. */
  iconName?: Maybe<Scalars['String']>;
  /** Global ID of the work item type. */
  id: Scalars['WorkItemsTypeID'];
  /** Name of the work item type. */
  name: Scalars['String'];
};

/** The connection type for WorkItemType. */
export type WorkItemTypeConnection = {
  __typename?: 'WorkItemTypeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkItemTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WorkItemType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type WorkItemTypeEdge = {
  __typename?: 'WorkItemTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkItemType>;
};

/** Autogenerated input type of WorkItemUpdate */
export type WorkItemUpdateInput = {
  /** Input for assignees widget. */
  assigneesWidget?: InputMaybe<WorkItemWidgetAssigneesInput>;
  /** Input for award emoji widget. */
  awardEmojiWidget?: InputMaybe<WorkItemWidgetAwardEmojiUpdateInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Input for to-dos widget. */
  currentUserTodosWidget?: InputMaybe<WorkItemWidgetCurrentUserTodosInput>;
  /** Input for description widget. */
  descriptionWidget?: InputMaybe<WorkItemWidgetDescriptionInput>;
  /** Input for health status widget. */
  healthStatusWidget?: InputMaybe<WorkItemWidgetHealthStatusInput>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyUpdateInput>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Input for iteration widget. */
  iterationWidget?: InputMaybe<WorkItemWidgetIterationInput>;
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsUpdateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Input for notifications widget. */
  notificationsWidget?: InputMaybe<WorkItemWidgetNotificationsUpdateInput>;
  /** Input for progress widget. */
  progressWidget?: InputMaybe<WorkItemWidgetProgressInput>;
  /** Input for start and due date widget. */
  startAndDueDateWidget?: InputMaybe<WorkItemWidgetStartAndDueDateUpdateInput>;
  /** Close or reopen a work item. */
  stateEvent?: InputMaybe<WorkItemStateEvent>;
  /** Input for status widget. */
  statusWidget?: InputMaybe<StatusInput>;
  /** Title of the work item. */
  title?: InputMaybe<Scalars['String']>;
  /** Input for weight widget. */
  weightWidget?: InputMaybe<WorkItemWidgetWeightInput>;
};

/** Autogenerated return type of WorkItemUpdate */
export type WorkItemUpdatePayload = {
  __typename?: 'WorkItemUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

/** Autogenerated input type of WorkItemUpdateTask */
export type WorkItemUpdateTaskInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Arguments necessary to update a task. */
  taskData: WorkItemUpdatedTaskInput;
};

/** Autogenerated return type of WorkItemUpdateTask */
export type WorkItemUpdateTaskPayload = {
  __typename?: 'WorkItemUpdateTaskPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Updated task. */
  task?: Maybe<WorkItem>;
  /** Updated work item. */
  workItem?: Maybe<WorkItem>;
};

export type WorkItemUpdatedTaskInput = {
  /** Input for assignees widget. */
  assigneesWidget?: InputMaybe<WorkItemWidgetAssigneesInput>;
  /** Input for award emoji widget. */
  awardEmojiWidget?: InputMaybe<WorkItemWidgetAwardEmojiUpdateInput>;
  /** Sets the work item confidentiality. */
  confidential?: InputMaybe<Scalars['Boolean']>;
  /** Input for to-dos widget. */
  currentUserTodosWidget?: InputMaybe<WorkItemWidgetCurrentUserTodosInput>;
  /** Input for description widget. */
  descriptionWidget?: InputMaybe<WorkItemWidgetDescriptionInput>;
  /** Input for hierarchy widget. */
  hierarchyWidget?: InputMaybe<WorkItemWidgetHierarchyUpdateInput>;
  /** Global ID of the work item. */
  id: Scalars['WorkItemID'];
  /** Input for labels widget. */
  labelsWidget?: InputMaybe<WorkItemWidgetLabelsUpdateInput>;
  /** Input for milestone widget. */
  milestoneWidget?: InputMaybe<WorkItemWidgetMilestoneInput>;
  /** Input for notifications widget. */
  notificationsWidget?: InputMaybe<WorkItemWidgetNotificationsUpdateInput>;
  /** Input for start and due date widget. */
  startAndDueDateWidget?: InputMaybe<WorkItemWidgetStartAndDueDateUpdateInput>;
  /** Close or reopen a work item. */
  stateEvent?: InputMaybe<WorkItemStateEvent>;
  /** Title of the work item. */
  title?: InputMaybe<Scalars['String']>;
};

export type WorkItemWidget = {
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents an assignees widget */
export type WorkItemWidgetAssignees = WorkItemWidget & {
  __typename?: 'WorkItemWidgetAssignees';
  /** Indicates whether multiple assignees are allowed. */
  allowsMultipleAssignees?: Maybe<Scalars['Boolean']>;
  /** Assignees of the work item. */
  assignees?: Maybe<UserCoreConnection>;
  /** Indicates whether the current user can invite members to the work item's project. */
  canInviteMembers: Scalars['Boolean'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents an assignees widget */
export type WorkItemWidgetAssigneesAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetAssigneesInput = {
  /** Global IDs of assignees. */
  assigneeIds: Array<Scalars['UserID']>;
};

/** Represents the award emoji widget */
export type WorkItemWidgetAwardEmoji = WorkItemWidget & {
  __typename?: 'WorkItemWidgetAwardEmoji';
  /** Award emoji on the work item. */
  awardEmoji?: Maybe<AwardEmojiConnection>;
  /** Number of downvotes the work item has received. */
  downvotes: Scalars['Int'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Number of upvotes the work item has received. */
  upvotes: Scalars['Int'];
};


/** Represents the award emoji widget */
export type WorkItemWidgetAwardEmojiAwardEmojiArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetAwardEmojiUpdateInput = {
  /** Action for the update. */
  action: WorkItemAwardEmojiUpdateAction;
  /** Emoji name. */
  name: Scalars['String'];
};

/** Represents a todos widget */
export type WorkItemWidgetCurrentUserTodos = CurrentUserTodos & WorkItemWidget & {
  __typename?: 'WorkItemWidgetCurrentUserTodos';
  /** To-do items for the current user. */
  currentUserTodos: TodoConnection;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a todos widget */
export type WorkItemWidgetCurrentUserTodosCurrentUserTodosArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<TodoStateEnum>;
};

export type WorkItemWidgetCurrentUserTodosInput = {
  /** Action for the update. */
  action: WorkItemTodoUpdateAction;
  /** Global ID of the to-do. If not present, all to-dos of the work item will be updated. */
  todoId?: InputMaybe<Scalars['TodoID']>;
};

/** Represents a description widget */
export type WorkItemWidgetDescription = WorkItemWidget & {
  __typename?: 'WorkItemWidgetDescription';
  /** Description of the work item. */
  description?: Maybe<Scalars['String']>;
  /** GitLab Flavored Markdown rendering of `description` */
  descriptionHtml?: Maybe<Scalars['String']>;
  /** Whether the description has been edited since the work item was created. */
  edited: Scalars['Boolean'];
  /** Timestamp of when the work item's description was last edited. */
  lastEditedAt?: Maybe<Scalars['Time']>;
  /** User that made the last edit to the work item's description. */
  lastEditedBy?: Maybe<UserCore>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetDescriptionInput = {
  /** Description of the work item. */
  description: Scalars['String'];
};

/** Represents a health status widget */
export type WorkItemWidgetHealthStatus = WorkItemWidget & {
  __typename?: 'WorkItemWidgetHealthStatus';
  /** Health status of the work item. */
  healthStatus?: Maybe<HealthStatus>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetHealthStatusInput = {
  /** Health status to be assigned to the work item. */
  healthStatus?: InputMaybe<HealthStatus>;
};

/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchy = WorkItemWidget & {
  __typename?: 'WorkItemWidgetHierarchy';
  /** Child work items. */
  children?: Maybe<WorkItemConnection>;
  /** Indicates if the work item has children. */
  hasChildren: Scalars['Boolean'];
  /** Parent work item. */
  parent?: Maybe<WorkItem>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a hierarchy widget */
export type WorkItemWidgetHierarchyChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetHierarchyCreateInput = {
  /** Global ID of the parent work item. */
  parentId?: InputMaybe<Scalars['WorkItemID']>;
};

export type WorkItemWidgetHierarchyUpdateInput = {
  /** ID of the work item to be switched with. */
  adjacentWorkItemId?: InputMaybe<Scalars['WorkItemID']>;
  /** Global IDs of children work items. */
  childrenIds?: InputMaybe<Array<Scalars['WorkItemID']>>;
  /** Global ID of the parent work item. Use `null` to remove the association. */
  parentId?: InputMaybe<Scalars['WorkItemID']>;
  /** Type of switch. Valid values are `BEFORE` or `AFTER`. */
  relativePosition?: InputMaybe<RelativePositionType>;
};

/** Represents an iteration widget */
export type WorkItemWidgetIteration = WorkItemWidget & {
  __typename?: 'WorkItemWidgetIteration';
  /** Iteration of the work item. */
  iteration?: Maybe<Iteration>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetIterationInput = {
  /** Iteration to assign to the work item. */
  iterationId?: InputMaybe<Scalars['IterationID']>;
};

/** Represents the labels widget */
export type WorkItemWidgetLabels = WorkItemWidget & {
  __typename?: 'WorkItemWidgetLabels';
  /** Indicates whether a scoped label is allowed. */
  allowsScopedLabels?: Maybe<Scalars['Boolean']>;
  /** Labels assigned to the work item. */
  labels?: Maybe<LabelConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents the labels widget */
export type WorkItemWidgetLabelsLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type WorkItemWidgetLabelsUpdateInput = {
  /** Global IDs of labels to be added to the work item. */
  addLabelIds?: InputMaybe<Array<Scalars['LabelID']>>;
  /** Global IDs of labels to be removed from the work item. */
  removeLabelIds?: InputMaybe<Array<Scalars['LabelID']>>;
};

/** Represents a milestone widget */
export type WorkItemWidgetMilestone = WorkItemWidget & {
  __typename?: 'WorkItemWidgetMilestone';
  /** Milestone of the work item. */
  milestone?: Maybe<Milestone>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetMilestoneInput = {
  /** Milestone to assign to the work item. */
  milestoneId?: InputMaybe<Scalars['MilestoneID']>;
};

/** Represents a notes widget */
export type WorkItemWidgetNotes = WorkItemWidget & {
  __typename?: 'WorkItemWidgetNotes';
  /** Notes on this work item. */
  discussions?: Maybe<DiscussionConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a notes widget */
export type WorkItemWidgetNotesDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<NotesFilterType>;
  first?: InputMaybe<Scalars['Int']>;
};

/** Represents the notifications widget */
export type WorkItemWidgetNotifications = WorkItemWidget & {
  __typename?: 'WorkItemWidgetNotifications';
  /** Whether the current user is subscribed to notifications on the work item. */
  subscribed: Scalars['Boolean'];
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetNotificationsUpdateInput = {
  /** Desired state of the subscription. */
  subscribed: Scalars['Boolean'];
};

/** Represents a progress widget */
export type WorkItemWidgetProgress = WorkItemWidget & {
  __typename?: 'WorkItemWidgetProgress';
  /** Progress of the work item. */
  progress?: Maybe<Scalars['Int']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetProgressInput = {
  /** Progress of the work item. */
  progress: Scalars['Int'];
};

/** Represents a legacy requirement widget */
export type WorkItemWidgetRequirementLegacy = WorkItemWidget & {
  __typename?: 'WorkItemWidgetRequirementLegacy';
  /**
   * Legacy requirement IID associated with the work item. Deprecated in 15.9: Use Work Item IID instead.
   * @deprecated Use Work Item IID instead. Deprecated in 15.9.
   */
  legacyIid?: Maybe<Scalars['Int']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents a start and due date widget */
export type WorkItemWidgetStartAndDueDate = WorkItemWidget & {
  __typename?: 'WorkItemWidgetStartAndDueDate';
  /** Due date of the work item. */
  dueDate?: Maybe<Scalars['Date']>;
  /** Start date of the work item. */
  startDate?: Maybe<Scalars['Date']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

export type WorkItemWidgetStartAndDueDateUpdateInput = {
  /** Due date for the work item. */
  dueDate?: InputMaybe<Scalars['Date']>;
  /** Start date for the work item. */
  startDate?: InputMaybe<Scalars['Date']>;
};

/** Represents a status widget */
export type WorkItemWidgetStatus = WorkItemWidget & {
  __typename?: 'WorkItemWidgetStatus';
  /** Status of the work item. */
  status?: Maybe<Scalars['String']>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};

/** Represents a test reports widget */
export type WorkItemWidgetTestReports = WorkItemWidget & {
  __typename?: 'WorkItemWidgetTestReports';
  /** Test reports of the work item. */
  testReports?: Maybe<TestReportConnection>;
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
};


/** Represents a test reports widget */
export type WorkItemWidgetTestReportsTestReportsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Type of a work item widget */
export type WorkItemWidgetType =
  /** Assignees widget. */
  | 'ASSIGNEES'
  /** Award Emoji widget. */
  | 'AWARD_EMOJI'
  /** Current User Todos widget. */
  | 'CURRENT_USER_TODOS'
  /** Description widget. */
  | 'DESCRIPTION'
  /** Health Status widget. */
  | 'HEALTH_STATUS'
  /** Hierarchy widget. */
  | 'HIERARCHY'
  /** Iteration widget. */
  | 'ITERATION'
  /** Labels widget. */
  | 'LABELS'
  /** Milestone widget. */
  | 'MILESTONE'
  /** Notes widget. */
  | 'NOTES'
  /** Notifications widget. */
  | 'NOTIFICATIONS'
  /** Progress widget. */
  | 'PROGRESS'
  /** Requirement Legacy widget. */
  | 'REQUIREMENT_LEGACY'
  /** Start And Due Date widget. */
  | 'START_AND_DUE_DATE'
  /** Status widget. */
  | 'STATUS'
  /** Test Reports widget. */
  | 'TEST_REPORTS'
  /** Weight widget. */
  | 'WEIGHT';

/** Represents a weight widget */
export type WorkItemWidgetWeight = WorkItemWidget & {
  __typename?: 'WorkItemWidgetWeight';
  /** Widget type. */
  type?: Maybe<WorkItemWidgetType>;
  /** Weight of the work item. */
  weight?: Maybe<Scalars['Int']>;
};

export type WorkItemWidgetWeightInput = {
  /** Weight of the work item. */
  weight?: InputMaybe<Scalars['Int']>;
};

/** Represents a remote development workspace */
export type Workspace = {
  __typename?: 'Workspace';
  /** Actual state of the workspace. */
  actualState: Scalars['String'];
  /** Kubernetes Agent associated with the workspace. */
  clusterAgent: ClusterAgent;
  /** Timestamp of workspace creation. */
  createdAt: Scalars['Time'];
  /** ResourceVersion of the Deployment resource for the workspace. */
  deploymentResourceVersion?: Maybe<Scalars['Int']>;
  /** Desired state of the workspace. */
  desiredState: Scalars['String'];
  /** Timestamp of last update to desired state. */
  desiredStateUpdatedAt: Scalars['Time'];
  /** Source YAML of the devfile used to configure the workspace. */
  devfile: Scalars['String'];
  /** Project repo git path containing the devfile used to configure the workspace. */
  devfilePath: Scalars['String'];
  /** Project repo git ref containing the devfile used to configure the workspace. */
  devfileRef: Scalars['String'];
  /** Editor used to configure the workspace. Must match a configured template. */
  editor: Scalars['String'];
  /** Global ID of the workspace. */
  id: Scalars['RemoteDevelopmentWorkspaceID'];
  /** Maximum hours the workspace can exist before it is automatically terminated. */
  maxHoursBeforeTermination: Scalars['Int'];
  /** Name of the workspace in Kubernetes. */
  name: Scalars['String'];
  /** Namespace of the workspace in Kubernetes. */
  namespace: Scalars['String'];
  /** Processed YAML of the devfile used to configure the workspace. */
  processedDevfile: Scalars['String'];
  /** ID of the Project providing the Devfile for the workspace. */
  projectId: Scalars['ID'];
  /** Timestamp of last response sent to GA4K for the workspace. */
  respondedToAgentAt?: Maybe<Scalars['Time']>;
  /** Timestamp of last update to any mutable workspace property. */
  updatedAt: Scalars['Time'];
  /** URL of the workspace. */
  url: Scalars['String'];
  /** Owner of the workspace. */
  user: UserCore;
};

/** The connection type for Workspace. */
export type WorkspaceConnection = {
  __typename?: 'WorkspaceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkspaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Workspace>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Autogenerated input type of WorkspaceCreate */
export type WorkspaceCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the cluster agent the created workspace will be associated with. */
  clusterAgentId: Scalars['ClustersAgentID'];
  /** Desired state of the created workspace. */
  desiredState: Scalars['String'];
  /** Project repo git path containing the devfile used to configure the workspace. */
  devfilePath: Scalars['String'];
  /** Project repo git ref containing the devfile used to configure the workspace. */
  devfileRef: Scalars['String'];
  /** Editor to inject into the created workspace. Must match a configured template. */
  editor: Scalars['String'];
  /** Maximum hours the workspace can exist before it is automatically terminated. */
  maxHoursBeforeTermination: Scalars['Int'];
  /** ID of the project that will provide the Devfile for the created workspace. */
  projectId: Scalars['ProjectID'];
};

/** Autogenerated return type of WorkspaceCreate */
export type WorkspaceCreatePayload = {
  __typename?: 'WorkspaceCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created workspace. */
  workspace?: Maybe<Workspace>;
};

/** An edge in a connection. */
export type WorkspaceEdge = {
  __typename?: 'WorkspaceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Workspace>;
};

/** Autogenerated input type of WorkspaceUpdate */
export type WorkspaceUpdateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Desired state of the created workspace. */
  desiredState: Scalars['String'];
  /** Global ID of the workspace. */
  id: Scalars['RemoteDevelopmentWorkspaceID'];
};

/** Autogenerated return type of WorkspaceUpdate */
export type WorkspaceUpdatePayload = {
  __typename?: 'WorkspaceUpdatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created workspace. */
  workspace?: Maybe<Workspace>;
};

/** Represents an X.509 certificate. */
export type X509Certificate = {
  __typename?: 'X509Certificate';
  /** Indicates if the certificate is good or revoked. */
  certificateStatus: Scalars['String'];
  /** Timestamp of when the certificate was saved. */
  createdAt: Scalars['Time'];
  /** Email associated with the cerificate. */
  email: Scalars['String'];
  /** ID of the certificate. */
  id: Scalars['ID'];
  /** Serial number of the certificate. */
  serialNumber: Scalars['String'];
  /** Subject of the certificate. */
  subject: Scalars['String'];
  /** Subject key identifier of the certificate. */
  subjectKeyIdentifier: Scalars['String'];
  /** Timestamp of when the certificate was last updated. */
  updatedAt: Scalars['Time'];
  /** Issuer of the certificate. */
  x509Issuer: X509Issuer;
};

/** Issuer of an X.509 certificate. */
export type X509Issuer = {
  __typename?: 'X509Issuer';
  /** Timestamp of when the issuer was created. */
  createdAt?: Maybe<Scalars['Time']>;
  /** Certificate revokation list of the issuer. */
  crlUrl?: Maybe<Scalars['String']>;
  /** ID of the issuer. */
  id?: Maybe<Scalars['ID']>;
  /** Subject of the issuer. */
  subject?: Maybe<Scalars['String']>;
  /** Subject key identifier of the issuer. */
  subjectKeyIdentifier?: Maybe<Scalars['String']>;
  /** Timestamp of when the issuer was last updated. */
  updatedAt?: Maybe<Scalars['Time']>;
};

/** X.509 signature for a signed commit */
export type X509Signature = CommitSignature & {
  __typename?: 'X509Signature';
  /** SHA of the associated commit. */
  commitSha?: Maybe<Scalars['String']>;
  /** Project of the associated commit. */
  project?: Maybe<Project>;
  /** User associated with the key. */
  user?: Maybe<UserCore>;
  /** Indicates verification status of the associated key or certificate. */
  verificationStatus?: Maybe<VerificationStatus>;
  /** Certificate used for the signature. */
  x509Certificate?: Maybe<X509Certificate>;
};

/** Autogenerated input type of iterationCreate */
export type IterationCreateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Description of the iteration. */
  description?: InputMaybe<Scalars['String']>;
  /** End date of the iteration. */
  dueDate?: InputMaybe<Scalars['String']>;
  /** Full path of the group with which the resource is associated. */
  groupPath?: InputMaybe<Scalars['ID']>;
  /** Global ID of the iteration cadence to be assigned to the new iteration. */
  iterationsCadenceId?: InputMaybe<Scalars['IterationsCadenceID']>;
  /** Full path of the project with which the resource is associated. */
  projectPath?: InputMaybe<Scalars['ID']>;
  /** Start date of the iteration. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Title of the iteration. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of iterationCreate */
export type IterationCreatePayload = {
  __typename?: 'iterationCreatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Errors encountered during execution of the mutation. */
  errors: Array<Scalars['String']>;
  /** Created iteration. */
  iteration?: Maybe<Iteration>;
};

export type CreateCommitMutationVariables = Exact<{
  fullPath: Scalars['ID'];
  appId?: InputMaybe<Scalars['String']>;
  branch: Scalars['String'];
  commitMessage: Scalars['String'];
  actions: Array<CommitAction> | CommitAction;
}>;


export type CreateCommitMutation = { __typename?: 'Mutation', commitCreate?: { __typename?: 'CommitCreatePayload', errors: Array<string>, commit?: { __typename?: 'Commit', sha: string } | null } | null };

export type GetAllRepositoriesForOwnerQueryVariables = Exact<{
  login: Scalars['ID'];
}>;


export type GetAllRepositoriesForOwnerQuery = { __typename?: 'Query', namespace?: { __typename?: 'Namespace', projects: { __typename?: 'ProjectConnection', nodes?: Array<{ __typename?: 'Project', fullPath: string } | null> | null } } | null };

export type GetAllRepositoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllRepositoriesQuery = { __typename?: 'Query', projects?: { __typename?: 'ProjectConnection', nodes?: Array<{ __typename?: 'Project', name: string, namespace?: { __typename?: 'Namespace', path: string } | null } | null> | null } | null };

export type GetNamespaceIdQueryVariables = Exact<{
  name: Scalars['ID'];
}>;


export type GetNamespaceIdQuery = { __typename?: 'Query', namespace?: { __typename?: 'Namespace', id: string } | null };

export type IsRepositoryArchivedQueryVariables = Exact<{
  fullPath: Scalars['ID'];
}>;


export type IsRepositoryArchivedQuery = { __typename?: 'Query', project?: { __typename?: 'Project', archived?: boolean | null } | null };

export type SearchByFilePathQueryVariables = Exact<{
  filePath?: InputMaybe<Scalars['String']>;
}>;


export type SearchByFilePathQuery = { __typename?: 'Query', projects?: { __typename?: 'ProjectConnection', nodes?: Array<{ __typename?: 'Project', fullPath: string, repository?: { __typename?: 'Repository', tree?: { __typename?: 'Tree', lastCommit?: { __typename?: 'Commit', shortId: string } | null } | null } | null } | null> | null } | null };


export const CreateCommitDocument = gql`
    mutation createCommit($fullPath: ID!, $appId: String, $branch: String!, $commitMessage: String!, $actions: [CommitAction!]!) {
  commitCreate(
    input: {projectPath: $fullPath, clientMutationId: $appId, branch: $branch, message: $commitMessage, actions: $actions}
  ) {
    errors
    commit {
      sha
    }
  }
}
    `;
export const GetAllRepositoriesForOwnerDocument = gql`
    query getAllRepositoriesForOwner($login: ID!) {
  namespace(fullPath: $login) {
    projects {
      nodes {
        fullPath
      }
    }
  }
}
    `;
export const GetAllRepositoriesDocument = gql`
    query getAllRepositories {
  projects(membership: true) {
    nodes {
      name
      namespace {
        path
      }
    }
  }
}
    `;
export const GetNamespaceIdDocument = gql`
    query getNamespaceId($name: ID!) {
  namespace(fullPath: $name) {
    id
  }
}
    `;
export const IsRepositoryArchivedDocument = gql`
    query isRepositoryArchived($fullPath: ID!) {
  project(fullPath: $fullPath) {
    archived
  }
}
    `;
export const SearchByFilePathDocument = gql`
    query searchByFilePath($filePath: String) {
  projects(membership: true) {
    nodes {
      fullPath
      repository {
        tree(path: $filePath) {
          lastCommit {
            shortId
          }
        }
      }
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    createCommit(variables: CreateCommitMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<CreateCommitMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateCommitMutation>(CreateCommitDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createCommit', 'mutation');
    },
    getAllRepositoriesForOwner(variables: GetAllRepositoriesForOwnerQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetAllRepositoriesForOwnerQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAllRepositoriesForOwnerQuery>(GetAllRepositoriesForOwnerDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAllRepositoriesForOwner', 'query');
    },
    getAllRepositories(variables?: GetAllRepositoriesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetAllRepositoriesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAllRepositoriesQuery>(GetAllRepositoriesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAllRepositories', 'query');
    },
    getNamespaceId(variables: GetNamespaceIdQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetNamespaceIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetNamespaceIdQuery>(GetNamespaceIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getNamespaceId', 'query');
    },
    isRepositoryArchived(variables: IsRepositoryArchivedQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<IsRepositoryArchivedQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<IsRepositoryArchivedQuery>(IsRepositoryArchivedDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'isRepositoryArchived', 'query');
    },
    searchByFilePath(variables?: SearchByFilePathQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<SearchByFilePathQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<SearchByFilePathQuery>(SearchByFilePathDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'searchByFilePath', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;